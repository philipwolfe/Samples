
<!--BEGIN HEADER-->
<html>
<head>
<link rel="stylesheet" href="../../../include/qsstyle.css">
</head>
<body topmargin="0" leftmargin="0" marginwidth="0" marginheight="0" >

<table class="outer" cellpadding=0 cellspacing=0>
<tr>
<td class="toc" valign="top" width="210">

<table>
<tr>
<td nowrap style="padding-right:15">

<div class="toc" style="font-size:8pt;color:darkred;">

    <div style="padding:0,0,4,0"><b>Remoting</b><br></div>
    &nbsp; <a class="outer" href="../../../howto/doc/remoting/mainfeatures.htm">Remoting Overview</a><br>
    &nbsp; <a class="outer" href="../../../howto/doc/remoting/nutshell.htm">How Remoting Works</a><br>
    &nbsp; <a class="outer" href="../../../howto/doc/remoting/quickstart.htm">Remoting Samples</a><p>
    <div style="padding:0,0,4,0"><b>The Basics</b><br></div>
    &nbsp; <a class="outer" href="../../../howto/doc/remoting/firstserver.htm">Create a Remote Server</a><br>
    &nbsp; <a class="outer" href="../../../howto/doc/remoting/firstclient.htm">Create a Client of the Server</a><p>
    <div style="padding:0,0,4,0"><b>Samples</b><br></div>
    &nbsp; <a class="outer" href="../../../howto/doc/remoting/singleton.htm">Create a Singleton Object</a><br>
    &nbsp; <a class="outer" href="../../../howto/doc/remoting/byreference.htm">Pass Objects By Reference</a><br>
    &nbsp; <a class="outer" href="../../../howto/doc/remoting/byvalue.htm">Pass Objects By Value</a><br>
    &nbsp; <a class="outer" href="../../../howto/doc/remoting/interface.htm">Compile Against an Interface</a><br>
    &nbsp; <a class="outer" href="../../../howto/doc/remoting/async.htm">Make an Asynchronous Call</a><p>
    <div style="padding:0,0,4,0"><a target="_top" style="color:darkred" href="../../../howto"><b>Back to Index</b></a><br></div>

</div>

</td>
</tr>
</table>






</td>
<td valign="top">
<div class="body">
<!--END HEADER-->

<style>
.mydd {  font: smaller verdana; }
.code1 {
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	background:#DFDFDF;
	font-family:"Courier New";
	color:blue;
	}
.codecomment1 {
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	background:#DFDFDF;
	font-family:"Courier New";
	color:green;
	}
.issue {
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	background-color:RED;
	color:WHITE;
	font-weight:bold;
	}


body { font: smaller verdana }        

</style>





<h4>How Remoting Works</h4>

The .NET remoting framework provides developers with a modern distributed 
object model that allows remote method invocation between different CLR's 
across the network or between different <b>AppDomains</b> in the same CLR.  Any 
interaction with a remote object occurs via a proxy, a client cannot 
access a remote object directly since the object is only meaningful inside 
its own <b>AppDomain.</b>  The following rules apply:<p>

<ul>
<li>All remote objects have to derive from <b>MarshalByRefObject.</b><p>

<li>Any interaction with a remote object occurs by reference through a 
proxy.  Clients have to obtain this proxy activating a remote object.  
This can be done by calling <b>CreateInstance</b>, <b>GetObject</b> or <b>new</b>.<p>

<li>Local objects can be used as parameters when making remote calls.  
Since a reference to a local object is meaningless to a remote object, all 
local objects are passed by value when they are used as parameters in a 
remote call or returned as a result from a remote call.<p>

<li>All objects passed by value must be serializable.  This can be 
achieved by implementing the <b>ISerializable</b> interface or marking the object 
with the [serializable] custom attribute.<p>

</ul>

Remote objects have to be activated before they can be used by a client.  
The framework supports two different activation models, server and client 
activation.  Server activation means the object will automatically be 
instantiated on the server when a client attempts to access the object.  
Client activation on the other hand, means the object will be instantiated 
as the result of a deliberate activation request from a client.  Why two 
different activation models?  The lifetime of an object often becomes an 
issue in distributed object models.  In some cases we require a remote 
object to maintain state across calls while in other case we require 
stateless objects where each caller is given a fresh instance of the 
object on each call.  Sometimes the client requires more control over the 
lifetime of the object than that provided by server activation.  By 
allowing both server as well as client activation, developers have the 
freedom to pick the best activation model for the task at hand.<p>

The previous paragraph describes the seemingly impossible, how can a 
server object listen for clients when it has not been instantiated?  After 
all, the concepts behind remote procedure calls are relatively simple.  A 
server object is created and deployed somewhere on the network where it 
listens for clients to connect.  When a client comes along, details about 
the call and the parameters are transported to server object, the method 
executes and an optional result is transported back to the client.<p>

Lets examine the steps involved in deploying a server object.<p>

<ol>

<li>All remote objects have to be registered with the CLR before they can be 
accessed by a client.  We need to provide the CLR with specific details 
about the object like the name of the assembly that should be loaded to 
activate the object, the namespace and type name of the object as well as 
the name of the endpoint where the object can be accessed.  The framework 
ensures that an object is not registered more than once in the same 
<b>AppDomain.</b><p>

<li>We also need to register all the channels clients will use to 
communicate with the object.  Each channel uses a specific protocol like 
TCP, HTTP or SMTP for example.  More than one channel can be registered where 
applicable.<p>

<li>Details about the object is stored in a table managed by the framework.  
An object reference is then created for object that is also stored.  The 
object reference will be used to represent the registered object in a 
different <b>AppDomain</b> and will be serialized and transported to the client 
when required.<p>

<li>The registered channels then starts listening for clients to connect.<p>

</ol>

Once a remote object has been deployed, clients can connect and invoke methods on the server object.<p>

<ol>

<li>The client registers a channel that will be used to communicate with the 
remote object.  The only requirement here is that the server should be 
listening on a similar channel.<p>

<li>The client then activates the object by calling <b>new</b>, 
<b>GetObject</b> or <b>CreateInstance.</b><p> 

<li>Sufficient information about the type and location of the remote object is 
provided with the activation request for the framework to create proxy to 
represent the remote object.  It is important to note that this process is 
local, no calls have been made to the remote object at all.  The proxy is 
also stored locally in a table, any additional activation request on the 
client side receives the same proxy.<p>

<li>Lets examine what happens in the case of server activated object. 
The client calls a method on the remote object via the proxy it 
received on activation.  The client channel then attempts to establish a 
connection with the remote channel if not already connected.<p>

<li>Once a connection is established, a message sink is connected to either 
side of the connection that handles the details of the communication using 
the specified protocol.<p>

<li>Details of the method call is loaded in a <b>Message</b> object that
is serialized an transported to the server.  The type of serialization
depends on the channel.  For example, when the HTTP channel is used, all
messages are serialized to XML and is transported over SOAP.  TCP on the
other hand, uses binary serialization.<p>

<li>Once the message arrives on the server side, the framework reassembles
the original call, activates the target object if it is not already activated, 
and then forwards the call to the object in question.  Returning a result
back to the client follows the exact opposite path - the result is packageg
in a message that is transported back to the client.  If server object is
of type <b>SingleCall</b>, the object is recycled after the result returns to
the client.<p>

</ol>

<!--END FOOTER-->
<p>
<hr>
<p>
</div>
</td>
</tr>
</table>
</BODY>
</html>
<!--END FOOTER-->