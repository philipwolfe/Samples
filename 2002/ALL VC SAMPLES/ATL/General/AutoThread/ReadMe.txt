===========================================================================

AutoThread:  Demonstrates the use of CAtlAutoThreadModule. 

This sample solution illustrates the use of CAtlAutoThreadModule. It is
made of two projects: The server is implemented in the AutoServer project
as an exe. The client consists of AtlCtl object in the dll project named
AutoClient.

CAtlAutoThreadModule implements a thread-pooled, apartment-model COM server
for EXEs and Windows NT/2000 services. CAtlAutoThreadModule uses CComApartment
to manage an apartment for each thread in the module.

An instance of this class is automatically pulled in when required. You must
use the DECLARE_CLASSFACTORY_AUTO_THREAD macro in your object’s class
definition to specify CComClassFactoryAutoThread as the class factory.

===========================================================================

Sample changes:

Note that this sample has been modified to leverage the new ATL 7.0 class
functionality. The combination of CAtlAutoThreadModule (instead of the old
CComAutoThreadModule class) and the CAtlExeModule, simplify implementation
to a great extent.

The way the old AutoServer worked was by deriving the exe module from 
CComAutoThreadModule instead of wizard generated CComModule class.
This resulted in server having to deal with implementation of methods
that start and monitor thread activity as well as maintain thread
variables.

All this functionality is now built into the CAtlExeModule class, which
is the one generated by wizard as default for exe projects. The threading
support is achieved by adding CAtlAutoThreadModule to the class definition
of our class CAutoSvrModule:

		class CAutoSvrModule : 
			public CAtlExeModuleT< CAutoSvrModule >,
			public CAtlAutoThreadModule
		{
			...
		}

All we need now to have the auto threading working is to make a call to the 
DECLARE_CLASSFACTORY_AUTO_THREAD() macro. This is done in the server interface
object (AutoServ) class definition:

		class ATL_NO_VTABLE CAutoServ :
			...
		{
		public:
			...	
			DECLARE_CLASSFACTORY_AUTO_THREAD()
			...
		}	

The server interface has a single method, Sleep. This method puts the server
thread to sleep for a given amount of time.

The client portion of the sample is an ActiveX control that invokes the
server’s sleep method when it the user clicks on the control. The client
also has a property named Delay that represents how long the server thread
will be put to sleep for. The control displays the text "Ready" when it is
waiting for the user to click. The string "Waiting" is displayed when the
control is waiting for the server to finish sleeping.

===========================================================================

Running the sample:

First compile the AutoServer object and register the server executable. Then
compile the AutoClient client dll. The IDE solution does this for you in a
custom build step. 

Start up two separate instances of the Control Test Container. Insert one of
the client controls into each of the test containers. Click on one of the
controls and notice that it takes one second for the server to return.

Position and resize the test containers so that both of them are visible at
the same time. Click on one of the controls and then quickly click on the other
control. You will notice that they finish waiting at approximately the same time.
  
(If CAtlAutoThreadModule were not used, the first control would finish after one
second but the second control would not finish until a full second after the
first control was finished. The second call to sleep would not occur until the
first had finished.)

You can use the Delay(PropGet) and Delay(PropPut) methods to adjust the number of
milliseconds the server sleeps for. If set properly, the second call to sleep may
return before the first call to sleep.
 
===========================================================================