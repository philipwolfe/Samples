//===================================================================
// Mailer.cpp : Defines the entry point for the DLL application.
//===================================================================
//
// This file shows a simple example of a Request Handler, and 
// demonstrates some of the basic features of the mail classes:
// CMimeMessage and CSMTPConnection.
// See atlsmtpconnection.h and atlmime.h for documentation and
// more advanced features including full MIME multilanguage 
// support.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Classes Reference and related electronic
// documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft C++ Libraries products.


#include "stdafx.h"
#include <atlsmtpconnection.h>

class CMailerModule : public CAtlDllModuleT<CMailerModule>
{
};

CMailerModule _Module;

// CDebugReportHook is used in conjunction with WebDbg.exe for
// custom assert and trace handling.
#ifdef _DEBUG
CDebugReportHook g_ReportHook;
#endif


BOOL APIENTRY DllMain( HINSTANCE /*hInstance*/, DWORD  dwReason, LPVOID lpReserved)
{
    return _Module.DllMain(dwReason, lpReserved); 
}


class CSimpleMailer: public CRequestHandlerT<CSimpleMailer>
{
public:
	HTTP_CODE ValidateAndExchange()
	{
		ATLTRACE("CSimpleMailer::ValidateAndExchange");

		_ATLTRY
		{
			// Set the content type to be text/plain (default is text/html)
			m_HttpResponse.SetContentType("text/plain");
			CValidateContext c;

			// Validate the required parameters
			m_HttpRequest.FormVars.Validate("server_name", (LPCSTR*)NULL, 1, 256, &c);
			m_HttpRequest.FormVars.Validate("from", (LPCSTR*)NULL, 1, 256, &c);
			m_HttpRequest.FormVars.Validate("to", (LPCSTR*)NULL, 1, 256, &c);

			// If one of the parameters is not valid, output an error message and return
			if (!c.ParamsOK())
			{
				int nFailed = c.GetResultCount();
				CStringA strParamName;
				DWORD type;
				m_HttpResponse.Write("Failed Params\r\n");
				for (int i=0;i<nFailed;i++)
				{
					c.GetResultAt(i, strParamName, type);
					switch(type)
					{
						case VALIDATION_E_PARAMNOTFOUND:
							m_HttpResponse.Write(strParamName);
							m_HttpResponse.Write(" not found\r\n");
							break;

						case VALIDATION_E_INVALIDLENGTH:
							m_HttpResponse.Write(strParamName);
							m_HttpResponse.Write(" length error\r\n");
							break;

						case VALIDATION_E_INVALIDPARAM:
							m_HttpResponse.Write(strParamName);
							m_HttpResponse.Write(" invalid parameter\r\n");
							break;
					}
				}

				// Delete any temporary files that may have been generated by the multipart form
				m_HttpRequest.DeleteFiles();

				// return HTTP_REQUEST_NO_PROCESS to keep CRequestHandlerT from doing any further processing
				return HTTP_SUCCESS_NO_PROCESS;
			}

			CMimeMessage msg;

			LPCSTR szField = NULL;

			// Set the sender of the message
			msg.SetSender(CA2CT(m_HttpRequest.FormVars.Lookup("from")));

			// Set the sender display name, if it exists
			szField = m_HttpRequest.FormVars.Lookup("sender_name");
			if (szField && *szField)
				msg.SetSenderName(CA2CT(szField));
			
			// Add the recipient(s) (with a display name if it exists)
			msg.AddRecipient(CA2CT(m_HttpRequest.FormVars.Lookup("to")), 
				CA2CT(m_HttpRequest.FormVars.Lookup("recip_name")));

			// if the CC field is not empty, add the cc line (must be properly formatted)
			szField = m_HttpRequest.FormVars.Lookup("cc_field");
			if (szField && *szField)
				msg.AddCc(CA2CT(szField));

			// Add the subject
			szField = m_HttpRequest.FormVars.Lookup("subject_field");
			if (szField && *szField)
				msg.SetSubject(CA2CT(szField));

			// Add the message text
			szField = m_HttpRequest.FormVars.Lookup("msg");
			if (szField && *szField)
				msg.AddText(CA2CT(szField));

			// Set the message priority
			msg.SetPriority(static_cast<ATL_MIME_PRIORITY>(atoi(m_HttpRequest.FormVars.Lookup("msg_pri"))));


			// Determine the encoding schemes of the possible 3 attached files
			DWORD filesEnc[3];
			filesEnc[0] = atoi(m_HttpRequest.FormVars.Lookup("file1_enc"));
			filesEnc[1] = atoi(m_HttpRequest.FormVars.Lookup("file2_enc"));
			filesEnc[2] = atoi(m_HttpRequest.FormVars.Lookup("file3_enc"));

			// If there any files, attach them
			POSITION pos = m_HttpRequest.m_Files.GetStartPosition();
			int i = 0;
			while (pos != NULL)
			{
				// Get the "actual" file name from the IHttpFile object
				IHttpFile *pFile = m_HttpRequest.m_Files.GetValueAt(pos);
				LPCSTR szDisplayFile = pFile->GetFileName();

				// if it is emtpy, no file was specified
				if (szDisplayFile && *szDisplayFile)
				{
					// Get the temporary file name (the file that is actually has the file contents)
					LPCSTR szTmpFile = pFile->GetTempFileName();

					// If the file exists, attach it
					if (szTmpFile && *szTmpFile)
					{
						// szDisplayFileName is the file name that will show up mail readers
						if (!msg.AttachFile(CA2CT(szTmpFile), CA2CT(szDisplayFile), _T("application/octet-stream"), filesEnc[i]))
						{
							m_HttpResponse << "Could Not Attach File : " << szDisplayFile << "\r\n";
							return HTTP_SUCCESS_NO_PROCESS;
						}
					}
				}
				
				i++;
				m_HttpRequest.m_Files.GetNext(pos);
			}

			CSMTPConnection connection;

			// Attempt to connect to the specified SMTP server
			if (!connection.Connect(CA2CT(m_HttpRequest.FormVars.Lookup("server_name"))))
			{
				m_HttpResponse << "Could Not Connect To Server : " << m_HttpRequest.FormVars.Lookup("server_name") << "\r\n";
				return HTTP_SUCCESS_NO_PROCESS;
			}

			// Attempt to send the message (using the sender and recipient(s) specified in the CMimeMessage object --
			// if no explicit sender and recipients are given as parameters to SendMessage, it attempts to look them
			// up in the CMimeMessage object
			if (!connection.SendMessage(msg))
			{
				m_HttpResponse << "Failed To Send Message! : \r\n";
				return HTTP_SUCCESS_NO_PROCESS;
			}

			// Output message information
			m_HttpResponse << "Your Message Was Sent\r\n\r\n";
			m_HttpResponse << "Message Information: \r\n";
			m_HttpResponse << "From    : " << msg.GetSenderName() << " " << msg.GetSender() << "\r\n";
			m_HttpResponse << "To      : " << msg.GetRecipients() << "\r\n";
			m_HttpResponse << "Cc      : " << msg.GetCc() << "\r\n";
			m_HttpResponse << "Subject : " << msg.GetSubject() << "\r\n";
			m_HttpResponse << "Message : \r\n";
			m_HttpResponse << m_HttpRequest.FormVars.Lookup("msg");

			// Delete any temporary files that may have been generated
			m_HttpRequest.DeleteFiles();
		}
		_ATLCATCHALL()
		{
			return AtlsHttpError(500, ISE_SUBERR_OUTOFMEM);
		}

		// return HTTP_SUCCESS_NO_PROCESS to keep CRequestHandlerT from doing any further processing
		return HTTP_SUCCESS_NO_PROCESS;
	}

    // override FormFlags to allow file upload
	DWORD FormFlags()
	{
		return ATL_FORM_FLAG_NONE;
	}
}; 

// Specify the handler
BEGIN_HANDLER_MAP()
	HANDLER_ENTRY("Default", CSimpleMailer)
END_HANDLER_MAP()
