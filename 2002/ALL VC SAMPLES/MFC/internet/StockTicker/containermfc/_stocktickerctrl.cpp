// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Classes Reference and related electronic
// documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft C++ Libraries products.

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "_stocktickerctrl.h"

// Dispatch interfaces referenced by this interface
#include "Font.h"

/////////////////////////////////////////////////////////////////////////////
// CStockTickerCtrl

IMPLEMENT_DYNCREATE(CStockTickerCtrl, CWnd)

void CStockTickerCtrl::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
		WriteControl(ar);
	else
		ASSERT(FALSE);  // never load this way!
}

void CStockTickerCtrl::WriteControl(CArchive& ar)
{
	LPUNKNOWN lpUnk = GetControlUnknown();

	// create a storage to use temporarily

	LPLOCKBYTES lpLockBytes;
	LPSTORAGE lpStorage;

	SCODE sc = ::CreateILockBytesOnHGlobal(NULL, TRUE, &lpLockBytes);
	if (sc != S_OK)
		AfxThrowOleException(sc);
	ASSERT(lpLockBytes != NULL);

	sc = ::StgCreateDocfileOnILockBytes(lpLockBytes,
		STGM_SHARE_EXCLUSIVE|STGM_CREATE|STGM_READWRITE, 0, &lpStorage);
	if (sc != S_OK)
	{
		VERIFY(lpLockBytes->Release() == 0);
		lpLockBytes = NULL;
		AfxThrowOleException(sc);
	}

	// use the storage

	LPPERSISTSTORAGE lpPersistStorage;

	if (!SUCCEEDED(lpUnk->QueryInterface(IID_IPersistStorage, (void**) &lpPersistStorage)))
		ASSERT(FALSE);
	sc = ::OleSave(lpPersistStorage, lpStorage, FALSE);
	lpPersistStorage->SaveCompleted(NULL);
	lpPersistStorage->Release();
	lpStorage->Commit(STGC_OVERWRITE);
	ASSERT(::StgIsStorageILockBytes(lpLockBytes) == S_OK);

	// attempt to get the handle to the global memory
	HGLOBAL hStorage;
	sc = ::GetHGlobalFromILockBytes(lpLockBytes, &hStorage);
	if (sc != S_OK)
		AfxThrowOleException(sc);

	// first write a byte count
	STATSTG statstg;
	sc = lpLockBytes->Stat(&statstg, STATFLAG_NONAME);
	if (sc != S_OK)
		AfxThrowOleException(sc);
	ASSERT(statstg.cbSize.HighPart == 0);   // don't support >4GB objects
	DWORD dwBytes = statstg.cbSize.LowPart;
	ar << dwBytes;

	// write the contents of the block
	LPVOID lpBuf = GlobalLock(hStorage);
	ASSERT(lpBuf != NULL);
	ar.Write(lpBuf, (UINT)dwBytes);
	::GlobalUnlock(hStorage);
}

/////////////////////////////////////////////////////////////////////////////
// CStockTickerCtrl properties

OLE_COLOR CStockTickerCtrl::GetBackColor()
{
	OLE_COLOR result;
	GetProperty(DISPID_BACKCOLOR, VT_I4, (void*)&result);
	return result;
}

void CStockTickerCtrl::SetBackColor(OLE_COLOR propVal)
{
	SetProperty(DISPID_BACKCOLOR, VT_I4, propVal);
}

COleFont CStockTickerCtrl::GetFont()
{
	LPDISPATCH pDispatch;
	GetProperty(DISPID_FONT, VT_DISPATCH, (void*)&pDispatch);
	return COleFont(pDispatch);
}

void CStockTickerCtrl::SetFont(LPDISPATCH propVal)
{
	SetProperty(DISPID_FONT, VT_DISPATCH, propVal);
}

OLE_COLOR CStockTickerCtrl::GetForeColor()
{
	OLE_COLOR result;
	GetProperty(DISPID_FORECOLOR, VT_I4, (void*)&result);
	return result;
}

void CStockTickerCtrl::SetForeColor(OLE_COLOR propVal)
{
	SetProperty(DISPID_FORECOLOR, VT_I4, propVal);
}

short CStockTickerCtrl::GetUpdateInterval()
{
	short result;
	GetProperty(0x1, VT_I2, (void*)&result);
	return result;
}

void CStockTickerCtrl::SetUpdateInterval(short propVal)
{
	SetProperty(0x1, VT_I2, propVal);
}

short CStockTickerCtrl::GetTickerSpeed()
{
	short result;
	GetProperty(0x2, VT_I2, (void*)&result);
	return result;
}

void CStockTickerCtrl::SetTickerSpeed(short propVal)
{
	SetProperty(0x2, VT_I2, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CStockTickerCtrl operations

void CStockTickerCtrl::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
