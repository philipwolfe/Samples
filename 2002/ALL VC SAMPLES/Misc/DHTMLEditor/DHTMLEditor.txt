The DHTMLEditor sample demonstrates how to use the new MFC DHTML editing classes.
It implements a simple HTML editor, which allows you to create and edit
HTML files.

The Application is based on the MFC SDI application generated by AppWizard, and
the new classes that implement all the functionality are CHtmlEditDoc and CHtmlEditView.
Internally it uses the Dynamic HTML Editing Component, to learn more about it
refer to the Web Workshop on Microsoft MSDN site.

Classes are defined in afxhtml.h header file, so the following line should
be added to the stdafx.h file:

	#include <afxhtml.h>		// MFC Dynamic HTML Editing Component 

To reuse the new classes functionality we have to derive our document class
from CHtmlEditDoc, but AppWizard derives your document class from CDocument.
Just replace all references to CDocument class in your document header and source
with reference to CHtmlEditDoc class.

You should do the same thing for the view derived class as well. Replace all references to
te CView class with a refernce to CHtmlEditView class in the DHTMLEditorView.h
and DHTMLEditorView.cpp files.

Your view class hosts the Dynamic HTML Editing Component (actually it is encapsulated
by CHtmlEditCtrlBase class, but CHtmlEditView is derived from CHtmlEditCtrlBase),
so to do useful work, you should call members of the CHtmlEditView class.
Check the documentation for CHtmlEditCtrlBase to get a list and description.

To perform the ExecuteCommand job, the command handler was added to the view class.
Add its prototype to the view header file (DHTMLEditorView.h

	afx_msg BOOL ExecuteCommand(UINT nID);

and implementation to the view source file (DHTMLEditorView.cpp).

As an alternative, inside this function you can map menu commands to
the Dynamic HTML Editing Component commands and use ExecCommand method
to execute them. 

HRESULT ExecCommand(
   long cmdID,			// Identifier of command to execute
   long cmdExecOpt,		// Options for executing the command
   VARIANT* pInVar = NULL,	// Pointer to input arguments
   VARIANT* pOutVar = NULL	// Pointer to command output
) const;

Refer to the description of the CHtmlEditCtrlBase::ExecCommand and
IOleCommandTarget::Exec to get full details.

//*******************************************************************
//	ExecuteCommand
//
//		Function maps menu command to the MSHTML Editor commands
//		and executes them.
//
//	RETURNS:
//		TRUE - if function succeeded.
//		FALSE - if function failed.
//*******************************************************************
BOOL CDHTMLEditorView::ExecuteCommand(UINT nID)
{
	// Map menu command to the MSHTML Editor commands.
	HRESULT hRes;

	switch(nID)
	{
		case ID_MODE_VIEW:
			hRes = SetDesignMode(FALSE);
			break;
		case ID_MODE_EDIT:
			hRes = SetDesignMode(TRUE);
			break;
		case ID_FORMAT_FONT:
			hRes = Font();
			break;
		case ID_EDIT_CUT:
			hRes = Cut();
			break;
		case ID_EDIT_COPY:
			hRes = Copy();
			break;
		case ID_EDIT_PASTE:
			hRes = Paste();
			break;
		case ID_FORMAT_INSERTIMAGE:
			hRes = Image();
			break;
		case ID_EDIT_UNDO:
			hRes = Undo();
			break;
		default:
			return FALSE;
	}

	return hRes == S_OK ? TRUE : FALSE;
}

For each menu command we should add ON_COMMAND_EX macro to the message map.

	ON_COMMAND_EX(ID_MODE_VIEW, ExecuteCommand)
	ON_COMMAND_EX(ID_MODE_EDIT, ExecuteCommand)
	ON_COMMAND_EX(ID_FORMAT_FONT, ExecuteCommand)
	ON_COMMAND_EX(ID_EDIT_CUT, ExecuteCommand)
	ON_COMMAND_EX(ID_EDIT_COPY, ExecuteCommand)
	ON_COMMAND_EX(ID_EDIT_PASTE, ExecuteCommand)
	ON_COMMAND_EX(ID_FORMAT_INSERTIMAGE, ExecuteCommand)
	ON_COMMAND_EX(ID_EDIT_UNDO, ExecuteCommand)



