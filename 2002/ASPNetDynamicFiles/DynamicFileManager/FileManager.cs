//	THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//	KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//	IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//	PARTICULAR PURPOSE.

using System;
using System.Collections;
using System.IO;
using System.Text.RegularExpressions;
using System.Web;
using System.Web.Caching;

namespace DynamicFileManager
{
	/// <summary>
	/// This class provides a data agnostic way to manage autogenerated files
	/// on an ASP.NET web site which have limits placed on who can access them.
	/// </summary>
	public class FileManager
	{
		/// <summary>
		/// static constructor for FileManager. It loads the configurable options from the
		/// web.config file
		/// </summary>
		static FileManager()
		{
			string tmp = System.Configuration.ConfigurationSettings.AppSettings["FileManager_Extension"];		
			if (tmp != null) 
			{
				fileExtension = tmp;
			}

			tmp = System.Configuration.ConfigurationSettings.AppSettings["FileManager_Path"];		
			if (tmp != null) 
			{
				storagePath = tmp;
			}

			tmp = System.Configuration.ConfigurationSettings.AppSettings["FileManager_Mime"];		
			if (tmp != null) 
			{
				mimeType = tmp;
			}

			tmp = System.Configuration.ConfigurationSettings.AppSettings["FileManager_Timeout"];
			if (tmp != null)
			{
				try 
				{
					fileLifetime = TimeSpan.FromMinutes(Convert.ToInt32(tmp));
				}
				catch(Exception ex)
				{
					throw new System.Configuration.ConfigurationException("FileManager_Timeout error", ex);
				}
			}

			// if the app was restarted we need to add expiration for existing files
            string absolutePath = HttpContext.Current.Server.MapPath(storagePath);
            string[] files = Directory.GetFiles(absolutePath);
			foreach(string file in files)
			{
				HttpContext.Current.Cache.Add(file, GetFileIDFromFilePath(file), null, DateTime.MaxValue, fileLifetime, CacheItemPriority.Normal, new CacheItemRemovedCallback(OnFileExpired));
			}
		}

		/// <summary>
		/// The file system extension given to all files stored by the file manager
		/// </summary>
		static private string fileExtension = "dfm";
		
		/// <summary>
		/// The file system extension given to all files stored by the file manager
		/// </summary>
		static public string FileExtension
		{
			get { return fileExtension; }
			set { fileExtension = value; }
		}

		/// <summary>
		/// The path under the virtual root where the files will be stored. This 
		/// path must have read/write access granted to the ASP.NET worker process
		/// </summary>
		static private string storagePath = "dynamicFiles";

		/// <summary>
		/// The default mime type of the files that are stored.
		/// </summary>
		static private string mimeType = null;
		
		/// <summary>
		/// The default mime type of the files that are stored.
		/// </summary>
		static public string MimeType
		{
			get 
			{
				return mimeType;
			}
		}

		/// <summary>
		/// The path under the virtual root where the files will be stored. This 
		/// path must have read/write access granted to the ASP.NET worker process
		/// </summary>
		public string StoragePath
		{
			get { return storagePath; }
			set { storagePath = value; }
		}

		/// <summary>
		/// the amount of time before files are removed from the system
		/// </summary>
		static private TimeSpan fileLifetime = TimeSpan.FromHours(24);

		/// <summary>
		/// Gets the physical file system path of the file referenced by the file ID
		/// </summary>
		/// <param name="fileID">the file ID</param>
		/// <returns>the physical file system path</returns>
		protected string GetLocalFilePath(string fileID)
		{
			string localPath = storagePath + "\\" + GenerateFileName(fileID);
            string absolutePath = HttpContext.Current.Server.MapPath(localPath);
            return absolutePath;
		}

		/// <summary>
		/// Retrieves a stream to load the data in a file with a user defined unique key.
		/// The client is responsible for closing the stream when done.
		/// </summary>
		/// <param name="fileID">the unique identifier of the file</param>
		/// <returns>the stream which can load the requested data</returns>
		public Stream GetLoadStream(string fileID)
		{
			if (!IsValidFileID(fileID))
			{
				throw new ArgumentException("fileID", "invalid file name");
			}

			// get the actual filepath of the destination
			string absolutePath = GetLocalFilePath(fileID);

			// open the existing file
			FileStream fs = null;
			try 
			{
				fs = new FileStream(absolutePath, FileMode.Open, FileAccess.Read, FileShare.Read);

				// update the cache entry to keep the file alive
				HttpContext.Current.Cache.Add(absolutePath, fileID, null, DateTime.MaxValue, fileLifetime, CacheItemPriority.Normal, new CacheItemRemovedCallback(OnFileExpired));
			}
			catch(IOException ex)
			{
				HttpContext.Current.Trace.Write("DynamicFileManager", ex.Message);
				throw ex;
			}
			return fs;
		}

		/// <summary>
		/// Retrieves a stream to store the data in a file with a user defined unique key.
		/// The client is responsible for closing the stream when done.
		/// </summary>
		/// <param name="?">the stream to store</param>
		/// <returns>the identifier of the stored file</returns>
		public Stream GetStorageStream(out string fileID)
		{
			return GetStorageStream(Guid.NewGuid().ToString(), out fileID);
		}

		/// <summary>
		/// deletes the file when it expires based on a Cache entry
		/// </summary>
		/// <param name="key">the cache key (physical file path)</param>
		/// <param name="val">the cache value (file ID)</param>
		/// <param name="reason">the reason it is expired from the cache</param>
		static public void OnFileExpired(string key, object val, CacheItemRemovedReason reason)
		{
			File.Delete((string)key);
		}

		/// <summary>
		/// Retrieves a stream to store the data in a file with a user defined unique key.
		/// The client is responsible for closeing the stream when done.
		/// </summary>
		/// <param name="stream">the stream to store</param>
		/// <param name="key">a value used to generate the fileID</param>
		/// <returns>The identifier of the stored file</returns>
		public Stream GetStorageStream(string key, out string fileID)
		{

			// get the actual filepath of the destination
			string tmpID = GenerateFileID(key);
			string absolutePath = GetLocalFilePath(tmpID);

			// open the new file
			FileStream fs = null;
			try 
			{
				fs = new FileStream(absolutePath, FileMode.Create);
			}
			catch(IOException ex)
			{
				HttpContext.Current.Trace.Write("DynamicFileManager", ex.Message);
				throw ex;
			}
			fileID = tmpID;

			// start timer for file cleanup
			HttpContext.Current.Cache.Add(absolutePath, fileID, null, DateTime.MaxValue, fileLifetime, CacheItemPriority.Normal, new CacheItemRemovedCallback(OnFileExpired));

			return fs;
		}

		/// <summary>
		/// Generates a filename with extension for a given file ID
		/// </summary>
		/// <param name="fileID">the file ID</param>
		/// <returns>a valid NTFS filename</returns>
		public string GenerateFileName(string fileID)
		{
			return fileID + "." + fileExtension;
		}

		/// <summary>
		/// determines the File ID from a given physical system file path
		/// </summary>
		/// <param name="path">the physical system path to the file</param>
		/// <returns>the file ID</returns>
		protected static string GetFileIDFromFilePath(string path)
		{
			char[] slashes = new char[] {'/','\\'};
			int idx = path.LastIndexOfAny(slashes);
			string file = path.Substring(idx+1, path.Length - (idx + 
					
				1) - (FileExtension.Length + 1));
			return file;
		}

		/// <summary>
		/// generate a file ID which can be used to retrieve the file at a
		/// later data. 
		/// 
		/// If this method is overridden then IsValidFileID should
		/// also be overriden to ensure that their functionality stays in sync
		/// 
		/// The base implementation file ID is based on the current Http session 
		/// </summary>
		/// <param name="key">user defined key</param>
		/// <returns>a file ID</returns>
		protected virtual string GenerateFileID(string key)
		{
			return HttpContext.Current.Session.SessionID + "_" + key;
		}

		/// <summary>
		/// checks if the file ID is valid in the current context. This base implementation
		/// ensures that file ID was generated by the current Http session.
		/// 
		/// If this method is overridden then GenerateFileID should
		/// also be overriden to ensure that their functionality stays in sync
		/// </summary>
		/// <param name="file ID">the file ID to validate</param>
		/// <returns>true if the file ID is valid</returns>
		public virtual bool IsValidFileID(string fileID)
		{
			// file must start with the storage path and the current session ID. 
			string fileStarter = HttpContext.Current.Session.SessionID;
			if (fileID.Length < fileStarter.Length)
			{
				return false;
			}
			return fileID.Substring(0, fileStarter.Length) == fileStarter;
		}

		/// <summary>
		/// retrieves all the valid file IDs for the current context
		/// </summary>
		/// <returns>an array of file IDs</returns>
		public string[] GetAllFileIDs()
		{
            string fileDir = HttpContext.Current.Server.MapPath(storagePath);
            string[] files = Directory.GetFiles(fileDir);

			ArrayList fileIDs = new ArrayList(files.Length);
			foreach(string file in files)
			{
				string ID = GetFileIDFromFilePath(file);
				if (IsValidFileID(ID))
				{
					fileIDs.Add(ID);
				}
			}		

			return (string[])fileIDs.ToArray(typeof(string));
		}

		/// <summary>
		/// deletes a file
		/// </summary>
		/// <param name="fileID">the file ID of the file to be deleted</param>
		public void RemoveFile(string fileID)
		{
			if(!IsValidFileID(fileID)) 
			{
				return;
			}

			string path = GetLocalFilePath(fileID);
			File.Delete(path);
		}

		/// <summary>
		/// deletes all the files for the current context
		/// </summary>
		public void RemoveAllFiles()
		{
			string[] IDs = GetAllFileIDs();
			foreach(string ID in IDs)
			{
				RemoveFile(ID);
			}
		}
	}
}
