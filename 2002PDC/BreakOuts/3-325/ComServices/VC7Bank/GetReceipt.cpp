// ==============================================================================
// Filename: GetReceipt.h
//
// Summary:  managed cpp definition of the GetReceipt class for the bank sample
// Classes:  GetReceipt.cs
//
// This file is part of the Microsoft COM+ Samples
//
// Copyright (C) 1995-1999 Microsoft Corporation. All rights reserved
//
// This source code is intended only as a supplement to Microsoft
// Development Tools and/or on-line documentation.  See these other
// materials for detailed information reagrding Microsoft code samples.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//


// import mscorlib definitions
#using "mscorlib.dll"
using namespace System;
using namespace System::Runtime::InteropServices;

// import definitions for ComServices support
#using "Microsoft.ComServices.dll"
using namespace Microsoft::ComServices;

//import definitions for ADO
#using "adodb.dll"
using namespace ADODB;

// import definition for account typelibrary
#using "account.dll"
using namespace ACCOUNTCom;

#define null 0

#include "getreceipt.h"
#include "updatereceipt.h"

namespace VC7Bank
{
    int GetReceiptOrig::GetNextReceipt ()
    {

        bool bSuccess = false;
        int result;

        // First of all, get the object context
        try
        {
            // Call the true function
            result = trueGetNextReceipt ();
            bSuccess = true;
            return result;
        }

        // Upon exit, always call SetComplete if happy, or SetAbort if unhappy.
        // We do this because we never save state across method calls.
        __finally
        {
            if (bSuccess)
                ContextUtil::SetComplete();
            else
                ContextUtil::SetAbort();
        }
    }


    // F+F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++F+++
    //
    // Function: trueGetNextReceipt
    //
    // trueGetNextReceipt() is the function that performs the actual work for the Account class.
    // If an error occurs during execution, it will throw a COMException for GetNextReceipt()
    // to handle.

    // For exposition purposes, two versions of this function are given. You can uncomment either one
    // of these routines.

    // The first version of trueGetNextReceipt uses the COM+ Shared Property Manager to hold the
    // shared state. The Shared Property Manager allows one to share state across all instances of
    // components that are in the same package, regardless of what language and tools were used to
    // implement each component. It is also hard to create race conditions with the Shared Property Manager.
    // This example also shows that the interface the the Shared Property Manager.

    // The second version of trueGetNextReceipt uses static variables to hold the shared state,
    // and a static synchronized method to access and update. Correctly writing code like this also
    // requires a full understanding of static members and methods, of synchronized methods, and of
    // how the two interact. It's relatively easy to get code like this wrong, but this example is
    // simple enough that the code is attractive in this case.
    //
    // Args:     None
    // Returns:  Long -  next receipt value
    //
    // F-F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---F---


    // trueGetNextReceipt using COM+ Shared Properties:
    int GetReceiptOrig::trueGetNextReceipt ()
    {
        SharedPropertyGroupManager* spmMgr = null;
        SharedPropertyGroup* spmGroup = null;
        SharedProperty* spmPropNextReceipt = null;
        SharedProperty* spmPropMaxNum = null;
        IUpdateReceipt* objReceiptUpdate = null;

        try
        {
            // Create SPM group manager
            //spmMgr = (ISharedPropertyGroupManager) Context.getObjectContext().CreateInstance
            //  (SharedPropertyGroupManager.clsid, ISharedPropertyGroupManager.iid);
            spmMgr = new SharedPropertyGroupManager();

            // Prepare primnitive types that can be passed in by reference, as per the
            // function declarations generated by the Type Library Wizard for the
            // "Shared Property Manager Type Library."
            bool bExists = false;
            PropertyLockMode iLockMode;  //= new int [1];
            PropertyReleaseMode iReleaseMode;//  = new int [1];

            //iLockMode [0] = ISharedPropertyGroupManager.LOCKMODE_METHOD;
            iLockMode  = PropertyLockMode::Method;
            //iReleaseMode [0] = ISharedPropertyGroupManager.RELEASEMODE_PROCESS;
            iReleaseMode  = PropertyReleaseMode::Process;

            // Create the shared property group
            spmGroup = spmMgr->CreatePropertyGroup (S"Receipt", &iLockMode, &iReleaseMode, &bExists);

            // Create the properties
            spmPropNextReceipt = spmGroup->CreateProperty(S"Next", &bExists);
            spmPropMaxNum = spmGroup->CreateProperty(S"MaxNum", &bExists);

            // Call GetNextReceipt() if necessary
            int iPropNextReceipt = reinterpret_cast<int>(dynamic_cast<Int32*>(spmPropNextReceipt->Value));
            int iPropMaxNum = reinterpret_cast<int>(dynamic_cast<Int32*>(spmPropMaxNum->Value)); 
            if( iPropNextReceipt >= iPropMaxNum)
            {

				objReceiptUpdate = dynamic_cast<IUpdateReceipt __gc *>(new UpdateReceipt());
                int iRet = objReceiptUpdate->Update ();
                spmPropNextReceipt->Value = __box(iRet);
                spmPropMaxNum->Value = __box(iRet + 100);
            }

            int vfoo = reinterpret_cast<int>(dynamic_cast<Int32*>(spmPropNextReceipt->Value)) + 1;
            spmPropNextReceipt->Value = __box(vfoo);

            // We are finished and happy
            return reinterpret_cast<int>(dynamic_cast<Int32*>(spmPropNextReceipt->Value));
        }

        __finally
        {
            // The following code is not strictly necessary. By calling ComLib.release here,
            // the object counts seen in the MTX explorer remain correct. Without these release
            // calls, the objects used here would not get released until after the next time
            // the garbage collector runs. No other ill effect would be caused by omitting
            // this code.

            // Note that this code will be executed regardless of whether we leave this
            // method via return or via an exception.
            //if (spmMgr             != null) Marshal.ReleaseComObject (spmMgr);
            //if (spmGroup           != null) Marshal.ReleaseComObject (spmGroup);
            //if (spmPropNextReceipt != null) Marshal.ReleaseComObject(spmPropNextReceipt);
            //if (spmPropMaxNum      != null) Marshal.ReleaseComObject (spmPropMaxNum);
            //if (objReceiptUpdate   != null) Marshal.ReleaseComObject (objReceiptUpdate);
        }
    }
}