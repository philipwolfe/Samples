#region Using directives

using System;
using System.Collections.Generic;
using System.Text;
using System.Data.SqlClient;
using System.Reflection;
using System.IO;
using System.Windows.Forms;
#endregion

namespace AttachDBFileName.PerfTestDataSetTableAdapters
{
		/// <summary>
		/// This partial clas extends the functionality
		/// that exists when the TestDataTableAdapter class is generated
		/// You use a partial class to indicated that it is part of the main class.
		/// </summary>
		public partial class TestDataTableAdapter
		{
        
            /// <summary>
            ///This method executes a stored procedure with three parameters.
            /// It creates and opens a the SqlCommand connection by using the autogenerated
            /// connection string from the TestDataTableAdapter.  The command object then
            /// executes a non-query.
            /// </summary>
            /// <param name="QueryString"></param>
            /// <param name="Parameter1"></param>
            /// <param name="Parameter2"></param>
            /// <param name="Parameter3"></param>
            /// <returns></returns>
            /// <remarks></remarks>
        public int StoredProcedureQueryInsert(string QueryString,string Parameter1,string Parameter2 , string Parameter3)
        {

            SqlCommand command = new SqlCommand();
            int returnValue;
				
            try
            {
                command.CommandText = QueryString;			
                command.Connection = this.Connection;
                command.Connection.Open();

                command.Parameters.AddWithValue("@firstValue", Parameter1);
			    command.Parameters.AddWithValue("@secondValue", Parameter2);
                command.Parameters.AddWithValue("@timeStamp", Parameter3);
                command.CommandType = System.Data.CommandType.StoredProcedure;
                returnValue = command.ExecuteNonQuery();               
                
            
            }
            finally

            {  
                command.Connection.Close();
            }
 

            return returnValue;

}

			/// <summary>
			/// This method executes a query that is sent in as a parameter.
			/// It creates and opens a the SqlCommand connection by using the autogenerated
			/// connection string from the TestDataTableAdapter.  The command object then
			/// executes a non-query.
			/// </summary>
			/// <param name="QueryString"></param>
			/// <returns></returns>
			public int QueryInsert(string QueryString)
			{
				
				SqlCommand command = new SqlCommand();
				command.CommandText = QueryString;
				int returnValue;
				try
				{
                    command.Connection = this.Connection;
					command.Connection.Open();
                    returnValue = command.ExecuteNonQuery();
				}
				finally
				{
					command.Connection.Close();
				}
				return returnValue;
			}
			/// <summary>
			/// This method attaches retrieves the path to the second 
			/// database and sets the new connection string.  This method also
			/// sets all the database properties.
			/// </summary>
			public void AttachDB2()
			{
				// If the connection does not already exist, you want to use
				// auto-generated connection method InitConnection
				if (this.m_connection == null)
				{
					this.m_connection = new SqlConnection();
					this.InitConnection();
				}
				else
					this.m_connection.Close();

				string execPath = Path.GetDirectoryName(
					Assembly.GetExecutingAssembly().GetModules()[0].FullyQualifiedName);

				SqlConnectionStringBuilder newString = new SqlConnectionStringBuilder();
				newString.IntegratedSecurity = true;
				newString.DataSource = this.m_connection.DataSource;
				newString.AttachDBFilename = execPath + "\\Database2\\PerfTest.mdf";
				this.m_connection.ConnectionString = newString.ConnectionString;
			}
			/// <summary>
			/// This method sets the connection string to access the first database.
			/// The path to the specific database is created and then the connection
			/// string is set.  The connection object's properties are also set here.
			/// </summary>
			public void AttachDB1()
			{
				if (this.m_connection == null)
				{
					this.m_connection = new SqlConnection();
					this.InitConnection();
				}
				else
					this.m_connection.Close();

				string execPath = Path.GetDirectoryName(
					Assembly.GetExecutingAssembly().GetModules()[0].FullyQualifiedName);
                SqlConnectionStringBuilder newString = new SqlConnectionStringBuilder();
				newString.IntegratedSecurity = true;
				newString.DataSource = this.m_connection.DataSource;
				newString.AttachDBFilename = execPath + "\\Database1\\PerfTest.mdf";
                this.m_connection.ConnectionString = newString.ConnectionString;

			}
			/// <summary>
			/// This method returns the name of database that is currently connected.
			/// It accesses the name from the connection string of the current connection 
			/// object.
			/// </summary>
			/// <returns></returns>
			public string GetAttachedDBFilename()
			{
				if (this.m_connection == null)
				{
					this.m_connection = new SqlConnection();
					this.InitConnection();
				}

				SqlConnectionStringBuilder newString = new SqlConnectionStringBuilder();
				newString.ConnectionString = this.m_connection.ConnectionString;
				if (newString.AttachDBFilename != null)
				{
					return TrimPath(newString.AttachDBFilename);
				}
				else
					return String.Empty;
			}

			/// <summary>
			/// This method reduces the size of the full path of 
			/// where the database is located.  It only shows a subset of the full
			/// path so that it can be displayed.  This is a helper method for the 
			/// GetAttachedDBFilename method.
			/// </summary>
			/// <param name="fullPath"></param>
			/// <returns></returns>
 			private string TrimPath(string fullPath)
			{
				if (fullPath.IndexOf(@"\") == 0)
					return String.Empty;

				int start = fullPath.Length - 1;
				int end = (start / 2 - 1);
				string result = String.Empty;
				int count = 1;
				while ((start > -1) && (count < 5))
				{
					int pos = fullPath.LastIndexOf(@"\", start, end);
					result = "..\\" + fullPath.Substring(pos);
					start = pos - 1;
					count++;
				}
				return result;
			}

		}
	}

