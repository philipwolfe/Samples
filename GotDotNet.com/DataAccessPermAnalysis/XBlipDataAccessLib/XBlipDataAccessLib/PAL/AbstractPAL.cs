using System;
using System.Xml;
using System.Xml.XPath;
using System.IO;
using System.Text;
using System.Collections;
using XBLIP.XmlUtil;

namespace XBLIP.PAL
{
	/// <summary>
	/// censor policy enumerator. Used when a response is to be censored.
	/// The enumerator has 3 values:
	/// <lu>
	///		<li>CPRemove - remove the censored field</li>
	///		<li>CPClearMark - clear the censored field contents and mark it as censored</li>
	///		<li>CPMark - mark the censored field (no emptying)</li>
	/// </lu>
	/// </summary>
	public enum CensorPolicy 
	{
		CPRemove,
		CPClearMark,
		CPMark
	}

	/// <summary>
	/// Main class of <c>XBLIP.PAL</c> namespace. The class helps handling permissions
	/// on requests, using predefined tests. a Test is an object that perform a permission
	/// text using certain parameters. PAL allows for a definition of a series of tests to perform
	/// before performing and action, after performing a retrieve action (for censoring
	/// purposes) and for a query on the permissions of a certain user. The definition
	/// of tests is per application, which is why this class is abstract.
	/// <newPara>
	/// The class has 4 main methods:
	/// <lu>
	///		<li><c>getRequestLimitation</c> - used before performing an action via a Standard
	///		request. The method perform tests and may response in one of 3 ways: issue an "ABORT"
	///		string, which means that the action should not be performed because the user is
	///		prohibited from the action. It may choose to issue a new request in which the profile
	///		of the original request is further limited to include only permitted items on which
	///		the user is allowed to perform. Last it may respond with the original request, which
	///		means that no limitations were applied to the request - all tests returned without limitation
	///		</li>
	///		<li><c>censor</c> - used after a data retrieve request has been made and a standard response
	///		was returend, to censor it before returning to the user. The censorship policy is set
	///		by the <c>CensorPolicy</c> enumerator</li>
	///		<li><c>retrievePermissions</c> - used for querying the abilities of the user as to
	///		the permissions on a list of actions for specific or for all items
	///		</li>
	///		<li><c>getTestProvider</c> - an abstract method that should be implemented to
	///		get a test provider from a given label. The label is determined in each of the
	///		above method via the transformer that is provided.
	///		</li>
	/// </lu>
	/// </newPara>
	/// <newPara>
	/// An transformer is provided with each method to create an XML description of the tests that
	/// should be made according to the XML input (request/response). The transformer does not
	/// transofrm directly on the action but on an XML that includes the original XML input
	/// in a wrapping that defines also a logical id and action - to allow a combined method
	/// of writing permission tests for several ids or actions
	/// </newPara>
	/// <newPara>
	///	The following example shows how to use the class:
	///	<pre>
	///	AbstractPAL myPAL = new MyApplicationDAIL(); 
	///		// notice that the instancieated class is not of the library, but
	///		// of the application. This class should implement <c>getTestProvider</c>
	///	string strXSLFilePath = "c:\\myApplicationXSL\\Employees\\EmployeeRetrieveLimitationTests.xsl";
	///	string strQuery =
	///		"&lt;Request id=\"Employee\" action=\"Retrieve\"&gt;
	///			&lt;Data&gt;
	///				&lt;Name/&gt;
	///				&lt;Address/&gt;
	///			&lt;/Data&gt;
	///			&lt;Profile&gt;
	///				&lt;Department&gt;
	///					&lt;Item&gt; A &lt;/Item&gt;
	///				&lt;/Department&gt;
	///			&lt;/Profile&gt;
	///		&lt;/Request&gt;";
	///			
	///	ITransformer transformer = new XSLTransformer(strXSLFilePath);
	///	string strLimitedQuery = 
	///		myPAL.getRequestLimitation(strQuery,transformer,"Employee","Retrieve");
	///	
	///	/* later use DAIL to retrieve the limited request */
	///	</pre>
	/// </newPara>
	/// </summary>
	public abstract class AbstractPAL
	{

		/// <summary>
		/// constant string symbols a failure to pass the permission tests.
		/// returned by tests or <c>getRequestLimitation</c> when the action
		/// should not be performed
		/// </summary>
		public const string ABORT_STRING = "ABORT";

		/// <summary>
		/// Recent limiting profile that has been generated by
		/// <c>getLimitedRequest</c>. The user may get it through <c>recentLimitingProfile</c>
		/// </summary>
		private string strLimitingProfile;

		/// <summary>
		/// return a <c>IPALTestProvider</c> class that matches the input label.
		/// If no test provider exists that matches the label, subclasses should throw
		/// the <c>XBLIP.PAL.UnknownTestProviderException</c> exception
		/// </summary>
		/// <param name="strTPLabel">test provider label</param>
		/// <returns>a test provider</returns>
		protected abstract IPALTestProvider getTestProvider(string strTPLabel);

		/// <summary>
		/// read only property for the recent limiting profile generated by
		/// the last call to <c>getRequestLimitation</c>. This profile may
		/// be used later to find out which items are not allowed for that action
		/// (combined with the original request profile)
		/// </summary>
		public string recentLimitingProfile 
		{
			get 
			{
				return strLimitingProfile;
			}
		}
		
		/// <summary>
		/// test a request for its permission validity. The return value may be
		/// one of 3:
		/// <lu>
		///		<li>unchanged request - if the user passed all the tests without any 
		///		limitation defined by it</li>
		///		<li>limited request - if at least one of the tests defined a limiting profile
		///		the profile(s) will be inserted into the given request, and the new limited request
		///		will be returned</li>
		///		<li>"ABORT" - if one of the mandatory tests failed completly and returned "ABORT"
		///		then the request should not be executed. In this case an "ABORT" string is returned
		///		</li>
		/// </lu>
		/// after performing this action <c>recentLimitingProfile</c> may be used for
		/// returning the limiting profile (alone, without the original profile of the request)
		/// in order to get the permission limitation.
		/// The transformer points to an object building a tests series out of the request
		/// </summary>
		/// <param name="strRequest">request to test</param>
		/// <param name="transformer">request transformer</param>
		/// <param name="strID">logical permission id</param>
		/// <param name="strAction">logical permission action</param>
		/// <returns>a standard request</returns>
		public string getRequestLimitation(
			string strRequest, 
			ITransformer transformer,
			string strID,
			string strAction) 
		{
			XmlReaderEntityNavigator testsIterator;			
			string strLimitation;
			string strResult;

			testsIterator = generateTestsIterator(strRequest,transformer,strID,strAction);
			strLimitation = getTestsLimitation(testsIterator);

			if(ABORT_STRING == strLimitation)
				strResult = ABORT_STRING;
			else
			{
				strLimitingProfile = strLimitation;
				strResult = appendLimitingProfile(strRequest,strLimitation);
			}

			return strResult;
		}

		/// <summary>
		/// generate a tests iterator out of the request and transformer
		/// </summary>
		/// <param name="strRequest">standard request</param>
		/// <param name="transformer">transforms a wrapped request to tests</param>
		/// <param name="strID">logical permission id</param>
		/// <param name="strAction">logical permission action</param>
		/// <returns>a navigator holding tests</returns>
		private XmlReaderEntityNavigator generateTestsIterator(
			string strRequest,
			ITransformer transformer,
			string strID,
			string strAction) 
		{
			return generatePermissionDataIterator(strRequest,transformer,strID,strAction,"Tests");
		}

		/// <summary>
		/// wrap the request in an XML and transform it. Later create a navigator
		/// on the result XML
		/// </summary>
		/// <param name="strPermissionSource">standard request which is the source of all tests (!!!)</param>
		/// <param name="transformer">transformer object for the tests generator</param>
		/// <param name="strID">logical permission id</param>
		/// <param name="strAction">logical permission action</param>
		/// <param name="strIteratorBound">navigator bound</param>
		/// <returns>navigator on the resulting XML</returns>
		private XmlReaderEntityNavigator generatePermissionDataIterator(
			string strPermissionSource,
			ITransformer transformer,
			string strID,
			string strAction,
			string strIteratorBound) 			 
		{
			
			string strGenerationData =
				"<PermissionRequest id=\"" + strID + "\" action=\"" + strAction + "\">" +
				strPermissionSource +
				"</PermissionRequest>";
			string strTestsXml = transformer.transform(strGenerationData);
			StringReader stringReader = new StringReader(strTestsXml);
			XmlTextReader xmlReader = new XmlTextReader(stringReader);
			XmlReaderEntityNavigator testsIterator = new XmlReaderEntityNavigator(xmlReader,strIteratorBound);
			
			return  testsIterator;
		}

		/// <summary>
		/// get the limitation defined by the navigated tests by iterating
		/// and executing each.
		/// </summary>
		/// <param name="testsIterator">tests navigator to iterate on</param>
		/// <returns>the accumulated tests result (limiting profile/ABORT/"")</returns>
		private string getTestsLimitation(XmlReaderEntityNavigator testsIterator) 
		{
			StringBuilder strCollectedProfile = new StringBuilder();
			string strTestResult = "";
			bool bAbortNotFound = true;

			if(testsIterator.moveToEntitiesBegin()) 
			{
				while(!testsIterator.isEntitiesEnd() && bAbortNotFound)	
				{
					strTestResult = 
						getTestResult(testsIterator);

					if(ABORT_STRING == strTestResult)
						bAbortNotFound = false;
					else
						strCollectedProfile.Append(strTestResult);
				} 
			}

			if(bAbortNotFound)
				return strCollectedProfile.ToString();
			else
				return ABORT_STRING;
		}

		/// <summary>
		/// get a single test/group of tests result
		/// </summary>
		/// <param name="testNavigator">navigator that points to the test to execute</param>
		/// <returns>the test result</returns>
		private string getTestResult(XmlReaderEntityNavigator testNavigator) 
		{
			string strTestResult;

			if("Test" == testNavigator.getEntityName())
				strTestResult = getSingleTestResult(testNavigator);	
			else
				strTestResult = getTestGroupResult(testNavigator);

			return strTestResult;
		}

		/// <summary>
		/// execute a single non-group tests (with a "Test" tag name)
		/// </summary>
		/// <param name="testNavigator">navigator pointing to the test</param>
		/// <returns>the test result</returns>
		private string getSingleTestResult(XmlReaderEntityNavigator testNavigator) 
		{
			string strTestID;

			strTestID = testNavigator.getEntityAttribute("id");
			return executeTest(
				strTestID,
				testNavigator.getEntityContent());
		}

		/// <summary>
		/// get a group of tests result. A group of tests may be an "AND" group
		/// or an "OR" group. An "AND" group returns the accumulated result of all
		/// internal tests/groups. An "OR" group returns the first result that is 
		/// not an "ABORT" string, or an "ABORT" string if all results are "ABORT"
		/// </summary>
		/// <param name="testNavigator">navigator pointing on the group</param>
		/// <returns>the group of tests result</returns>
		private string getTestGroupResult(XmlReaderEntityNavigator testNavigator) 
		{
			string strCurrentBound = testNavigator.entitiesBoundLabel;
			string strTestResult;
			string strType;
			
			testNavigator.entitiesBoundLabel = "TestGroup";
			strType = testNavigator.getEntityAttribute("type");
			if(strType == "AND")
				strTestResult = getAndGroupTestsLimitation(testNavigator);
			else
				strTestResult = getOrGroupTestsLimitation(testNavigator);
			
			testNavigator.entitiesBoundLabel = strCurrentBound;
			testNavigator.moveToNextEntity();
			return strTestResult;
		}

		/// <summary>
		/// run an "AND" group test. Actualy this is the same as running the original
		/// limitation method.... use it...
		/// </summary>
		/// <param name="testNavigator">navigator pointing to the group</param>
		/// <returns>the group of tests result</returns>
		private string getAndGroupTestsLimitation(XmlReaderEntityNavigator testNavigator) 
		{
			return getTestsLimitation(testNavigator);
		}

		/// <summary>
		/// get an "OR" group limitation. The method loops the tests/groups executing
		/// each one, and returning the first non-abort result
		/// </summary>
		/// <param name="testsOrGroupNavigator">navigator pointing to the group</param>
		/// <returns>the group of tests result</returns>
		private string getOrGroupTestsLimitation(XmlReaderEntityNavigator testsOrGroupNavigator) 
		{
			string strGroupResult = "";
			bool bNonAbortNotFound = true;
			
			if(testsOrGroupNavigator.moveToEntitiesBegin()) 
			{
				while(!testsOrGroupNavigator.isEntitiesEnd() && bNonAbortNotFound)
				{
					strGroupResult = getTestResult(testsOrGroupNavigator);
					bNonAbortNotFound = (strGroupResult == ABORT_STRING);
				} 
			}
			return strGroupResult;

		}

		/// <summary>
		/// execute a test (a single non-group test). Get the test provider
		/// for the given test id, and send it its params string. If a test
		/// throws and exception it will be encapsulated in a thrown
		/// <c>XBLIP.PAL.TestProviderActionFailedException</c> exception
		/// </summary>
		/// <param name="strTestID">test id</param>
		/// <param name="strTestParams">test parameters</param>
		/// <returns>the test result</returns>
		private string executeTest(string strTestID,string strTestParams) 
		{
			string strTestResult;
			IPALTestProvider testProvider = getTestProvider(strTestID);

			try 
			{
				strTestResult = testProvider.getLimitiation(strTestParams);
			} 
			catch (Exception e) 
			{
				throw new TestProviderActionFailedException(
					"Error when executing test",
					e,strTestID,strTestParams);
			}
			
			
			return strTestResult;
		}

		/// <summary>
		/// create a new request out of an original request and a limiting profile.
		/// The new request will include the limiting profile inside the original profile -
		/// append, not replace
		/// </summary>
		/// <param name="strRequest">original request</param>
		/// <param name="strLimitingProfile">limitng profile</param>
		/// <returns>a combined request</returns>
		private string appendLimitingProfile(string strRequest,string strLimitingProfile) 
		{
			int nProfileEndPos;
			int nRequestEndPos;
			StringBuilder stbResult;
			string strResult;

			if(strLimitingProfile == String.Empty)
				strResult = strRequest;
			else 
			{
				stbResult = new StringBuilder();
				nProfileEndPos = strRequest.IndexOf("</Profile>");
				if(-1 == nProfileEndPos) 
				{
					nRequestEndPos = strRequest.IndexOf("</Request>");
					stbResult.Append(strRequest.Substring(0,nRequestEndPos));
					stbResult.Append("<Profile>");
					stbResult.Append(strLimitingProfile);
					stbResult.Append("</Profile>");
					stbResult.Append(strRequest.Substring(nRequestEndPos,strRequest.Length - nRequestEndPos));
				} 
				else 
				{
					stbResult.Append(strRequest.Substring(0,nProfileEndPos));
					stbResult.Append(strLimitingProfile);
					stbResult.Append(strRequest.Substring(nProfileEndPos,strRequest.Length - nProfileEndPos));
				}
				strResult = stbResult.ToString();
			}

			return strResult;
		}

		/// <summary>
		/// censor a reponse. The method accepts a reponse and a transformer that
		/// transforms a wrapped version of the response (with the logical action
		/// and id) to a series of groups. Each group holds a fields section 
		/// which includes field names and a tests section which includes tests.
		/// The tests are performed and the result determines what items in the
		/// response will have the listed fields. If the tests result in "ABORT" 
		/// the fields are censored from all items. If the tests result in a limiting
		/// profile the supplied <c>itemsRetriever</c> is used for retrieving the item
		/// IDs matching the profile. The items that are not in the resulted list are
		/// censored for the listed fields. If the tests result in an empty string nothing
		/// is censored. And this goes for each defined group
		/// </summary>
		/// <param name="strResponse">standard response to censor</param>
		/// <param name="transformer">generator of groups </param>
		/// <param name="strID">logical permission id</param>
		/// <param name="strAction">logical permission action</param>
		/// <param name="censorPolicy">censor policy to use on censored fields</param>
		/// <param name="itemsRetriever">retrieve items for a given standard retrieve
		/// request</param>
		/// <returns>a censored standard response</returns>
		public string censorResponse(
			string strResponse, 
			ITransformer transformer,
			string strID,
			string strAction,
			CensorPolicy censorPolicy,
			IItemsListRetriever itemsRetriever) 
		{
			XmlReaderEntityNavigator groupsIterator;			
			string strResult;
			CensorableResponse censorableResponse;

			groupsIterator = generateGroupsIterator(strResponse,transformer,strID,strAction);
			if(groupsIterator.moveToEntitiesBegin()) 
			{
				censorableResponse = new CensorableResponse(strResponse,censorPolicy);
				while(!groupsIterator.isEntitiesEnd())
				{
					censorSingleGroup(censorableResponse,groupsIterator,strID,itemsRetriever);	
					groupsIterator.moveToNextEntity();
				}
				
				strResult = censorableResponse.processedResponse;
			} else
				strResult = strResponse;

			return strResult;
		}

		/// <summary>
		/// generate groups of fields and tests out of the response
		/// </summary>
		/// <param name="strResponse">standard response to generate groups from</param>
		/// <param name="transformer">object that will transform the 
		/// wrapped response to a series of groups and tests</param>
		/// <param name="strID">logical permission id</param>
		/// <param name="strAction">logical permission action</param>
		/// <returns>a navigator for the generated groups XML</returns>
		private XmlReaderEntityNavigator generateGroupsIterator(		
			string strResponse,
			ITransformer transformer,
			string strID,
			string strAction) 
		{
			return generatePermissionDataIterator(strResponse,transformer,strID,strAction,"Groups");
		}
		
		/// <summary>
		/// censor a single group - perform its tests and determine
		/// for which items the groups fields should be censored
		/// </summary>
		/// <param name="censorableResponse">a censorable response class to perform the actual censoring</param>
		/// <param name="censorGroup">a group of tests and fields to censor</param>
		/// <param name="strID">logical id to use when retrieving from <c>itemsRetriever</c></param>
		/// <param name="itemsRetriever">items retriever to use when a limited profile is accepted
		/// from the tests, in order to fetch the limited items list</param>
		private void censorSingleGroup(
			CensorableResponse censorableResponse,
			XmlReaderEntityNavigator censorGroup,
			string strID,
			IItemsListRetriever itemsRetriever) 
		{
			string strLimitation;
			ArrayList fieldsArray;
			XPathNavigator itemsOKNavigator;
			string strCurrentBound = censorGroup.entitiesBoundLabel;
			censorGroup.entitiesBoundLabel = "Group";
			strLimitation = getTestsLimitation(new XmlReaderEntityNavigator(censorGroup.underlyingReader,"Tests"));
			censorGroup.moveToNextEntity();
			if(String.Empty != strLimitation) 
			{
				fieldsArray = generateFieldsArray(new XmlReaderEntityNavigator(censorGroup.underlyingReader,"Fields"));
				if(ABORT_STRING == strLimitation)
					censorableResponse.censorForAll(fieldsArray);
				else {
					itemsOKNavigator =  getLimitedItems(strLimitation,strID,itemsRetriever);
					censorableResponse.censorForItemsNotInList(itemsOKNavigator,fieldsArray);
				}
			}
			censorGroup.moveToNextEntity();
			censorGroup.entitiesBoundLabel = strCurrentBound;
		}

		/// <summary>
		/// get an array listing the fields in the current group
		/// </summary>
		/// <param name="fieldsNavigator">navigator pointing to the fields section
		/// of a group</param>
		/// <returns>an array list holding the fields</returns>
		private ArrayList generateFieldsArray(XmlReaderEntityNavigator fieldsNavigator) 
		{
			ArrayList arrResult = new ArrayList();

			if(fieldsNavigator.moveToEntitiesBegin()) 
			{
				while(!fieldsNavigator.isEntitiesEnd())
				{
					arrResult.Add(fieldsNavigator.getEntityAttribute("id"));
					fieldsNavigator.moveToNextEntity();
				} 
			}

			return arrResult;
		}

		/// <summary>
		/// using <c>itemsRetriever</c> return a standard response including
		/// a list of the items matching the given profile, of the type of the input
		/// id. The method builds a request with the "id" of the given id, and the
		/// action name of "Retrieve". The Data section of the request is empty (so
		/// no fields should be returned, only the mandatory "id" attribute) and the
		/// profile that appears is the given profile.
		/// </summary>
		/// <param name="strItemsProfile">profile of items to return</param>
		/// <param name="strItemID">items type id to use as "id" attribute of the request</param>
		/// <param name="itemsRetriever">a class that knows to accept such a request as described
		/// and return with a standard response listing the profiled items</param>
		/// <returns>an XPathNavigator holding the retrieved response</returns>
		private XPathNavigator getLimitedItems(
			string strItemsProfile,
			string strItemID,
			IItemsListRetriever itemsRetriever) 
		{
			string strItemsRequest;
			string strItems;
			StringReader stringReader;
			XPathDocument xpathDocument;

			strItemsRequest = 
				"<Request id=\"" + strItemID + "\" action=\"Retrieve\">" +
					"<Data/><Profile>" +
						strItemsProfile +
					"</Profile></Request>";
			
			strItems = itemsRetriever.retrieveItemsList(strItemsRequest);
			stringReader = new StringReader(strItems);
			xpathDocument = new XPathDocument(stringReader);

			return xpathDocument.CreateNavigator();
		}

		/// <summary>
		/// retrieve a list of items and/or an "All" item and for each
		/// the list will include the allowed actions out of the actions
		/// that the given request defines. The request may choose to define
		/// a certain profile out of which items should be queried for the permissions
		/// </summary>
		/// <param name="strRequest">a standard request in the format
		/// defined by PAL for querying permissions</param>
		/// <param name="transformer">an object that can build tests for
		/// dummy requests built by the method in order to determine the range
		/// of permitted items for a certain action</param>
		/// <param name="itemsRetriever">a class that retrieve a list of items
		/// according to a given profile</param>
		/// <returns>standard response to the request, in a format defined by PAL</returns>
		public string retrievePermissions(
			string strRequest,
			ITransformer transformer,
			IItemsListRetriever itemsRetriever) 
		{
			PermittedActionsRequestParams requestParams = new PermittedActionsRequestParams();
			PermittedActionsResponseGenerator responseGenerator = new PermittedActionsResponseGenerator();
			
			requestParams.initWithRequest(strRequest);
			insertQueriedItems(responseGenerator,requestParams,itemsRetriever);

			foreach (DictionaryEntry actionParamsEntry in requestParams.dictQueriedActions) 
				setPermittedActionForItems(
					responseGenerator,
					requestParams,
					transformer,
					(string) actionParamsEntry.Key,
					(string) actionParamsEntry.Value,
					itemsRetriever
				);

			return responseGenerator.generateResponse(requestParams.id);
		}

		/// <summary>
		/// insert all items defined by the request to the <c>responseGenerator</c>.
		/// The items entries in the generator will be later used to save the actions
		/// permitted for the items
		/// </summary>
		/// <param name="responseGenerator">a response generator</param>
		/// <param name="requestParams">a proxy class for the request</param>
		/// <param name="itemsRetriever">a class that retrieve a list of items
		/// according to a given profile</param>
		private void insertQueriedItems(
			PermittedActionsResponseGenerator responseGenerator,
			PermittedActionsRequestParams requestParams,
			IItemsListRetriever itemsRetriever) 
		{
			string strItemsRequest;
			XmlReaderEntityNavigator itemsNavigator;

			if(requestParams.isAddAllItem)
				responseGenerator.addItem("All");
			if(requestParams.isUsesProfile) 
			{
				strItemsRequest = 
					"<Request id=\"" + requestParams.id + "\" action=\"Retrieve\">" +
					"<Data/><Profile>" +
					requestParams.profileParams +
					"</Profile></Request>";
				itemsNavigator = getItemsListNavigator(strItemsRequest,itemsRetriever);
				responseGenerator.addItems(itemsNavigator);
			}
		}

		/// <summary>
		/// retrieve the items defined by the request, and insert the response
		/// to a navigator
		/// </summary>
		/// <param name="strRequest">standard request for items of a type supported by
		/// the implementation of the given <c>itemsProvider</c></param>
		/// <param name="itemsRetriever">a class that retrieve a list of items
		/// according to a given profile</param>
		/// <returns>a navigator holding a standard response listing the requested items</returns>
		private XmlReaderEntityNavigator getItemsListNavigator(string strRequest,IItemsListRetriever itemsRetriever) 
		{
			string strItems;
			StringReader stringReader;
			XmlReader xmlReader;
			XmlReaderEntityNavigator itemsNavigator;

			strItems = itemsRetriever.retrieveItemsList(strRequest);
			stringReader = new StringReader(strItems);
			xmlReader = new XmlTextReader(stringReader);
			itemsNavigator = new XmlReaderEntityNavigator(xmlReader,"Response");

			return itemsNavigator;
		}

		/// <summary>
		/// find the items to which a single action is permitted.
		/// Build a dummy request for the action, and use <c>getRequestLimitation</c>
		/// to find out the profile of the items to which this action is allowed.
		/// mark the action as allowed for the items that are profiled
		/// </summary>
		/// <param name="responseGenerator">holder of items list, to which permitted actions are added</param>
		/// <param name="requestParams">parameters of the request, used for building the request,
		///	and determining behavior of adding a permitted action</param>
		/// <param name="transformer">transformer of a dummy request to a series of tests</param>
		/// <param name="strActionID">action to check</param>
		/// <param name="strActionSpecificData">"Data" tag to be planted in the dummy request to trigger special
		/// tests that are triggered by the special "Data" tag (may be an empty "Data" tag, of course)</param>
		/// <param name="itemsRetriever">items retriever used for fetching limited items, in
		/// the case the tests require a limitation</param>
		private void setPermittedActionForItems(
			PermittedActionsResponseGenerator responseGenerator,
			PermittedActionsRequestParams requestParams,
			ITransformer transformer,
			string strActionID,
			string strActionSpecificData,
			IItemsListRetriever itemsRetriever) 
		{

			string strDummyRequest;
			string strDummyLimitedRequest;
			string strDummyProfileString;
			string strItemsProfileString;

			strDummyProfileString =
				(requestParams.isUsesProfile ? 
					(requestParams.profileParams == "" ? "":"<Profile>" + requestParams.profileParams + "</Profile>") :
					"");
			strDummyRequest = 
				"<Request id=\"" + requestParams.id + "\" action=\"" + strActionID + "\">" +
					"<Data>" + 
						strActionSpecificData + 
					"</Data>" +
					strDummyProfileString + 
				"</Request>";
			strDummyLimitedRequest = 
				getRequestLimitation(strDummyRequest,transformer,requestParams.id,strActionID);
			if(strDummyLimitedRequest != ABORT_STRING)  {
				if(strLimitingProfile == "")
					responseGenerator.AddPermittedAction(strActionID);
				else 
				{
					if(requestParams.isAddAllItem)
						responseGenerator.AddPermittedAction("All",strActionID);
					if(requestParams.isUsesProfile) 
					{
						strItemsProfileString = requestParams.profileParams + strLimitingProfile;
						addActionToProfiledItems(responseGenerator,requestParams.id,strActionID,strItemsProfileString,itemsRetriever);
					}
				}
			}
		}

		/// <summary>
		/// when a limited profile is generated out of a dummy request this method
		/// is used to add the action to the limited items. It builds a simple
		/// request to <c>itemsRetriever</c> and the returned items are permitted for
		/// the action (so that method adds that action to each item list)
		/// </summary>
		/// <param name="responseGenerator">generator of response which lists items and permitted actions</param>
		/// <param name="strItemID">item id for the items request</param>
		/// <param name="strActionID">action id to add as permitted for the retrieved items</param>
		/// <param name="strItemsProfile">profile of items to add the permitted action for</param>
		/// <param name="itemsRetriever">items retriever used for fetching limited items, in
		/// the case the tests require a limitation</param>
		private void addActionToProfiledItems(
			PermittedActionsResponseGenerator responseGenerator,
			string strItemID,
			string strActionID,
			string strItemsProfile,
			IItemsListRetriever itemsRetriever) 
		{
			string strItemsRequest = 
				"<Request id=\"" + strItemID + "\" action=\"Retrieve\">" +
				"<Data/>" +
				(strItemsProfile == "" ?  "":"<Profile>" + strItemsProfile + "</Profile>") +
				"</Request>";
			XmlReaderEntityNavigator itemsNavigator = getItemsListNavigator(strItemsRequest,itemsRetriever);
			responseGenerator.addPermittedAction(itemsNavigator,strActionID);
		}

	}
}
