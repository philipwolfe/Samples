<?xml version="1.0"?>
<doc>
    <assembly>
        <name>System.MessageBus</name>
    </assembly>
    <members>
        <member name="T:System.MessageBus.Configuration.IMessageBusConfigSectionHandler">
            <summary>
            <para>Interface derived from <see cref="!:System.Configuration.IConfigurationSectionHanlder"/> to build MessageBus config section
               handlers.</para>
            </summary>
            <remarks>
               <para>The MessageBus configuration handler 
                  MessageBusConfigHandler supports sub-handlers that implement this internface.
                  Each section of the &lt;System.MessageBus&gt; config section must have an
                  associated handler. It is also possible to nest config sections. The
                  parent config section must be able to handle the child sections to make this
                  work. <see cref="T:System.MessageBus.Configuration.MessageBusSectionHandlerBase"/>
                  is a base implementation of that makes it
                  easy to hanlde child sections.</para>
               <para>MessageBus config section Example:</para>
               <code>
            &lt;System.MessageBus&gt;
               &lt;configSections&gt;
                  &lt;section name="a" type=.../&gt;
                  &lt;section name="b" type=.../&gt;
               &lt;/configSections&gt;
               &lt;a&gt;
                 &lt;aSetting&gt;1&lt;/aSetting&gt;
                 &lt;b&gt;
                   &lt;bSetting&gt;2&lt;/bSetting&gt;
                 &lt;/b&gt;
               &lt;/a&gt;
            &lt;/System.MessageBus&gt;
               </code>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Configuration.IMessageBusConfigSectionHandler.WireUp(System.MessageBus.MessageBusConfiguration)">
            <summary>
               <para>Wire up the various components created by config.</para>
            </summary>
            <param name='messageBusComponents'>The MessageBusConfiguration contaning the items built from config that will be returned to the application.</param>
            <remarks>
               When all of the MessageBus config sections have been parsed and objects
               addedd to the MessageBusConfiguration section, Wire up is called on each
               item. This allows items that have dependencies on other items to hook
               those up. fs
            </remarks>
        </member>
        <member name="T:System.MessageBus.Configuration.MessageBusSectionHandlerBase">
            <summary>
            <para>MessageBusSectionHandlerBase - wrapper for <see cref="T:System.MessageBus.Configuration.IMessageBusConfigSectionHandler"/> . This
               impliments a base class for storing and parsing a MessageBus XMLNode Config object.</para>
            </summary>
            <threadsafe>
               <para>Single Threaded</para>
            </threadsafe>
            <remarks>
               <para>This is a base class for creating MessageBus config hanlders that have nested 
                  config handlers or need Add, Remove, and Clear functionality. It handles
                  iterating through the child XML nodes and calling the subordinate config
                  sections. It supplies a framework for implementing Add, Remove, and
                  Clear. </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Configuration.MessageBusSectionHandlerBase.Add(System.String,System.String)">
            <summary>
               Optionally adds and updates an internal collection.
            </summary>
            <remarks>
               <para>The base clase has no implementation of this method. It is called when 
                  an "add" element is parsed in the XML node during Create. </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Configuration.MessageBusSectionHandlerBase.Clear">
            <summary>
               <para>Clear the internal collection. The base implementation has no functionality.</para>
            </summary>
            <remarks>
               <para>This method is called when a "clear" element is parsed from the XML node 
                  during Create.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Configuration.MessageBusSectionHandlerBase.Create(System.Object,System.Object,System.Xml.XmlNode)">
            <summary>
               <para>Given a partially composed config object (possibly null) and some input from the
                  config system, return a further partially composed config object.</para>
            </summary>
            <param name="parent">This is the config object being composed by the parent config section. The object a derived class passes back will be incorporated somehow into this object. For top level MessageBus config sections, this is the MessageBusConfiguration collection. In this case, handlers should check to see if the object they return already exits (it might have been added in a pass through Machine.config) and modify the existing item instead of overwriting it. </param>
            <param name=" configContext">For top level MessageBus config sections this is null, but if those sections have nested sections, they may pass in the object they are building as configContext. For instance, the PoftSectionHanlder passes in the Port instance to each of the transport config section handlers it calls.</param>
            <param name=" section">The <see cref="!:System.MessageBus.Configuration.XmlNode"/> representing the section of the config document to be parsed by this handler.</param>
            <returns>
               <para>The object created as a result of this config section.</para>
            </returns>
            <remarks>
               <para>Create is called by the config system of the parent handler to initiate 
                  parsing of a config section.</para>
               During this processing, OnCreateChildObject and OnProcessChildElement are
               called for each assocated element.
               When Create is called by config, this base class will parse the
            <paramref name="section"/> XML and call Add, 
               Remove, Clear, OnProcessChildElement, and OnCreateChildObject as appropriate.
               The order in which this occures is as follows:
               <list type="number"><item>
                  <term>
                     Check for Add, Remove, and Clear - Looks for XML
                     elements named using the AddElementName, RemoveElementName, and
                     ClearElementName. These can be null to never match. If found, call the
                     appropiate method (Add, Remove, or Clear) then return.</term>
               </item>
               <item>
                  <term>
                     Check the HandlerTable to see if there is a config
                     section handler for this element. If found call the handler's Create method,
                     call OnCreateChildObject with the object returned by Create and then return.</term>
               </item>
               <item>
                  <term>
                     Call OnProcessChildElement with the XML
                     element.</term>
               </item>
            </list>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Configuration.MessageBusSectionHandlerBase.Get">
            <summary>
               Gets the object that is returned by the public Create
               method.
            </summary>
            <remarks>
               <para>Derived classes must implement this and supply the object to be returned by 
                  Create. This object is also passed into the configContext parameter of the
                  Create method of subodinate config sections.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Configuration.MessageBusSectionHandlerBase.OnCreate(System.Object,System.Object)">
            <summary>
            Handle creation of this object. 
            May create an internal representation of the collection object being implimented
            </summary>
        </member>
        <member name="M:System.MessageBus.Configuration.MessageBusSectionHandlerBase.OnCreateChildObject(System.Object)">
            <summary>
               <para>Handle the creation of a child object</para>
            </summary>
            <remarks>
               <para>This method is called during Create for each element in the section 
                  that maps to a config handler in <see cref="P:System.MessageBus.Configuration.MessageBusSectionHandlerBase.HandlerTable"/> . </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Configuration.MessageBusSectionHandlerBase.OnProcessChildElement(System.Xml.XmlNode)">
            <summary>
               <para>Process an XML Node that wasn't handled by the other config handlers.</para>
            </summary>
            <param name='element'>Xml node of the unhandled element.</param>
            <remarks>
               <para>This method is called during Create for each section 
                  element that does not have a config hander in the HandlerTable.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Configuration.MessageBusSectionHandlerBase.Remove(System.String)">
            <summary>
            Removes the specified key from the collection
            </summary>
        </member>
        <member name="M:System.MessageBus.Configuration.MessageBusSectionHandlerBase.WalkXmlNodeList(System.Object,System.Object,System.Xml.XmlNode)">
            <summary>
            Walks list of XML nodes, and processes them for by calling Add, Clear, Remove
             to cause them to update the config object we are processin
            </summary>
        </member>
        <member name="M:System.MessageBus.Configuration.MessageBusSectionHandlerBase.WireUp(System.MessageBus.MessageBusConfiguration)">
            <nodoc/>
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Configuration.MessageBusSectionHandlerBase.AddElementName">
            <summary>
               <para>Gets the name of the add element. Defaults to "add".</para>
            </summary>
            <value>
               <para>The name of the add element.</para>
            </value>
            <remarks>
               <para>This allows derived classes to override the name of the add element. Return 
                  null to disable the use of Add.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Configuration.MessageBusSectionHandlerBase.ClearElementName">
            <summary>
               <para>Gets the name of the Clear element. Defaults to "clear".</para>
            </summary>
            <value>
               <para>The name of the Clear element.</para>
            </value>
            <remarks>
               <para>This allows derived classes to override the name of the Clear 
                  element. Return null to disable the use of Clear.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Configuration.MessageBusSectionHandlerBase.KeyAttributeName">
            <summary>
               <para>Gets the name of the key attribute used by Add and Remove. Defaults to "key".</para>
            </summary>
            <value>
               <para>The name of the key attribute.</para>
            </value>
            <remarks>
               <para>This allows derived classes to override the name of the Key attribute. </para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Configuration.MessageBusSectionHandlerBase.HandlerTable">
            <summary>
               A collection of handler classes indexed by name.
            </summary>
            <value>
               <para>A collection of handler classes indexed by name.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.Configuration.MessageBusSectionHandlerBase.ParentConfiguration">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Configuration.MessageBusSectionHandlerBase.RemoveElementName">
            <summary>
               <para>Gets the name of the remove element. Defaults to "remove".</para>
            </summary>
            <value>
               <para>The name of the remove element. Defaults to "remove".</para>
            </value>
            <remarks>
               <para>This allows derived classes to override the name of the remove element. 
                  Return null to disable the use of Remove.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Configuration.MessageBusSectionHandlerBase.ValueAttributeName">
            <summary>
               <para>The name of the value attribute used by Add and Remove. Defaults to "value".</para>
            </summary>
            <value>
               <para>The name of the value attribute.</para>
            </value>
            <remarks>
               <para>Make the name of the value attribute configurable by derived classes.</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.Management.Logging.LoggingHeader">
            <summary>
            Definition of the LoggingHeader
            </summary>
        </member>
        <member name="T:System.MessageBus.MessageProperty">
            <summary>
               <para> 
                  Base class for transcient headers.</para>
            </summary>
            <remarks>
            <para><see cref="T:System.MessageBus.MessageHeader"/>s are an ideal way to annotate a <see cref="T:System.MessageBus.Message"/> with 
               system-processing information. General <see cref="T:System.MessageBus.MessageHeader"/>s are carried with the
            <see cref="T:System.MessageBus.Message"/> as moves through intermediaries to the 
               eventual endpoint. This is the ideal way to annotate a <see cref="T:System.MessageBus.Message"/> with
               system-processing information needed by other endpoints. However, it is also
               useful to be able to attach transcient state to a <see cref="T:System.MessageBus.Message"/> to be used only during
               processing by a single endpoint. Such state should not be transmitted with the
            <see cref="T:System.MessageBus.Message"/> 
            to other endpoints.</para>
            <para>A MessageProperty is a <see cref="T:System.MessageBus.MessageHeader"/> 
            that is not transmitted along with the <see cref="T:System.MessageBus.Message"/> to another endpoint. A
            MessageProperty will not go across a <see cref="T:System.MessageBus.Port"/>
            boundary.</para>
            <para>There is a default name and namespace for a 
               MessageProperty, though this may be overridden when the MessageProperty is constructed. To identify
               a particular MessageProperty, derive a class from MessageProperty, and find the
            <see cref="T:System.MessageBus.MessageHeader"/> by type using the methods on <see cref="T:System.MessageBus.MessageHeaderCollection"/> 
            .
            See example below.</para>
            </remarks>
            <example>
               <code lang="C#">
            // Message m;
            MyCustomHeader h = (MyCustomHeader)m.Headers.Find(typeof(MyCustomHeader));
               </code>
            </example>
        </member>
        <member name="T:System.MessageBus.MessageHeader">
            <summary>
            <para>Represents a header of a <see cref="T:System.MessageBus.Message"/>.</para>
            </summary>
            <threadsafe>
               <para>Single threaded.</para>
            </threadsafe>
            <remarks>
            <para>Broadly speaking, MessageHeaders are <see cref="T:System.MessageBus.Message"/> data 
               that is in the domain of system processing; a <see cref="T:System.MessageBus.Message"/> has zero or more
               MessageHeaders in a (potentially empty) <see cref="T:System.MessageBus.MessageHeaderCollection"/>.</para>
            <para>MessageHeaders are loaded into memory and may be accessed 
               randomly. Though the MessageHeader is in memory, it may be accessed any number
               of times as
               an <see cref="T:System.Xml.XmlReader"/>
               .</para>
            <para>When a Message is received, its MessageHeaders are of 
               some type derived from the abstract base MessageHeader type. Unlike <see cref="T:System.MessageBus.MessageContent"/>, the base MessageHeader class does not
               provide a <see cref="M:System.MessageBus.MessageContent.GetObject(System.Type)"/> method to cast a MessageHeader into a specific object type; instead it is expected that
               MessageHeader types will be derived from the base class.</para>
            <para>Generally, the set of MessageHeaders is bounded in size 
               by available memory. However, transport implementations will have a configurable
               limit. (Currently the <see cref="T:System.MessageBus.Transports.TextXmlFormatterFactory"/> implementation
               limits an incoming <see cref="T:System.MessageBus.Message"/>'s <see cref="T:System.MessageBus.MessageHeaderCollection"/> to &lt;= 32K Bytes.) If an
               outgoing <see cref="T:System.MessageBus.Message"/>
               exceeds the limit, an exception is raised.</para>
            <para>When an application creates a new <see cref="T:System.MessageBus.Message"/>, it 
            may create and add MessageHeaders to the <see cref="T:System.MessageBus.MessageHeaderCollection"/> . The new MessageHeaders may be from
            any type that derives from the MessageHeader base class.</para>
            <para>Because MessageHeaders may be serialized into a number of 
               different wire formats, the WriteTo method serializes the MessageHeader into a
            <see cref="T:System.IO.Stream"/> or <see cref="T:System.Xml.XmlWriter"/> 
            . If a MessageHeader is used as
            temporary state and shouldn't be serialized, then either:</para>
            <list type="bullet"><item>
               <term>
                  Derive a type from <see cref="T:System.MessageBus.MessageProperty"/>, or</term>
            </item>
            <item>
               <term>
                  Set the IsTransmittable property to false and raise an exception if
                  WriteTo is called.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="T:System.MessageBus.IInfosetElement">
            <summary>
               <para>An interface to expose an object as an XML infoset element.</para>
            </summary>
            <remarks>
               <para>Objects need to impement IInfosetElementb in order to be added to an 
                  IInfosetNode's IInfosetElementCollection.</para>
               <para>For example, the Message class stores MessageHeaders in a class that 
                  implments IInfosetElementCollection therefore MessageHeader implments
                  IInfosetItem.</para>
               <para>The IInfoset* interfaces are used to enable XML infoset navigation of objects 
                  by the <see cref="T:System.MessageBus.Filter"/>, <see cref="T:System.MessageBus.FilterTable"/>, and <see cref="T:System.MessageBus.FilterHierarchy"/>.</para>
            </remarks>
            <seealso cref="T:System.MessageBus.InfosetElementAttribute"/>
        </member>
        <member name="T:System.MessageBus.IInfosetItem">
            <summary>
               <para>Base interface for IInfosetAttribute and IInfosetElement.</para>
            </summary>
            <remarks>
               <para>The IInfoset* interfaces are used to enable XML infoset navigation of objects 
                  by the <see cref="T:System.MessageBus.Filter"/>, <see cref="T:System.MessageBus.FilterTable"/>, and <see cref="T:System.MessageBus.FilterHierarchy"/>. This is most useful for classes that derive from
               <see cref="T:System.MessageBus.MessageHeader"/>.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.IInfosetItem.Content">
            <summary>
               <para>The contents of the attribute or element.</para>
            </summary>
            <value>
               <para>The value of the attribute or element.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.IInfosetItem.Name">
            <summary>
               <para>The unqualified name of the infoset version of this item.</para>
            </summary>
            <value>
               <para>The unqualified name fo the infoset version of this item.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.IInfosetItem.Namespace">
            <summary>
               <para>The namespace used to qualify the name of this item.</para>
            </summary>
            <value>
               <para>The value namespace used to qualify the name of this item.</para>
            </value>
        </member>
        <member name="M:System.MessageBus.MessageHeader.#ctor(System.String,System.Uri)">
            <overload>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.MessageHeader"/> class.</para>
            </overload>
            <summary>
               <para>Initializes a MessageHeader given a name and namespace.</para>
            </summary>
            <param name="name">The <see langword="string"/> representing the name of the MessageHeader</param>
            <param name="ns">The <see cref="T:System.Uri"/> representing the XML target namespace of the MessageHeader</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="ns"/> is <see langword="null"/></exception>
            <remarks>
            <para>Equivalent to MessageHeader(<paramref name="name"/>, <paramref name="ns"/>, 
            <see langword="false"/>, <see langword="null"/> ).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.MessageHeader.#ctor(System.String,System.Uri,System.Boolean,System.Uri)">
            <summary>
               <para>Initializes a MessageHeader given a name, namespace, whether it must be 
                  understood, and its intended processing role.</para>
            </summary>
            <param name="name">The <see langword="string"/> representing the name of the MessageHeader</param>
            <param name="ns">The <see cref="T:System.Uri"/> representing the XML target namespace of the MessageHeader</param>
            <param name="mustUnderstand"><see langword="true"/> to signify that the SOAP header's mustUnderstand attribute is set to true; otherwise, <see langword="false"/></param>
            <param name=" role">The <see cref="T:System.Uri"/> representing the intended processing role</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="ns"/> is <see langword="null"/></exception>
        </member>
        <member name="M:System.MessageBus.MessageHeader.#ctor(System.MessageBus.MessageHeader)">
            <summary>
               <para>Initializes one MessageHeader given another. </para>
            </summary>
            <param name='source'>The MessageHeader to be copied </param>
            <remarks>
               <para>This constructor creates a new MessageHeader by copying over property values from another MessageHeader. This is a simple 
                  kind of clone that always creates an instance of the base class. Only
                  property values defined in the base class MessageHeader are copied. This may be useful
                  in implementing Clone. </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.MessageHeader.Clone">
            <summary>
               <para>Creates a new MessageHeader that is a deep copy of the current instance.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.MessageHeader.GetXmlReader">
            <summary>
            <para>Creates an <see cref="T:System.Xml.XmlReader"/> to access the contents of the MessageHeader.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.MessageHeader.WriteStandardAttributes(System.Xml.XmlWriter)">
            <summary>
            <para>Serializes the base properties of MessageHeader to an <see cref="T:System.Xml.XmlWriter"/> .</para>
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/>to serialize the properties into</param>
            <remarks>
               <para>Helper function that may be useful when implementing 
                  WriteTo.</para>
            <para>Equivalent to WriteStandardAttributes12(<paramref name="writer"/>).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.MessageHeader.WriteStandardAttributes11(System.Xml.XmlWriter)">
            <summary>
            <para>Serializes the base properties of MessageHeader as SOAP 1.1 attrbutes to an <see cref="T:System.Xml.XmlWriter"/> .</para>
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/>to serialize the properties into</param>
            <remarks>
               <para>Name and Namespace are written out in per the XML 1.0 and XML Namespace 
                  standards. MustUnderstand and Role are written out in the SOAP 1.1 namespace as
                  the mustUnderstand and actor attributes, respectively.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.MessageHeader.WriteStandardAttributes12(System.Xml.XmlWriter)">
            <summary>
            <para>Serializes the base properties of MessageHeader as SOAP 1.2 attrbutes to an <see cref="T:System.Xml.XmlWriter"/> .</para>
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/>to serialize the properties into</param>
            <remarks>
               <para>Name and Namespace are written out in per the XML 1.0 and XML Namespace 
                  standards. MustUnderstand and Role are written out in the SOAP 1.2 namespace as
                  the mustUnderstand and role attributes, respectively. </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.MessageHeader.WriteTo(System.Xml.XmlWriter)">
            <overload>
               <para>Serialize the MessageHeader.</para>
            </overload>
            <summary>
               <para>Serialize the MessageHeader as XML using a default encoding.</para>
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/>to serialize the properties into</param>
            <remarks>
            <para>If IsTransmittable is <see langword="false"/>, implementations of WriteTo 
               should raise an exception when called.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.MessageHeader.System#ICloneable#Clone">
            <summary>
               <para>Creates a new object that is a copy of the current instance.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.MessageHeader.DidUnderstand">
            <summary>
               <para>Gets or sets whether this MessageHeader has been understood.</para>
            </summary>
            <value>
            <para><see langword="true"/> if this MessageHeader has been understood; otherwise, 
            <see langword="false"/>. The default is <see langword="false"/>.</para>
            </value>
            <remarks>
            <para>When an <see cref="T:System.MessageBus.IMessageHandler"/> processes a MessageHeader, the <see cref="T:System.MessageBus.IMessageHandler"/> should set the DidUnderstand property to 
            <see langword="true"/>.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.MessageHeader.IsTransmittable">
            <summary>
               <para>Gets whether this MessageHeader may be transmitted to another endpoint.</para>
            </summary>
            <value>
            <para><see langword='true'/> if this MessageHeader may be transmitted to another 
               endpoint; otherwise, <see langword='false'/>. The default is
            <see langword='true'/>.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.MessageHeader.MustUnderstand">
            <summary>
               <para>Gets whether this MessageHeader must be understood.</para>
            </summary>
            <value>
            <para><see langword="true"/> if the MessageHeader must be understood; otherwise 
            <see langword="false"/>.</para>
            </value>
            <remarks>
               <para>A MessageHeader is marked to indicate whether it may be 
                  ignored (advisory) or must be understood (required). Patterned after SOAP
                  1.1/1.2 must understand, the MustUnderstand property indicates that the
                  MessageHeader must be understood by the appropriate actor. A Must Understand
                  fault is generated if any MessageHeader in the <see cref="T:System.MessageBus.MessageHeaderCollection"/> is:</para>
               <list type="number"><item>
                  <term>Marked for a role that the endpoint fulfills, and</term>
               </item>
               <item>
                  <term>Marked must understand, and</term>
               </item>
               <item>
                  <term>Has not been understood</term>
               </item>
            </list>
            <para>When an <see cref="T:System.MessageBus.IMessageHandler"/> processes a MessageHeader, the <see cref="T:System.MessageBus.IMessageHandler"/> should set the DidUnderstand property to 
            <see langword="true"/>.</para>
            <para>When a <see cref="T:System.MessageBus.Message"/> is received on a <see cref="T:System.MessageBus.Port"/>, the system-defined <see cref="T:System.MessageBus.DidUnderstandPortExtension"/> performs the three-point check described 
            above and generates a fault as needed. This check is performed before
            application-specific <see cref="T:System.MessageBus.Message"/> processing (before <see cref="!:System.MessageBus.Port.ReceiveChannel.Handler"/> is called); if a receiver needs to process an
            application MessageHeader, it should define a <see cref="T:System.MessageBus.PortExtension"/>
            to do that before the <see cref="P:System.MessageBus.PortReceiveStages.DidUnderstand"/> stage.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.MessageHeader.Name">
            <summary>
               <para>Gets the name of this MessageHeader.</para>
            </summary>
            <value>
            <para>The <see langword='string'/> representing the name of the MessageHeader.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.MessageHeader.Namespace">
            <summary>
               <para>Gets the namespace of the MessageHeader. </para>
            </summary>
            <value>
            <para>The <see cref="T:System.Uri"/> 
            representing the XML target namespace of the MessageHeader.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.MessageHeader.Role">
            <summary>
               <para> Gets the role (or actor) for this MessageHeader.</para>
            </summary>
            <value>
            <para>The <see cref="T:System.Uri"/> 
            representing the role intended to process this MessageHeader.</para>
            </value>
            <remarks>
               <para>A MessageHeader has a Role property. Patterned after the SOAP 1.2 role (SOAP 
                  1.1 actor), an endpoint fulfills one or more processing roles; the Role of a
                  MessageHeader indicates which of these roles is expected to process the
                  MessageHeader. Note that any given endpoint may fulfill more than one role.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.MessageHeader.System#MessageBus#IInfosetItem#Content">
            <summary>
               <para>Gets the InfoSetItem content.</para>
            </summary>
            <value>
               <para>The MessageHeader</para>
            </value>
        </member>
        <member name="M:System.MessageBus.MessageProperty.#ctor">
            <overload>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.MessageProperty"/> class.</para>
            </overload>
            <summary>
               <para>Initializes a MessageProperty with default name and namespace.</para>
            </summary>
            <remarks>
               <para>Equivalent to MessageProperty(null, null).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.MessageProperty.#ctor(System.String,System.Uri)">
            <summary>
               <para>Initializes a MessageProperty given a name and namespace.</para>
            </summary>
            <param name='name'>The string that is the name of the MessageProperty.</param>
            <param name=' uri'>The Uri that is the namespace for the MessageProperty.</param>
        </member>
        <member name="M:System.MessageBus.MessageProperty.#ctor(System.MessageBus.MessageProperty)">
            <summary>
               <para>Initializes a MessageProperty by copying another one.</para>
            </summary>
            <param name='source'>The MessageProperty to be copied.</param>
            <remarks>
               <para>This constructor creates a new MessageHeader by copying over property values 
                  from another MessageHeader. This is a simple kind of clone that always creates
                  an instance of the base class. Only property values defined in the base class
                  MessageHeader are copied. This may be useful in implementing Clone.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.MessageProperty.WriteTo(System.Xml.XmlWriter)">
            <summary>
               <para> Serialize the header into an XML Writer.</para>
            </summary>
            <exception cref="T:System.NotSupportedException">Always</exception>
            <remarks>
               <para>Always raises an exception since MessageProperties are not 
                  transmitted across <see cref="T:System.MessageBus.Port"/>
                  boundaries.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.MessageProperty.IsTransmittable">
            <summary>
            <para>Whether this <see cref="T:System.MessageBus.MessageHeader"/> may be transmitted when the 
            <see cref="T:System.MessageBus.Message"/> is sent to another <see cref="T:System.MessageBus.Port"/> 
            .</para>
            </summary>
            <value>
               <para>false</para>
            </value>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingHeader.Clone">
            <summary>
            Required method from MessageHeader
            </summary>
            <returns></returns>
        </member>
        <member name="P:System.MessageBus.Management.Logging.LoggingHeader.DateString">
            <summary>
            Public getter that returns the timestamp in 
            yyyy-MM-dd format.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Logging.LoggingHeader.LocationString">
            <summary>
            Location property
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Logging.LoggingHeader.TimeStampString">
            <summary>
            TimeStamp as string property
            </summary>
        </member>
        <member name="T:System.MessageBus.Management.Logging.LoggingProperty">
            <summary>
               <para>Encapsulates a single message property that can be logged.</para>
            </summary>
            <remarks>
               <para>A logging property is identified by a FieldName and a
                  PropertyExpression. The FieldName is what is used to identify the property in
                  the underlying store while the PropertyExpression is an instruction that
                  indicates how to retrieve the property's value from a message.</para>
            </remarks>
            <example>
               <para> 
                  The
                  following
                  is
                  a configurationexample of logging properties</para>
               <para>&lt;LoggingProperties&gt; </para>
               <para>&lt;Property&gt; </para>
               <para>&lt;FieldName&gt;next&lt;/FieldName&gt; 
                  &lt;Expression&gt;/env:Envelope/env:Header/rt:path/rt:fwd/rt:via[1]&lt;/Expression&gt; </para>
               <para>&lt;/Property&gt; </para>
               <para>&lt;Property&gt; </para>
               <para>&lt;FieldName&gt;action&lt;/FieldName&gt; 
                  &lt;Expression&gt;/env:Envelope/env:Header/rt:path/rt:action&lt;/Expression&gt; </para>
               <para>&lt;/Property&gt; </para>
               <para>&lt;/LoggingProperties&gt; </para>
               <para>&lt;Namespaces xmlns:env="http://www.w3.org/2001/12/soap-envelope" 
                  xmlns:rt="http://schemas.xmlsoap.org/ws/2002/05/routing" /&gt; </para>
                <para> The following is a code based example of logging properties </para>
                <para> </para>
            </example>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingProperty.#ctor(System.String,System.String)">
            <summary>
               <para>Initializes a LoggingProperty with a field name and 
                  property expression. Field name is a friendly name to be used in
                  logging and the property expression is an expression indicating how to retrieve the property from the message object.</para>
            </summary>
            <param name="fieldName">The LoggingProperty's field name</param>
            <param name="propertyExpression">The LoggingProperty's property expression</param>
            <exception cref="!:ArgumentNull">propertyExpression is null</exception>
            <exception cref="!:ArgumentNull">filedName is null</exception>
            <remarks>
               <para>The typical usage is to construct a set of logging properties and to pass 
                  them to the LoggingStore object before adding the logging port extension. The
                  expression for the logging property follows the XPath model where the specific
                  element to be logged from the message object is specified as a path from the
                  root document element. </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingProperty.CompareTo(System.Object)">
            <summary>
            Method that compares the current object to a given one as far as the field is
            concenrend.
            </summary>
            <param name="obj">The object oto compare against.</param>
            <returns>An integer indicating whether the objects are the same or not.</returns>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingProperty.Equals(System.Object)">
            <summary>
            Method that compares two objects.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingProperty.GetHashCode">
            <summary>
            Gets the hashcode for this logging property. This is defined
            as the hashcode for the field name.
            </summary>        
        </member>
        <member name="P:System.MessageBus.Management.Logging.LoggingProperty.FieldName">
            <summary>
            Gets the field name for this property
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Logging.LoggingProperty.PropertyExpression">
            <summary>
            Gets the identifying expresssion for this property.
            </summary>
            <remarks>
            TODO: This will be an xpath expression that uniquely identifies
                  the property in a message. For now we only support several hard coded identifiers.
            </remarks>
        </member>
        <member name="T:System.MessageBus.Management.Logging.LoggingStore">
            <summary>
            Provides the backing store for logging message fields to a text file.   
            </summary>
        </member>
        <member name="T:System.MessageBus.Management.InstrumentationExtension">
            <summary>
            Abstract class that all the instrumentation extension managers
            will inherit from.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.InstrumentationExtension.Port">
            <summary>
            Port property
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingStore.#ctor(System.MessageBus.Port,System.String,System.String,System.MessageBus.Management.Logging.RotationPolicy,System.Int64,System.MessageBus.Management.Logging.LoggingProperty[],System.Xml.XmlNamespaceManager,System.Text.Encoding)">
            <summary>
            Initializes a LoggingStore.
            </summary>
            <param name="port">The port that this store is hooked up to.</param>
            <param name="prefix">The log file prefix</param>
            <param name="directory">The directory to place log files</param>
            <param name="rotationPolicy">The policy used to determine when log files should be rotated if at all.</param>
            <param name="encoding">The text encoding to use.</param>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingStore.Finalize">
            <summary>
            The finalizer for this store.
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingStore.AddExtension">
            <summary>
            Adds the spy extension to the port.
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingStore.GetDefaultProperties(System.MessageBus.Management.Logging.LoggingProperty[]@,System.Xml.XmlNamespaceManager@)">
            <summary>
            Gets commonly used logging properties for the store.
            </summary>
            <remarks>
            The set of logging properties added include the route header's 
            Next and Action properties. In addition, the logging 
            header's Location and TimeStamp properties are added.
            </remarks>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingStore.ConstructNewLogEntry(System.MessageBus.Message)">
            <summary>
            Given a message this routine will determine what the next stream of bytes
            to be logged must be.
            </summary>
            <param name="message">The message being logged</param>        
            <returns>The bytes to be written to the log file</returns>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingStore.ContainsWhitespace(System.String)">
            <summary>
            Helper method that searches for whitespace in a given string
            </summary>
            <param name="s">The string to search</param>
            <returns>A bool value</returns>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingStore.Dispose">
            <summary>
            Cleans up the logging store's held resources.
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingStore.Dispose(System.Boolean)">
            <summary>
            Cleans up the logging store's held resources.
            </summary>
            <param name="disposing">
            true if this method was called by another method such as Close or Dispose; 
            false if this method was called by the finalizer.
            </param>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingStore.GetBoundedSizeFileName">
            <summary>
            Gets the name of the file the store should be writing to
            assuming a BoundedSize rotation policy.
            </summary>
            <returns>The filename that should be used.</returns>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingStore.GetDirectives">
            <summary>
            Helper function that is returning the durectives as byte array.
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingStore.GetLogFileName(System.DateTime)">
            <summary>
            Gets the filename to be used for the log.
            </summary>
            <param name="logTime">This method returns the current log file name</param>
            <remarks>
            This is not a fast call so use it only when you need to.
            </remarks>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingStore.ShouldRotate(System.DateTime)">
            <summary>
            Determines if it is time to rotate the log file.
            </summary>
            <param name="logTime">The current timespamp</param>
            <returns>A bool value indicating whether we should prduce a new log file or not.</returns>
            <remarks>Should only be invoked while the logStreamLock is held.</remarks>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingStore.OnMessageClose(System.Object,System.EventArgs)">
            <summary>
            Event handler that is called when someone closes the message. We need to 
            call the async result somehow.
            </summary>
            <param name="sender">The message object.</param>
            <param name="e">Event arguments</param>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingStore.OnWriteComplete(System.IAsyncResult)">
            <summary>
            Called when a stream's asynchronous write operation completes
            </summary>
            <param name="result">IAsyncResult variable</param>
        </member>
        <member name="M:System.MessageBus.Management.Logging.LoggingStore.WriteDirectives(System.Text.StringBuilder)">
            <summary>
            Takes a string builder and add to it the logging directives
            </summary>
            <param name="sb">String builder object</param>
        </member>
        <member name="T:System.MessageBus.Management.Logging.MessageHandlerLocation">
            <summary>
            Specifies the location of the logging handler in a web service's logical
            pipelines.
            </summary>
        </member>
        <member name="T:System.MessageBus.Management.Logging.RotationPolicy">
            <summary>
               <para>Specifies a log file rotation policy for a LoggingStore. 
                  The options are Hourly, Daily, Monthly, BoundedSize or None. The default is
                  None. Based on the rotation policy, the file where the log information is stored
                  changes periodically. If it is hourly, daily, monthly the file rotation is time
                  based. If it is set to be BoundedSize, then the file name is incremented when the specified size is reached.</para>
            </summary>
            <remarks>
               <para>File name is determined as follows:</para>
               <para>Hourly - prefix_yyyymmddhh.log</para>
               <para>Daily - prefix_yyyymmdd.log</para>
               <para>Monthly - prefix_yyyymm.log</para>
               <para>BoundedSize- prefix_[lastcnt+1].log</para>
            </remarks>
            <example>
               <para> 
                  The following example illustrates
                  the
                  use
                  of configuration
                  for
                  controlling
                  the
                  logging
                  rotation
                  semantics...
                  </para>
               <para>&lt;Management&gt; </para>
               <para>&lt;Logging&gt; </para>
               <para>&lt;Enable /&gt; </para>
               <para>&lt;FilePrefix&gt;WHSvr1&lt;/FilePrefix&gt; </para>
               <para>&lt;Directory&gt;c:\temp&lt;/Directory&gt; </para>
               <para>&lt;RotationPolicy&gt;Daily&lt;/RotationPolicy&gt; </para>
               <para>&lt;FileSizeThreshold&gt;200000&lt;/FileSizeThreshold&gt; </para>
               <para>&lt;/Logging&gt; </para>
               <para>&lt;/Management&gt; </para>
            </example>
        </member>
        <member name="F:System.MessageBus.Management.Logging.RotationPolicy.Hourly">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Management.Logging.RotationPolicy.Daily">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Management.Logging.RotationPolicy.Monthly">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Management.Logging.RotationPolicy.BoundedSize">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Management.Logging.RotationPolicy.None">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Management.Performance.PerformanceCounterInstrumentationExtension">
            <summary>
            The PerformanceCounterInstrumentationExtension is the standard instrumentation
            (aka management) extension to implement performance counters.
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.Performance.PerformanceCounterInstrumentationExtension.#ctor(System.MessageBus.Port)">
            <summary>
               <para>Construct the PerformanceCounterInstrumentationExtension 
                  object and associate it with the given port.</para>
            </summary>
            <param name='port'>The port to which to add the PerformanceCounterExtension</param>
            <remarks>
               <para>The act of creating a PerformanceCounterInstrumentationExtension
                  for a given port initializes the performance counters that the 
                  Message Bus emits and initializes the handlers on different 
                  channels associated with the port.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Management.Performance.PerformanceCounterInstrumentationExtension.AddExtension">
            <summary>
               <para>Force our extension to be added to the port. This is typically invoked
                  by the code that reads our configuration file.</para>
            </summary>
            <exception cref="!:PortNull">Port parameter that this instance was initialized with is null </exception>
            <exception cref="!:PortOpen">Port is already opened.</exception>
        </member>
        <member name="P:System.MessageBus.Management.Performance.PerformanceCounterInstrumentationExtension.Enabled">
            <summary>
            Boolean value that controls whether or not we actually install the real
            performance counter hooks when AddExtension is called. This is needed
            to allow an application configuration file to override and disable
            performance counters configured in the machine.config file.
            </summary>
        </member>
        <member name="T:System.MessageBus.Management.Spy.MBPortState">
            <summary>
            This class is containing information about a port that the spy engine
            has knowledge about. Therefore the engine holds one object of this class per 
            port and contains the information that came back after the latest successful ping 
            on that port.
            </summary>
        </member>
        <member name="T:System.MessageBus.Management.Spy.ReplyContentBase">
            <summary>
            This class is used to represent the default content in the Spy Message 
            reply messages.
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.Spy.ReplyContentBase.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.ReplyContentBase.CustomInfo">
            <summary>
            CustomInfo public property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.ReplyContentBase.HasError">
            <summary>
            HasError public property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.ReplyContentBase.RefId">
            <summary>
            Id public property.
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.Spy.MBPortState.#ctor">
            <summary>
            Default Ctor.
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.Spy.MBPortState.#ctor(System.Uri)">
            <summary>
            Ctor.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.MBPortState.Host">
            <summary>
            Host property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.MBPortState.PId">
            <summary>
            PId property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.MBPortState.PortUri">
            <summary>
            PortUri property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.MBPortState.PortUriAsString">
            <summary>
            Property that returns the Port's uri as string/
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.MBPortState.ProcessName">
            <summary>
            ProcessName property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.MBPortState.RoundTripTime">
            <summary>
            RoundTripTime property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.MBPortState.RoundTripTimeAsString">
            <summary>
            RoundTripTime property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.MBPortState.Utilization">
            <summary>
            Utilization property.
            </summary>
        </member>
        <member name="T:System.MessageBus.Management.Spy.MessageAction">
            <summary>
            Class that contains all the constant strings that will be needed
            when constructing the various messages.
            </summary>
        </member>
        <member name="T:System.MessageBus.Management.Spy.ProcessOutcome">
            <summary>
            Enumerator with the list of the possible events that can
            happen to a message.
            </summary>
        </member>
        <member name="T:System.MessageBus.Management.Spy.RequestContentBase">
            <summary>
            This class is used to represent the default content in the Spy Message 
            request messages.
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.Spy.RequestContentBase.#ctor">
            <summary>
            Constructor for messages that do not care about filters.
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.Spy.RequestContentBase.#ctor(System.String,System.Int64)">
            <summary>
            Constructor for messages that do not care about filters.
            </summary>
            <param name="action">The action that this message content represents.</param>
            <param name="id">The id of the request, this will be used to associate the reply with the
            request.</param>
        </member>
        <member name="M:System.MessageBus.Management.Spy.RequestContentBase.#ctor(System.Uri,System.Int64)">
            <summary>
            Constructor for messages that do not care about filters.
            </summary>
            <param name="action">The Uri action that this message content represents.</param>
            <param name="id">The id of the request, this will be used to associate the reply with the
            request.</param>
        </member>
        <member name="M:System.MessageBus.Management.Spy.RequestContentBase.#ctor(System.Uri,System.Int64,System.String)">
            <summary>
            Constructor for messages that do not care about filters.
            </summary>
            <param name="action">The Uri action that this message content represents.</param>
            <param name="id">The id of the request, this will be used to associate the reply with the
            request.</param>
            <param name="filter">The filter that specifies which messages we are interested in.</param>
        </member>
        <member name="M:System.MessageBus.Management.Spy.RequestContentBase.#ctor(System.String,System.Int64,System.String)">
            <summary>
            Constructor for messages that do not care about filters.
            </summary>
            <param name="action">The action that this message content represents.</param>
            <param name="id">The id of the request, this will be used to associate the reply with the
            request.</param>
            <param name="filter">The filter that specifies which messages we are interested in.</param>
        </member>
        <member name="P:System.MessageBus.Management.Spy.RequestContentBase.Action">
            <summary>
            Action public property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.RequestContentBase.Id">
            <summary>
            Id public property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.RequestContentBase.MessageToTrace">
            <summary>
            MessageToTrace public property.
            </summary>
        </member>
        <member name="T:System.MessageBus.Management.Spy.SpyInstrumentationManager">
            <summary>
            Manager for Spy management extensions.
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.Spy.SpyInstrumentationManager.#ctor(System.MessageBus.Port)">
            <summary>
            Constructor.
            </summary>
            <param name="port">Port where this extension will hook apply to.</param>
        </member>
        <member name="M:System.MessageBus.Management.Spy.SpyInstrumentationManager.AddExtension">
            <summary>
            Adds the spy extension to the port.
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.Spy.SpyInstrumentationManager.ProcessMessageException(System.MessageBus.MessageException)">
            <summary>
            This method given a Message Exception removes the entries related to an
            invalid enpoint from the internal spy tables.
            </summary>
            <param name="mex"></param>
        </member>
        <member name="M:System.MessageBus.Management.Spy.SpyInstrumentationManager.OnMessageClose(System.Object,System.EventArgs)">
            <summary>
            Event handler that is called when someone closes the message. We need to 
            call the async result somehow.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="P:System.MessageBus.Management.Spy.SpyInstrumentationManager.TraceTable">
            <summary>
            TraceTable getter
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.SpyInstrumentationManager.SpyTable">
            <summary>
            SpyTable getter
            </summary>
        </member>
        <member name="T:System.MessageBus.Management.Spy.SpyReplyContent">
            <summary>
            This class is used to represent the default content in the Spy Message 
            reply messages.
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.Spy.SpyReplyContent.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.Spy.SpyReplyContent.#ctor(System.Uri)">
            <summary>
            Constructor.
            </summary>
            <param name="client">The uri of the client that will receive the reply</param>
        </member>
        <member name="P:System.MessageBus.Management.Spy.SpyReplyContent.AssociatingMessageId">
            <summary>
            AssociatingMessageId public property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.SpyReplyContent.ClientUriAsString">
            <summary>
            ClientUriAsString public property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.SpyReplyContent.Headers">
            <summary>
            Headers public property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.SpyReplyContent.MatchingFilter">
            <summary>
            MatchingFilter public property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.SpyReplyContent.MessageProcessingOutcome">
            <summary>
            MessageProcessingOutcome public property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.SpyReplyContent.TimeStamp">
            <summary>
            TimeStamp public property.
            </summary>
        </member>
        <member name="T:System.MessageBus.Management.Spy.TraceHeader">
            <summary>
            This class represents the transmittable header that is attached to a message to indicate
            that the current message has to be traced.
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.Spy.TraceHeader.#ctor(System.Uri[],System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="receivers">A Uri array that contains the names of the
            clients that wish to receive a trace-route notification.</param>
        </member>
        <member name="M:System.MessageBus.Management.Spy.TraceHeader.#ctor(System.Collections.ArrayList,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="receivers">An array list that contains the names of the
            clients that wish to receive a trace-route notification.</param>
        </member>
        <member name="M:System.MessageBus.Management.Spy.TraceHeader.#ctor(System.MessageBus.Management.Spy.TraceHeader)">
            <summary>
            Constructor that creates a new TraceHEader based of an old one
            </summary>
            <param name="source">Source trace header.</param>
        </member>
        <member name="M:System.MessageBus.Management.Spy.TraceHeader.Clone">
            <summary>
            Clones a trace header
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.MessageBus.Management.Spy.TraceHeader.ExtractTraceHeader(System.MessageBus.Message)">
            <summary>
            Method that extracts the message trace header from a message.
            </summary>
            <param name="m">Message to extract teh header from.</param>
        </member>
        <member name="M:System.MessageBus.Management.Spy.TraceHeader.WriteTo(System.Xml.XmlWriter)">
            <summary>
            Method that writes the header to a stream.
            </summary>
            <param name="writer"></param>
        </member>
        <member name="P:System.MessageBus.Management.Spy.TraceHeader.Receivers">
            <summary>
            Receivers public property.
            </summary>
        </member>
        <member name="T:System.MessageBus.Management.Spy.TraceReplyContent">
            <summary>
            This class is used to represent the default content in the trace-route  
            reply messages.
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.Spy.TraceReplyContent.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.Spy.TraceReplyContent.#ctor(System.Uri)">
            <summary>
            Constructor.
            </summary>
            <param name="client">The uri of the client that will receive the reply</param>
        </member>
        <member name="P:System.MessageBus.Management.Spy.TraceReplyContent.AssociatingMessageId">
            <summary>
            AssociatingMessageId public property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.TraceReplyContent.ClientUriAsString">
            <summary>
            ClientUriAsString public property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.TraceReplyContent.Headers">
            <summary>
            Headers public property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.TraceReplyContent.MatchingFilter">
            <summary>
            MatchingFilter public property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.TraceReplyContent.NodeTrace">
            <summary>
            NodeTrace property.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.Spy.TraceReplyContent.TimeStamp">
            <summary>
            TimeStamp property.
            </summary>
        </member>
        <member name="T:System.MessageBus.Management.InstrumentationExtensionCollection">
            <summary>
            Collection for instrumentation extensions.
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.InstrumentationExtensionCollection.Add(System.MessageBus.Management.InstrumentationExtension)">
            <summary>
            Add method
            </summary>
            <param name="extension">Object to be added.</param>
            <returns>Return the size of the collection after the insertion.</returns>
        </member>
        <member name="M:System.MessageBus.Management.InstrumentationExtensionCollection.Contains(System.MessageBus.Management.InstrumentationExtension)">
            <summary>
            Contains method.
            </summary>
            <param name="extension">Object to be added.</param>
            <returns>Return the size of the collection after the insertion.</returns>
        </member>
        <member name="M:System.MessageBus.Management.InstrumentationExtensionCollection.CopyTo(System.MessageBus.Management.InstrumentationExtension[],System.Int32)">
            <summary>
            CopyTo method.
            </summary>
            <param name="array">Array to copy</param>
            <param name="index">Index to start copying from.</param>
        </member>
        <member name="M:System.MessageBus.Management.InstrumentationExtensionCollection.IndexOf(System.MessageBus.Management.InstrumentationExtension)">
            <summary>
            Gives the index of an extension object in the collection.
            </summary>
            <param name="extension">The extension object to look for.</param>
            <returns>The index of the object.</returns>
        </member>
        <member name="M:System.MessageBus.Management.InstrumentationExtensionCollection.Insert(System.Int32,System.MessageBus.Management.InstrumentationExtension)">
            <summary>
            Inserts an extension object in the specified index.
            </summary>
            <param name="index">The zero-based index at which value should be inserted</param>
            <param name="extension">The value to insert.</param>
        </member>
        <member name="M:System.MessageBus.Management.InstrumentationExtensionCollection.OnValidate(System.Object)">
            <summary>
            Performs additional custom processes when validating a value.
            </summary>
            <param name="value">the value to validate.</param>
        </member>
        <member name="M:System.MessageBus.Management.InstrumentationExtensionCollection.Remove(System.MessageBus.Management.InstrumentationExtension)">
            <summary>
            Removes an object from the collection.
            </summary>
            <param name="extension">The object to remove.</param>
        </member>
        <member name="P:System.MessageBus.Management.InstrumentationExtensionCollection.Item(System.Int32)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:System.MessageBus.Management.InstrumentationManager">
            <summary>
            This class contains a collection of Instrumentation Extensions.
            It is a common place holder for all the extensions. In this way the
            configuration handler or the user can interate through them and interact
            with them.
            </summary>
        </member>
        <member name="M:System.MessageBus.Management.InstrumentationManager.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:System.MessageBus.Management.InstrumentationManager.Extensions">
            <summary>
            Extensions property.
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.AccessMapping">
            <summary>
               <para>AccessMapping maps an input role, in the form of a 
                  string, to a filter on the message. If the message satisfies the filter and the
                  identities associated with the message have been mapped to the specified role,
                  then the message can perform the specified action. In other words, an access mapping is a role
                  to filter mapping which allows identities with the specified role to perform the action
                  as dictated by the message filter.</para>
            </summary>
            <remarks>
               <para>Add accessmappings to the access mappings collection on 
                  the securityManager's receiver. Access mappings specify roles that are granted
                  access to web service methods. For example, the "author" role might be granted
                  permission to perform "soap://read" and "soap://write" methods. These web
                  service methods are specified as a message filter. When a message matching the
                  specified filter arrives, (when a message tries to access a specific web service
                  method), the role(s) are obtained from the tokens associated with the message
                  (and based on identityproviders and identitymapproviders) and matched against
                  the required roles in the accessmappings. If the roles match, then the message
                  is authorized to perform the action. If the specified action doesn't have an
                  associated role, then all requests to this action fail.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Security.AccessMapping.#ctor(System.String,System.MessageBus.Filter)">
            <summary>
               <para>Constructor that initializes the specified filter for the role.</para>
            </summary>
            <param name="roleCondition">the role required</param>
            <param name="actionFilter">the filter that is used to capture messages with the intended action</param>
            <exception cref="T:System.ArgumentNullException">actionFilter parameter is null</exception>
            <exception cref="!:NotNullEmptyParameter">roleCondition parameter is null or of zero length</exception>
            <exception cref="!:AnonymousMappingProhibited">roleCondition specifies an anonymous role</exception>
            <remarks>
               <para>This method sets up one role to filter mapping.</para>
            </remarks>
            <example>
               <code lang="C#">// create an access mapping
            AccessMapping authorAccess = new AccessMapping("Author", Filter.MatchAllFilter));
            
            // add the access mapping to the receiver access mappings collection. 
            securityManager.Receiver.AccessMappings.Add(authorAccess);
            
            // create another access mapping
            AccessMapping viewer = new AccessMapping("viewer", new Filter(@"/env:Envelope/env:Header/rt:path[rt:action='soap://read/']", ns));
            
            // add to the receiver access mapping collection.
            securityManager.Receiver.AccessMappings.Add(viewer);
               </code>
            </example>
        </member>
        <member name="P:System.MessageBus.Security.AccessMapping.Role">
            <summary>
               <para>Returns the role for this access mapping.</para>
            </summary>
            <value>
               <para>The role of the access mapping. </para>
            </value>
        </member>
        <member name="P:System.MessageBus.Security.AccessMapping.Filter">
            <summary>
               <para>Returns the filter that this accessmapping contains.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.AccessMappingCollection">
            <summary>
            <para>Contains a list of <see cref="T:System.MessageBus.Security.AccessMapping"/>s. Individual 
               elements of the collection are accessed through their index location. The
               receiver on the security manager has an instance of this class that is used to
               provide message/method authorization.</para>
            </summary>
            <remarks>
               <para>AccessMappings are used to provide message/method 
                  authorization. To provide a role authorized access to a method, an access
                  mapping is created and added to the access mapping collection on the
                  securityManager's <see cref="T:System.MessageBus.Security.SecurityReceiver"/> object. AccessMappingCollection
                  provides support for managing multiple AccessMappings. Derived from <see cref="T:System.Collections.CollectionBase"/>
                  .</para>
            </remarks>
            <example>
               <code lang="C#">// add the author access mapping to the security receiver.
            
            securityManager.Receiver.AccessMappingCollection.Add(new AccessMapping("author", new Filter("/env.Envelope/env.Header/rt:path[rt:action='soap:write']", ns));
            securityManager.Receiver.AccessMappingCollection.Add(new AccessMapping("author", new Filter("/env.Envelope/env.Header/rt:path[rt:action='soap:read']", ns));
               </code>
            </example>
        </member>
        <member name="M:System.MessageBus.Security.AccessMappingCollection.Add(System.MessageBus.Security.AccessMapping)">
            <summary>
               <para>Add the accessMapping to the accessmappingcollection. 
                  The accessMapping entry is appended to the AccessMappingCollection.</para>
            </summary>
            <param name="accessMapping">accessMapping to add the collection</param>
            <returns>
               <para>Zero based positional index where the access mapping is added.</para>
            </returns>
            <exception cref="!:AnonymousMappingForbidden">accessMapping parameter refers to an anonymous mapping</exception>
            <exception cref="T:System.ArgumentNullException">accessMapping parameter is null</exception>
        </member>
        <member name="M:System.MessageBus.Security.AccessMappingCollection.Contains(System.MessageBus.Security.AccessMapping)">
            <summary>
               <para>Determines if the accessmappingcollection contains a 
                  specific accessmapping.</para>
            </summary>
            <param name='AccessMapping'>AccessMapping to check membership in the collection for</param>
            <returns>
               <para>True if the AccessMapping is found in the 
                  accessMappingCollection. False if not.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.Security.AccessMappingCollection.CopyTo(System.MessageBus.Security.AccessMapping[],System.Int32)">
            <summary>
               <para>Copies the entire accessMappings list to an array of 
                  accessMappings starting at the specified index.</para>
            </summary>
            <param name=' array'>An array of accessMapping entries to which the accessMappings from the AccessMappingCollection will be copied</param>
            <param name='index'>The index in the array at which to begin copying the accessMappings</param>
        </member>
        <member name="M:System.MessageBus.Security.AccessMappingCollection.IndexOf(System.MessageBus.Security.AccessMapping)">
            <summary>
               <para>Determines the specific index of the accessMapping in 
                  the AccessMappingCollection</para>
            </summary>
            <param name="accessMapping">The access mapping whose location in the collection is to be determined</param>
            <returns>
               <para>Index (zero based) where the access mapping is found in the collection. 
                  Otherwise returns -1.</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">access mapping element is null</exception>
        </member>
        <member name="M:System.MessageBus.Security.AccessMappingCollection.Insert(System.Int32,System.MessageBus.Security.AccessMapping)">
            <summary>
               <para>The access mapping is inserted at the specified index.</para>
            </summary>
            <param name=" index">The zero based index at which the accessMapping should be inserted.</param>
            <param name="accessMapping">The access mapping to insert into the access mapping collection.</param>
            <returns>
               <para>Nothing</para>
            </returns>
            <exception cref="!:ArgumentOutOrRangeException">The index parameter is not a valid index in the AccessMappingCollection</exception>
            <exception cref="T:System.ArgumentNullException">The accessMapping parameter is null</exception>
            <remarks>
               <para>If the index parameter is equal to the size of the AccessMappingCollection, 
                  then the accessMapping object is appended to the collection. Otherwise, when a
                  valid index (&gt;0 and &lt; size of tokenProviderCollection) is used, the
                  entries after the insertion point are moved down to accomodate the new
                  accessMapping element in the list. </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Security.AccessMappingCollection.Remove(System.MessageBus.Security.AccessMapping)">
            <summary>
               <para>Removes the specified accessMapping from the 
                  AccessMappingCollection.</para>
            </summary>
            <param name="accessMapping">The accessMapping to remove from the collection</param>
            <returns>
               <para>Nothing</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">The accessMapping parameter is null</exception>
        </member>
        <member name="P:System.MessageBus.Security.AccessMappingCollection.Item(System.Int32)">
            <summary>
               <para>Returns or sets the accessMapping at the specified index.</para>
            </summary>
            <param name="index">zero based positional index from which the accessMapping is retrieved or to which the access mapping is stored</param>
            <value>
               <para>AccessMapping retrieved from the AccessMappingCollection 
                  at the specified index.</para>
               <para>AccessMapping is set to the AccessMappingCollection at 
                  the specified index.</para>
            </value>
            <exception cref="!:AnonymousMappingProhibited">AccessMapping being added at the specified index is an anonymous role</exception>
        </member>
        <member name="T:System.MessageBus.Security.IRolesAsyncResult">
            <summary>
            The interface of the AsyncResult object returned by the BeginGetRoles method of identity mapping objects
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.IRolesAsyncResult.Roles">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.IdentityMapProvider">
            <summary>
               <para>IIdentityMapping objects map identities (under the scope 
                  of a resource) to roles. The IdentityMapProvider provides the abstract base class for identityMapProviders.</para>
            </summary>
            <remarks>
               <para>The system provides a simple identity map provider for 
                  populating and obtaining identity mappings from an in memory store.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Security.IdentityMapProvider.OnBeginGetRoles(System.String,System.String,System.String,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynch method for obtaining the roles given the idenity 
                  providers to use, the resource being accessed and the identity to use.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.IdentityMapProvider.OnEndGetRoles(System.MessageBus.Security.IRolesAsyncResult)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.IdentityMapProviderCollection">
            <summary>
               <para>The identityMapProvider collection contains a list of 
                  IdentityMapProviders. Individual elements of the collection can be accessed by
                  their index location. IdentityMapProviders provide a mechanism for obtaining
                  idenity mappings, i.e., (identity, resource) mappings to roles.</para>
            </summary>
            <remarks>
               <para>Use the identityMapProvidersCollection to add (multiple) 
                  identityMapProviders. The system implements a simpleIdentityMapProvider. The
                  security receiver contains an identityMapProviderCollection that is used specify
                  a simple mapping. The system obtains the identities from the tokens attached to
                  the message using the identityProviders, the resource that the message attempts
                  to access and uses the idenityMapProviders in the collection to map the
                  requesting entity to a specific role.</para>
               <para>The system currently implements the following identityMapProviders:</para>
               <list type='bullet'><item>
                  <term>SimpleIdentityMapProvider</term>
               </item>
            </list>
            </remarks>
            <example>
               <code lang='C#'>// create a simple identity map provider. 
                SimpleIdentityMapProvider identityMapProvider = new SimpleIdentityMapProvider();
            // add the identitymap to the identityMapProvider
                identityMapProvider.Mappings.Add(new SimpleIdentityMapping("windows:*","","Author"));                        
            // add the simple identityMapProvider to the IdentityMapProviders collection at the receiver
                securityManager.Receiver.IdentityMapProviders.Add(identityMapProvider);
               </code>
            </example>
        </member>
        <member name="M:System.MessageBus.Security.IdentityMapProviderCollection.Add(System.MessageBus.Security.IdentityMapProvider)">
            <summary>
               <para>Append the identityMapProvider to the 
                  identityMapProvider collection.</para>
            </summary>
            <param name="identityMapProvider">The identity map provider added to be added to the collection</param>
            <returns>
               <para>Zero based position where the identity provider is added.</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">identityMapProvider parameter is null</exception>
        </member>
        <member name="M:System.MessageBus.Security.IdentityMapProviderCollection.Contains(System.MessageBus.Security.IdentityMapProvider)">
            <summary>
               <para>Determines whether the identityMapProvider list contains 
                  the identityMapProvider.</para>
            </summary>
            <param name="identityMapProvider">The identityMapProvider to test membership in the collection for.</param>
            <returns>
               <para>True if found. False otherwise.</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">identityMapProvider parameter is null.</exception>
        </member>
        <member name="M:System.MessageBus.Security.IdentityMapProviderCollection.CopyTo(System.MessageBus.Security.IdentityMapProvider[],System.Int32)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.IdentityMapProviderCollection.IndexOf(System.MessageBus.Security.IdentityMapProvider)">
            <summary>
               <para>Returns the location where the identityMapProvider is found.</para>
            </summary>
            <param name="identityMaprProvider">The identity map provider to search for and return the zero based index in the collection.</param>
            <returns>
               <para>The positional index where the identityMapProvider is 
                  found in the identityMapProvidersCollection. -1 if not found.</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">identityMapProvider is null.</exception>
        </member>
        <member name="M:System.MessageBus.Security.IdentityMapProviderCollection.Insert(System.Int32,System.MessageBus.Security.IdentityMapProvider)">
            <summary>
               <para>Insert the specified identityMapProvider at the 
                  specified index in the identityMapProviderCollection</para>
            </summary>
            <param name=" index">The zero based index where the identityMapProvider is to be inserted</param>
            <param name="identityMapProvider">The identityMapProvider to insert at the specified index</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The index parameter is not within the bounds of the collection</exception>
            <exception cref="T:System.ArgumentNullException">The identityMapProvider parameter is null</exception>
            <remarks>
               <para>If the index parameter is equal to the size of the 
                  identityMapProviderCollection, the identityMapProvider is appended to the
                  collection. If it is within the bounds of the identityMapProviderCollection, all
                  elements after the insertion point are moved down to accomodate the
                  identityMapProvider into the list.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Security.IdentityMapProviderCollection.Remove(System.MessageBus.Security.IdentityMapProvider)">
            <summary>
               <para>Remove the specified identityMapProvider from the collection.</para>
            </summary>
            <param name='identityMapProvider'>The identityMapProvider to be removed from the collection</param>
        </member>
        <member name="P:System.MessageBus.Security.IdentityMapProviderCollection.Item(System.Int32)">
            <summary>
               <para>Return the identityMapProvider at the specified location.</para>
            </summary>
            <param name='index'>zero based index into the list of identity map providers used to retrieve the identity map providers </param>
            <value>
               <para>Identity Map provider at the specified index returned 
                  from the identityMapProvider collection</para>
            </value>
        </member>
        <member name="T:System.MessageBus.Security.IdentityProvider">
            <summary>
               <para>IdentityProvider objects perform trust checks on the 
                  class of tokens they understand, and extract the identity information from the tokens. Provides the
                  abstract base class for a strongly typed IdenityProvider.</para>
            </summary>
            <remarks>
               <para>This base class is provided to make it easier for 
                  implementers to create a IdenityProviders. The derived classes for the
                  current drop are: </para>
               <list type='bullet'><item>
                  <term>WindowsIdentityProvider</term>
               </item>
               <item>
                  <term>UserNameIdentityProvider</term>
               </item>
               <item>
                  <term>X509IdenityProvider</term>
               </item>
            </list>
            <para>IdentityProvider(s) have methods for getting the tokenType and for getting 
               the identity from the token given. IdentityProviders also perform trust check on
               the token. For the WindowsIdentityProvider and UserNameIdentityProvider trust
               check is implicit. For X509IdentityProvider the trust check involves validating
               the cert chain to the list of trusted roots. </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Security.IdentityProvider.OnGetIdentity(System.MessageBus.Security.ISecurityToken,System.MessageBus.Security.SecurityTokenCollection,System.String)">
            <summary>
               <para>Obtains the identity string from the security token. The 
                  supporting token collection is used to specify the additional tokens used for
                  checking the token trust chain.</para>
            </summary>
            <param name=' token'>The securityToken from which the identity string is obtained </param>
            <param name=' supportingTokens '>Additional tokens used during the trust check</param>
            <param name='resource'>The resource identifier string used to compose the user identity from the security token.</param>
            <remarks>
               <para>The system implements the following derived classes for 
                  identityProviders:</para>
               <list type='bullet'><item>
                  <term>UsernameIdentityProvider</term>
               </item>
               <item>
                  <term>WindowsIdentityProvider</term>
               </item>
               <item>
                  <term>X509IdentityProvider</term>
               </item>
            </list>
            <para>The UsernameIdentityProvider returns the username for GetIdentity. The 
               WindowsIdentityProvider returns the principal from the kerberos service token
               for GetIdentity call. X509IdentityProvider validates the cert chain and returns
               the resources specified (ex: cn, ou, etc.) as the identity. </para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Security.IdentityProvider.InputType">
            <summary>
               <para>Returns the token type that this 
                  IdentityProvider uses.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.IdentityProviderCollection">
            <summary>
               <para>This stores the list of providers as a hash table, keyed by the type of
                  token the provider understands. This is enumerable, and supports the Add,
                  Remove and Get operations</para>
            </summary>
            <remarks>
               <para>This class is a collection used to hold IdentityProviders (typically at the 
                  reciever). </para>
               <para>Use identity providers when expressing a symmetric encryption requirement at 
                  the message recipient, to indicate security tokens to be used by sender for
                  encrypting messages. Use identity providers when expressing a sigature
                  requirement at the message recipient by specifying the identity providers to be
                  used by sender for signing messages. Use identity providers when authenticating
                  a message sender. </para>
               <para>IdentityProviders for Windows (Kerberos), username/password and X.509 v3 are 
                  provided by the message bus in M3.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Security.IdentityProviderCollection.Add(System.String,System.MessageBus.Security.IdentityProvider)">
            <summary>
               <para>Adds the specified IdentityProvider to the 
                  IdentityProviderCollection under the specified friendly name.</para>
            </summary>
            <param name=" name">Friendly name referencing the identityprovider in subsequent calls.</param>
            <param name="identityProvider">The identityProvider to add to the IdentityProviderCollection.</param>
            <returns>
               <para>The zero based positional index in the list where the 
                  IdentityProvider is added.</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">IdentityProvider param is null or the IdentityProvider's name is null</exception>
            <exception cref="!:ExistingIdentityProvider">IdentityProvider of the specified type already exists in the IdentityProviderCollection.</exception>
            <remarks>
               <para>The system implements the following IdentityProvider 
                  types:</para>
               <list type="bullet"><item>
                  <term>
                     UsernameIdentityProvider (for username password
                     identities)</term>
               </item>
               <item>
                  <term>
                     WindowsIdentityProvider (for Kerberos identities)</term>
               </item>
               <item>
                  <term>
                     X509IdentityProvider</term>
               </item>
            </list>
            <para>The name parameter is used in the identityMappings as a shortcut for 
               identifying the identities. </para>
            <para>For example: </para>
            <para>myIdCollection.Add("winAuth", new 
               WindowsIdentityProvider());myIdentityMappings.Add("winAuth:someuser", "",
               "winuser");</para>
            <para>Note that the "winAuth" name is used to identify security token type required 
               and the identity is based off the token type. </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Security.IdentityProviderCollection.Contains(System.MessageBus.Security.IdentityProvider)">
            <summary>
               <para>Determines whether the specified identityProvider is 
                  available in the IdentityProviderCollection.</para>
            </summary>
            <param name="identityProvider">identityProvider that is searched for</param>
            <exception cref="T:System.ArgumentNullException">identityProvider parameter is null.</exception>
        </member>
        <member name="M:System.MessageBus.Security.IdentityProviderCollection.Contains(System.String)">
            <summary>
               <para>Determines whether the identity provider of the 
                  specified name is already present in the identityProviderCollection.</para>
            </summary>
            <param name='name'>Name of the identity provider in the identityProviderCollection.</param>
        </member>
        <member name="M:System.MessageBus.Security.IdentityProviderCollection.CopyTo(System.MessageBus.Security.IdentityProvider[],System.Int32)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.IdentityProviderCollection.IndexOf(System.MessageBus.Security.IdentityProvider)">
            <summary>
               <para>Determines the location of the specified 
                  identityProvider in the identityProviderCollection.</para>
            </summary>
            <param name="identityProvider">the identityProvider to get index for in the identityProviderCollection </param>
            <returns>
               <para>Zero based positional index of the identity provider. 
                  returns -1 if the identityProvider is not in the collection.</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">identityProvider param is null</exception>
        </member>
        <member name="M:System.MessageBus.Security.IdentityProviderCollection.IndexOf(System.String)">
            <summary>
               <para>Determines the location of the named 
                  identityProvider in the identityProviderCollection.</para>
            </summary>
            <param name="name">the name of the identity provider to search for.</param>
            <returns>
               <para>Zero based positional index of the where the specified name is found. -1 
                  otherwise. </para>
            </returns>
            <exception cref="T:System.ArgumentNullException">name param is null</exception>
        </member>
        <member name="M:System.MessageBus.Security.IdentityProviderCollection.Insert(System.Int32,System.MessageBus.Security.IdentityProvider)">
            <summary>
               <para>Inserts the specified (name, identityProvider) tuple 
                  into the identityProviderCollection at the specified location.</para>
            </summary>
            <param name=' index'>The location in the identityProviderCollection where the identity provider is to be inserted</param>
            <param name='identityProvider'>The identityProvider to insert into the identityProviderCollection list.</param>
            <remarks>
               <para>If the index is equal to the length of the 
                  identityProviderCollection list, then the element is appended to the end of the
                  list. If any other valid index, all subsequent elements of the list after the
                  index are moved down to accomodate this element.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Security.IdentityProviderCollection.Remove(System.MessageBus.Security.IdentityProvider)">
            <summary>
               <para>Removes the specified identityProvider from the collection.</para>
            </summary>
            <param name="identityProvider">identityProvider to remove from the collection.</param>
            <exception cref="T:System.ArgumentNullException">identityProvider parameter is null</exception>
        </member>
        <member name="P:System.MessageBus.Security.IdentityProviderCollection.Item(System.Int32)">
            <summary>
               <para>Returns the identityProvider at the specified location.</para>
            </summary>
            <param name='index'>zero based index into the list of identity providers </param>
            <value>
               <para>IdentityProvider returned from the IdenityProviderCollection at the specified 
                  index</para>
            </value>
        </member>
        <member name="P:System.MessageBus.Security.IdentityProviderCollection.Item(System.String)">
            <summary>
               <para>Returns the identity provider with the specified name 
                  from the IdentityProvidersCollection.</para>
            </summary>
            <param name='name'>Name of the identity provider to search for.</param>
            <value>
               <para>Returns the IdentityProvider whose name matches the name param. Null if no 
                  match found. </para>
            </value>
        </member>
        <member name="T:System.MessageBus.Security.SimpleIdentityMapping">
            <summary>
               <para> This class is used to store the mapping details for the given id mapping. It stores
                  the identityProvider, identity, resource to role mapping.</para>
            </summary>
            <remarks>
               <para>This class stores the role mapping details for the given id. The 
                  SimpleIdentityMapping contains the tuples (identityProvider, resource, identity,
                  role). The identityProvider string refers to the name of the identityProvider as
                  it is added to the identityProviders collection. The resource string refers to
                  the resource relative to the base resource that is being protected. The identity
                  string is the specific identity that is being granted the specified role. </para>
               <para>In order to provide authenticated roles, create a SimpleIdentityMapping for 
                  each role, add these SimpleIdentityMappings to the <see cref="T:System.MessageBus.Security.SimpleIdentityMapProvider"/> and add the
                  SimpleIdentityMapProvider to the securityReceiver's <see cref="T:System.MessageBus.Security.IdentityMapProviderCollection"/>
                  . When the system receives a message, the identities
                  extracted from the security tokens associated with the message using appropriate
               <see cref="T:System.MessageBus.Security.IdentityProvider"/> s, and the resource 
                  that the message is trying to access are used by the
                  IdentityMapProviderCollection (and if SimpleIdentityMapProvider is added, by the
                  entries in the SimpleIdenityMapProvider) to map the message identities to a
                  specific set of roles. </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Security.SimpleIdentityMapping.#ctor(System.String,System.String,System.String)">
            <summary>
               <para>Constructor for the SimpleIdentityMapping class takes an 
                  authenticated identity of the form IdentityProvider:Idenity, a resource string
                  relative to the base resource that this message is targeted at, and the role
                  mapped to this identity.</para>
            </summary>
            <param name=" identity">The identity for the mapping as IdentityProviderName:Identity</param>
            <param name=" Resource">Resource string relative to the base resource</param>
            <param name="Role">The role assigned to the identity for the resource</param>
            <exception cref="!:NotNullEmptyParameter">Identity parameter is null or role parameter is null or of zero length</exception>
            <exception cref="T:System.ArgumentNullException">resource parameter is null</exception>
            <exception cref="!:SimpleIdentityMappingSyntax">The identity parameter should be of the form IdentityProvider:Identity. This exception is thrown when the format is incorrect or when the IdentityProvider or the Identity portions if the identity parameter are empty.</exception>
            <remarks>
               <para>Identity parameter should be of the format 
                  IdentityProvider:Identity where IdentityProvider refers to the name of an
                  identityProvider in the system's identity provider collection and the identity
                  parameter refers to an identity obtained using the identity provider. For
                  example, "winauth" might be programmed to refer to the WindowsIdentityProvider
                  and "SomeUser" might be the principal name obtained from the
                  WindowsIdentityProvider for a given message. The tag "winauth:SomeUser" hence
                  refers to a specific principal.</para>
               <para>resource parameter is resource relative to the base 
                  resource that the message is trying to access. This is commonly used for cases
                  where the web service methods act on different resources than the base resource.
                  For example, soap://www.example.com might be the base resource and
                  SomeUserMailBox might be the resource being accessed. The actual web resource
                  that this message is bound to is hence
                  soap://www.example.com/SomeUserMailBox/</para>
               <para>For the example above, the Role might be the string 
                  "Owner". The specific rights that this role has are dictated by AccessMappings.</para>
            </remarks>
            <example>
               <code lang="C#">// create a simple identity  map provider
                        SimpleIdentityMapProvider sim = new SimpleIdentityMapProvider();
            // create a new simpleidentitymapping.Requests bound for this resource with the specified user identity are given owner role.
                        SimpleIdentityMapping sidMap = new SimpleIdentityMapping("WinAuth:SomeUser", "SomeUserMailBox", "Owner");
                        sim.Mappings.Add(sidMap);
            // add this identity map provider to the identity map provider collection in the receiver.            
                        receiver.IdentityMapProviders.Add(sim);
               </code>
            </example>
        </member>
        <member name="P:System.MessageBus.Security.SimpleIdentityMapping.Resource">
            <summary>
               <para>Returns the resource property that the 
                  SimpleIdentityMapping has been configured with.</para>
            </summary>
            <value>
               <para>The relative resource that this SimpleIdentityMapping instance contains. </para>
            </value>
        </member>
        <member name="P:System.MessageBus.Security.SimpleIdentityMapping.Identity">
            <summary>
               <para>Returns the identity of the SimpleIdentityMapping object.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.SimpleIdentityMapping.Role">
            <summary>
               <para>Returns the Role that this instance of 
                  SimpleIdentityMapping contains.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.SimpleIdentityMapProvider">
            <summary>
               <para>This class stores SimpleIdentityMappings and retrieves 
                  the roles corresponding to the identity specified.</para>
            </summary>
            <remarks>
            <para>The SecurityReceiver on the SecurityManager has an <see cref="T:System.MessageBus.Security.IdentityMapProviderCollection"/>. Create a new 
               SimpleIdenityMapProvider, populate this SimpleIdentityMapProvider with
               SimpleIdentityMappings, and add the SimpleIdentityMapProvider to the
               SecurityReceiver's IdentityMapProviderCollection. This process is used to enable
               identity mapping to roles. </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Security.SimpleIdentityMapProvider.#ctor">
            <summary>
               <para>Creator for the SimpleIdentityMapProvider.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.SimpleIdentityMapProvider.OnBeginGetRoles(System.String,System.String,System.String,System.AsyncCallback,System.Object)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.SimpleIdentityMapProvider.OnEndGetRoles(System.MessageBus.Security.IRolesAsyncResult)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.SimpleIdentityMapProvider.MatchIdentityCase">
            <summary>
               <para>Property dictating that the identity is case sensitive.</para>
            </summary>
            <value>
               <para>Set property to true to indicate that the identity is case sensitive, false otherwise. 
                  Default value is false.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.Security.SimpleIdentityMapProvider.MatchResourceCase">
            <summary>
               <para>Is the resource name case sensitive.</para>
            </summary>
            <value>
               <para>Set to true to be case sensitive. False otherwise. Default false. </para>
            </value>
        </member>
        <member name="P:System.MessageBus.Security.SimpleIdentityMapProvider.Mappings">
            <summary>
               <para>Getter for returning the collection object from the 
                  SimpleIdentityMapProvider.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.SimplePasswordResolver">
            <summary>
            THis is a simple password resolver.  It wraps a dictionary to be used for password lookup.
            IT's config allows it to be supplied with a list of username/password pairs.
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.SimplePasswordResolver.#ctor(System.Collections.IDictionary)">
            <summary>
            THis is a simple password resolver.  It wraps a dictionary to be used for password lookup.
            </summary>
            <param name="passwordDictionary">
            If the passwordDictionary is null, a hashtable will be conjured up for use when the property is accessed.
            </param>
        </member>
        <member name="T:System.MessageBus.Security.UsernameIdentityProvider">
            <summary>
               <para>IdentityProviders support methods for obtaining identities from supplied 
                  tokens. The UsernameIdentityProvider returns the identity as the username
                  from the usernameToken provided. </para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.UsernameIdentityProvider.#ctor(System.MessageBus.Security.IPasswordResolver)">
            <summary>
            The config for this object allows the resolver to be passed in by instantiating a class by name that implements the interface.
            This includes the built-in SimplePasswordResolver or your own resolver.
            </summary>
            <param name="resolver"></param>
        </member>
        <member name="M:System.MessageBus.Security.UsernameIdentityProvider.OnGetIdentity(System.MessageBus.Security.ISecurityToken,System.MessageBus.Security.SecurityTokenCollection,System.String)">
            <summary>
               <para>Returns the identity from the token. The identity 
                  returned is the username found in the token.</para>
            </summary>
            <param name=' token'>Username security token to obtain the identity information from.</param>
            <param name=' supportingTokens'>Not used</param>
            <param name='resource'>Not used</param>
            <returns>
               <para>String representing the usename from the security token 
                  if the token is a username token. Null otherwise.</para>
            </returns>
        </member>
        <member name="P:System.MessageBus.Security.UsernameIdentityProvider.InputType">
            <summary>
               <para>Returns the type as UsernameToken.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.UsernameToken">
            <summary>
               <para>This class represents the usernameToken specified in WS-Security.</para>
            </summary>
            <remarks>
               <para>This class provides the encoding support for username/password credentials. 
                  This class implements WS-Security compliant usernameToken. It represent's the
                  developer view of the username/password token on the wire. </para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.Security.ISecurityToken">
            <summary>
            ISecurityToken represents the view that developers have of security tokens in messages
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.UsernameToken.Password">
            <summary>
               <para>Property returns the password associated with this token.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.UsernameToken.Username">
            <summary>
               <para>Property returns the username associated with this token.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.UsernameTokenProvider">
            <summary>
            The UsernameTokenProvider generates username tokens as specified in WS-Security.
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.TokenProvider">
            <summary>
               <para> TokenProvider provides the abstract base class that token providers implement.</para>
            </summary>
            <remarks>
               <para>TokenProvider objects generate security tokens for use while sending secure 
                  messages.</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.Security.WindowsIdentityProvider">
            <summary>
               <para>Class encapsulating the Windows Kerberos support.</para>
            </summary>
            <remarks>
               <para>An identity provider has support for obtaining principal 
                  and identity information based on the token supplied.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Security.WindowsIdentityProvider.OnGetIdentity(System.MessageBus.Security.ISecurityToken,System.MessageBus.Security.SecurityTokenCollection,System.String)">
            <summary>
               <para>Returns the principal from the token supplied</para>
            </summary>
            <param name=' token'>The WindowsToken used for obtaining the identity</param>
            <param name=' supportingToken'>Not used</param>
            <param name='resource'>Not used</param>
            <returns>
               <para>returns the principal from the token supplied if it is a 
                  windows token. If not, it returns null.</para>
            </returns>
            <remarks>
               <para>This method provides the primary functionality of the 
                  WindowsIdentityProvider: to obtain the identity from the specified token after
                  performing the trust check. For the WindowsIdentityProvider (kerberos ticket),
                  trust check is implicit. </para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Security.WindowsIdentityProvider.InputType">
            <summary>
               <para>Returns the InputType as a WindowsToken.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.WindowsIdentityProvider.ServiceDomain">
            <summary>
               <para>The service domain name in the token supplied.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.WindowsIdentityProvider.ServicePrincipal">
            <summary>
               <para>Returns the ServicePrincipal name. </para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.WindowsToken">
            <summary>
               <para> 
                  This class provides the support for encoding the WindowsToken.</para>
            </summary>
            <remarks>
               <para> WS-Security specification provides information on how to 
                  encode and bind the security token to the message. It defines the encoding for
                  BinarySecurityTokens of which a kerberos ticket is a type.
                  The WindowsToken representing the message bus implementation of
                  the Kerberos ticket is derived from BinarySecurityToken. This class represents the developer
                  view of the windows security token in the message. </para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.Security.BinarySecurityToken">
            <summary>
               <para> This class serves as a base
                  for binary security tokens.</para>
            </summary>
            <remarks>
               <para>WS-Security defines two encoding types for binarySecurityTokens:</para>
               <list type='bullet'><item>
                  <term>Base64</term>
               </item>
               <item>
                  <term>Hex</term>
               </item>
            </list>
            <para>This enum encapsulates the two types. </para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.Security.BinarySecurityToken.EncodingType">
            <summary>
            Represents a binary security token encoding type.
            </summary>
        </member>
        <member name="F:System.MessageBus.Security.BinarySecurityToken.EncodingType.Base64Binary">
            <summary>
            wsse:Base64Binary
            </summary>
        </member>
        <member name="F:System.MessageBus.Security.BinarySecurityToken.EncodingType.HexBinary">
            <summary>
            wsse:HexBinary
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.WindowsToken.Domain">
            <summary>
               <para>Returns the domain name for the WindowsToken.</para>
            </summary>
            <value>
               <para>Gets the domain name from the Windows Token.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.Security.WindowsToken.Principal">
            <summary>
               <para>Returns the principal name from the WindowsToken.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.WindowsToken.ExpirationDate">
            <summary>
               <para>Returns the ExpirationDate of the WindowsToken.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.WindowsToken.HasExpired">
            <summary>
               <para>Returns whether the Token has expired or not.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.WindowsTokenProvider">
            <summary>
               <para>This class generates Windows tokens as specified in WS-Security.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.WindowsTokenProvider.#ctor">
            <summary>
               <para>Creates an empty KerberosToken.</para>
            </summary>
            <example>
               <code lang='C#'>// an example using configuration
            
            MessageBusConfiguration config = MessageBusConfiguration.GetFromConfig();
            
            // Load our port from config.
            
            this.port = (Port) config[typeof(Port)];
            
            // Allow all messages to be received at this port.
            
            this.securityManager = (SecurityManager) config[typeof(SecurityManager)];
            
            SecuritySender mySender = this.securityManager.sender;
            
            // create a new WindowsTokenProvider and add it to the TokenProvider collection
            
            this.securityManager.sender.TokenProviders.Add(new WindowsTokenProvider());
                  </code>
            </example>
        </member>
        <member name="P:System.MessageBus.Security.WindowsTokenProvider.Domain">
            <summary>
               <para>Returns the domain name from the Kerberos token.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.WindowsTokenProvider.Principal">
            <summary>
               <para>Returns the principal name from the kerberos token.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.X509Certificate.FromBase64String(System.String)">
            <summary>
            Creates a new Certificate from raw X509 data in string form.
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.X509Certificate.ToBase64String">
            <summary>
            Converts the CertificateContexts raw data into a base64 encoded string.
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.X509Certificate.EffectivityDate">
            <summary>
            Gets the date before which this certificate is not valid.
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.X509Certificate.ExpirationDate">
            <summary>
            Gets the date after which this certificate is not valid.
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.X509Certificate.IsCurrent">
            <summary>
            Tests whether the certificate is current.
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.X509Certificate.PrivateKeyAvailable">
            <summary>
            Determines whether the private key for this certificate is available.
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.X509Certificate.PublicKey">
            <summary>
            Returns the public key derived from the certificates data. This key cannot be used
            to either sign or decrypt data.
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.X509Certificate.SubjectDnsName">
            <summary>
            Gets the DNS name, if any, owned by the subject.
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.X509Certificate.SubjectEmail">
            <summary>
            Gets the e-mail address, if any, owned by the subject.
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.X509Certificate.SubjectUrl">
            <summary>
            Gets the URL, if any, owned by this subject.
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.X509Certificate.Thumbprint">
            <summary>
            Returns the Thumbprint for the certificate - the certificates (SHA-1) hash value
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.X509Certificate.UserPrincipalName">
            <summary>
            Gets the principal name, if any, of this subject.
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.X509CertificateStore">
            <summary>
            Provides primitive access to LocalMachine and CurrentUser certificate stores.
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.X509CertificateStore.LocalMachineStore(System.String)">
            <summary>
            Returns a LocalMachine certificate store
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.X509CertificateStore.CurrentUserStore(System.String)">
            <summary>
            Returns a CurrentUser certificate store
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.X509CertificateStore.FindCertificateByHash(System.Byte[])">
            <summary>
            Finds a certificate in the store using the certificates (SHA-1) hash value.
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.X509CertificateStore.FindCertificateBySubjectString(System.String)">
            <summary>
            Finds a certificate in the store using the certificates name value. This
            search uses the semantics of the CERT_FIND_SUBJECT_STR search (i.e. substring
            matching).
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.X509CertificateStore.Open">
            <summary>
            Opens the certificate store.
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.X509CertificateStore.OpenRead">
            <summary>
            Opens the store for read-only access.
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.X509CertificateStore.Certificates">
            <summary>
            Returns a collection of the certificates in the store.
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.X509CertificateStore.StoreLocation">
            <summary>
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.X509CertificateStore.StoreProvider">
            <summary>
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.X509CertificateStore.StoreOpenFlags">
            <summary>
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.X509IdentityProvider">
            <summary>
            X509IdentityProvider recognizes x509 tokens and extracts identity information from them. It is constructed
            to return the identity value in the order of the attributes specified in the constructor
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.X509IdentityProvider.#ctor">
            <summary>
            The provider should be specified a comma separated list of identity attributes it wants the sequence in.
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.X509TokenProvider">
            <summary>
            This class generates X509 tokens as specified in WS-Security.
            For M3, it takes an instanced X509 Certificate as it's basis.
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.X509TokenProvider.#ctor(System.MessageBus.Security.X509Certificate)">
            <summary>
            Creates an empty KerberosToken
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.XrmlLicenseToken">
            <summary>
            This class represents a highly constrained XrML 2.0 license.  See the XrML 2.0 spec for details.
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.XrmlLicenseTokenProvider">
            <summary>
            The XrmlLicenseTokenProvider generates XrmlLicenseTokens for sending on messages.
            For M3, this provider just returns this individual token.
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.TokenProviderCollection">
            <summary>
               <para> 
                  Contains a list of
                  security token providers. Individual elements of the collection can be accessed by
                  their index location.</para>
            </summary>
            <remarks>
               <para> TokenProviders (ex: usermane/password, Windows 
                  - kerberos, X.509) are used to obtain security tokens. The security tokens
                  are used by the system in formulating a secure message complying with the
                  policies of the message recipient. Derived from <see cref="!:System.Collection]"/>.CollectionBase'/&gt;</para>
               <para>Use the TokenProvicersCollection to add (multiple) token providers. The 
                  system examines the TokenProviders collection on the sender object in the
                  security manager when formulating a secure message. If it finds a token provider
                  that matches the required token type(s) as dictated by the message recipient
                  policy, it uses the token provider to derive the appropriate token, and
                  formulate a secure message (encrypt, sign, attach tokens).</para>
            </remarks>
            <example>
               <code lang="C#">// Security manager has been created
            // Following code adds a Windows token provider to the token provider collection.
            secMan.Sender.TokenProviders.Add(new WindowsTokenProvider());
            // following code adds a username token provider to the token provider collection
            secMan.Sender.TokenProviders.Add(new UsernameTokenProvider("username", "userpwd"));
               </code>
            </example>
        </member>
        <member name="M:System.MessageBus.Security.TokenProviderCollection.Add(System.MessageBus.Security.TokenProvider)">
            <summary>
               <para>Adds a specified token provider at the end of the 
                  TokenProvider list.</para>
            </summary>
            <param name="TokenProvider">The token provider to add</param>
            <returns>
               <para>The positional index where the token provider is added. </para>
            </returns>
            <exception cref="T:System.ArgumentNullException">The tokenProvider condition is null</exception>
            <remarks>
               <para>The system currently implements token providers for the following token 
                  types:</para>
               <list type="bullet"><item>
                  <term>
                     Username/password token provider
                     (UsernameTokenProvider)</term>
               </item>
               <item>
                  <term>
                     Windows token provider (for Kerberos support) -
                     (WindowsTokenProvider)</term>
               </item>
               <item>
                  <term>
                     X.509 token provider (X509TokenProvider)</term>
               </item>
               <item>
                  <term>
                     XrML license token provider (XrMLLicenseTokenProvider)</term>
               </item>
            </list>
            </remarks>
            <example>
               <code lang="C#">// Security manager has been created
            // Following code adds a Windows token provider to the token provider collection.
            secMan.Sender.TokenProviders.Add(new WindowsTokenProvider());
            // following code adds a username token provider to the token provider collection
            secMan.Sender.TokenProviders.Add(new UsernameTokenProvider("username", "userpwd"));
               </code>
            </example>
        </member>
        <member name="M:System.MessageBus.Security.TokenProviderCollection.Contains(System.MessageBus.Security.TokenProvider)">
            <summary>
               <para>Determines whether the tokenProviderCollection contains 
                  the specific tokenProvider</para>
            </summary>
            <param name="tokenProvider">tokenProvider to check existence for in the tokenProviderCollection</param>
            <returns>
               <para>true if the tokenProvider is present in the collection. false otherwise.</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">tokenProvider parameter is null</exception>
        </member>
        <member name="M:System.MessageBus.Security.TokenProviderCollection.CopyTo(System.MessageBus.Security.TokenProvider[],System.Int32)">
            <summary>
               <para>Copies the entire tokenProviders list to an array of 
                  tokenProviders starting at the specified index.</para>
            </summary>
            <param name=' array'>An array of tokenProvider entries to which the tokenProviders from the tokenProviderCollection will be copied</param>
            <param name='index'>The index in the array at which to begin copying the tokenProviders</param>
        </member>
        <member name="M:System.MessageBus.Security.TokenProviderCollection.IndexOf(System.MessageBus.Security.TokenProvider)">
            <summary>
               <para>Determines the specific index of the tokenProvider in 
                  the TokenProviderCollection</para>
            </summary>
            <param name="tokenProvider">The token provider whose location in the collection is to be determined</param>
            <returns>
               <para>Index (zero based) where the token provider is found in the collection. 
                  Otherwise returns -1.</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">tokenProvider element is null</exception>
        </member>
        <member name="M:System.MessageBus.Security.TokenProviderCollection.Insert(System.Int32,System.MessageBus.Security.TokenProvider)">
            <summary>
               <para>The token provider is inserted at the specified index.</para>
            </summary>
            <param name=" index">The zero based index at which the tokenProvider should be inserted.</param>
            <param name="tokenProvider">The token provider to insert into the token provider collection.</param>
            <returns>
               <para>Nothing</para>
            </returns>
            <exception cref="!:ArgumentOutOrRangeException">The index parameter is not a valid index in the tokenProvidersCollection</exception>
            <exception cref="T:System.ArgumentNullException">The tokenProvider parameter is null</exception>
            <remarks>
               <para>If the index parameter is equal to the size of the tokenProvidersCollection, 
                  then the tokenProvider object is appended to the collection. Otherwise, when a
                  valid index (&gt;0 and &lt; size of tokenProviderCollection) is used, the
                  entries after the insertion point are moved down to accomodate the new
                  tokenProvider element in the list. </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Security.TokenProviderCollection.Remove(System.MessageBus.Security.TokenProvider)">
            <summary>
               <para>Removes the specified tokenProvider from the 
                  TokenProvider collection.</para>
            </summary>
            <param name="tokenProvider">The tokenProvider to remove from the collection</param>
            <returns>
               <para>Nothing</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">The tokenProvider parameter is null</exception>
        </member>
        <member name="P:System.MessageBus.Security.TokenProviderCollection.Item(System.Int32)">
            <summary>
               <para>Returns the tokenProvider at the specified index.</para>
            </summary>
            <param name='index'>zero based index into the list of token providers used to retrieve the token provider</param>
            <value>
               <para>tokenProvider returned from the tokenProviderCollection at the specified 
                  index</para>
            </value>
        </member>
        <member name="T:System.MessageBus.Security.AsymmetricEncryptionRequirement">
            <summary>
               <para>Summary description for AsymmetricEncryptionRequirement.</para>
            </summary>
            <remarks>
               <para>When an AsymmetricEncryptionRequirement is specified, a 
                  policy is generated at the message recipient, the public
                  portion of the asymmetric key is sent to the message sender and is used
                  by the sender to encrypt all messages for the given action. The encryption requirement is
                  enforced at the message recipient. </para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.Security.EncryptionRequirement">
            <summary>
               <para>Provides the abstract base class for encryption requirements.</para>
            </summary>
            <example>
            <para>The system implements two derived classes of this type: <see cref="T:System.MessageBus.Security.AsymmetricEncryptionRequirement"/> and <see cref="T:System.MessageBus.Security.SymmetricEncryptionRequirement"/>. </para>
            </example>
        </member>
        <member name="M:System.MessageBus.Security.AsymmetricEncryptionRequirement.#ctor">
            <summary>
            This indicates that all messages for the given action should be encrypted using
            a newly generated Encryption key.
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.AsymmetricEncryptionRequirement.#ctor(System.MessageBus.Security.ISecurityToken)">
            <summary>
               <para>This indicates that all messages for the given action 
                  should be encrypted using the encryptionToken.</para>
            </summary>
            <param name='encryptionToken'>The encryptionToken to use. This must be a public key token.</param>
            <remarks>
               <para>This indicates that all messages for the given action 
                  should be encrypted using the encryptionToken. Policy will be generated indicating this, with the public portion of the asymmetric key
                  contained in the encryptionToken attached to the Policy, and the SecurityManager
                  will decrypt messages encrypted for this action.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Security.AsymmetricEncryptionRequirement.GenerateEncryptionKey">
            <summary>
               <para>When this flag is set, a new asymmetric EncryptionToken 
                  is generated. If EncryptionToken is set, this property must be false and will throw upon making it true.</para>
            </summary>
            <exception cref="!:EncryptionTokenExists">Encyption token is already set and a different encyption token cannot be generated</exception>
        </member>
        <member name="P:System.MessageBus.Security.AsymmetricEncryptionRequirement.EncryptionToken">
            <summary>
               <para>If EncryptionToken is set to a valid encryption token,
                  the GenerateEncryptionKey will be coerced to false.</para>
            </summary>
            <exception cref="!:unsupportedTokenType">The specified token cannot be used for specifying asymmetric encryption requirement </exception>
            <exception cref="!:X509TokenPrivKenUnavailable">The private portion of the X509 token is unavailable.</exception>
        </member>
        <member name="P:System.MessageBus.Security.SecurityLicensing.Enabled">
            <summary>
            Gets or sets whether automatic token issuance is enabled.  The default is false.
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.SecurityLicensing.KeyType">
            <summary>
            Gets or sets the type of key to generate for issued tokens.  The default is public-key.
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.SecurityLicensing.ValidityPeriod">
            <summary>
            Gets or sets the length of time for which issued tokens should be valid.  The default is 8 hours.
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.SecurityManager">
            <summary>
               <para>This class provides the main access point to message bus 
                  security system. This class cannot be inherited.</para>
            </summary>
            <remarks>
               <para>Message bus provides methods for message security including message 
                  encryption, message signature, message authentication, request authorization and
                  security policy management. The SecurityManager class provides the main access
                  point to the SecuritySender and SecurityReceiver classes for exposing send-side
                  and receiver-side security functionalities. </para>
               <para>SecurityManager functionality is bound to a port. Once a 
                  port is opened, the security manager is immutable. </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Security.SecurityManager.#ctor(System.MessageBus.Port)">
            <summary>
               <para>Constructor. Takes the port and hooks up the security 
                  manager to the specified port. SecurityManager is bound to the specified port. On the receiver the port URI specifies the
                  base resource that needs to be secured by default. That means all
                  messages sent to this port are secured as per the policies (encryption requirements, signature
                  requirements, authentication requirements and resources for access control) set up for the security manager. The
                  resource property can be used to specify a different base resource than the default
                  available through the port property.</para>
            </summary>
            <param name='port'>Port property.</param>
            <example>
               <para>This example creates a security manager for the specified port resource.</para>
               <code lang='C#'>// first create port
                         Port myport = new Port(new Uri("soap.tcp://example.com:808/hellosvc"));
                       // next specify port as param to security manager... the security policies and instance data are then set up for the sender or receiver
                          SecurityManager secMan= new SecurityManager(myport);
               </code>
            </example>
        </member>
        <member name="M:System.MessageBus.Security.SecurityManager.ResetResource">
            <summary>
               <para>Resets the Resource property to reflect the current
                  Port's Uri property.</para>
            </summary>
            <param name='None'></param>
            <remarks>
               <para>The Resource property is used to set the base resource upon which the 
                  security manager acts. When the resource property is set, the default base
                  resource from the Port is lost. ResetResource can be called to reset the base
                  resource back to the current port's Uri.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Security.SecurityManager.Port">
            <summary>
               <para>The Port property associated with the SecurityManager.</para>
            </summary>
            <exception cref="P:System.MessageBus.Security.SecurityManager.PortOpen">Exception is thrown if the security manager port is already opened and we try to set port.</exception>
            <remarks>
               <para>The port property is used to specify which port to attach security manager 
                  to. </para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Security.SecurityManager.Receiver">
            <summary>
               <para>Public object representing the security processing on 
                  the receiver side of the message. Included are the encryption requirement, the
                  signature requirements, the identity providers to use for making authentication
                  decisions, the authorization (access) mappings, and licensing objects.</para>
            </summary>
            <example>
               <para>This example refers to the security receiver.</para>
               <code lang='C#'>// first create port
                         Port myport = new Port(new Uri("soap.tcp://example.com:808/hellosvc"));
                       // next specify port as param to security manager... 
                          SecurityManager secMan= new SecurityManager(myport);
                       // next access the securityreceiver
                       secMan.Receiver.encryptionRequirement = null;
               </code>
            </example>
        </member>
        <member name="P:System.MessageBus.Security.SecurityManager.Resource">
            <summary>
               <para>The Resource property indicates which Security header to process, namely the SOAP header who's
                  actor/role equals the Resource property value.
                  By default, the Resource property inherits the Port's Uri property, unless specifically set
                  to a value. Once the property has been set, the inheritance is disconnected, and to
                  recover the inheritance behavior, call ResetResource().
                  Setting this property while the associated Port is open will cause an exception to be thrown.</para>
            </summary>
            <exception cref="P:System.MessageBus.Security.SecurityManager.PortOpen">Exception is thrown if the security manager port is already opened and we try to set resource and open port.</exception>
        </member>
        <member name="P:System.MessageBus.Security.SecurityManager.Sender">
            <summary>
               <para> 
                  Security sender contains a token
                  collection object. The Sender holds a reference to the SecuritySender object on the securityManager.</para>
            </summary>
            <remarks>
               <para>"Sender" applications add security tokens to this collection. Based on the 
                  security polic(ies) of the actor(s) that a message is meant for, the message bus
                  security system extracts the appropriate tokens from the token collection,
                  performs required security operations on the message and binds the selected
                  tokens to the message. </para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.Security.SecurityReceiver">
            <summary>
               <para>This class represents the SecurityReceiver object. The 
                  SecurityReceiver object on the SecurityManager provides the main access point
                  for all receiver side security functionality. This class cannot be inherited from.</para>
            </summary>
            <remarks>
               <para>The SecurityReceiver object provides the main access point for receiver side 
                  security functionality. </para>
               <para>The SecurityReceiver provided functionality for the receiver to express its 
                  security policies in the form of encryption, signature, authentication protocol
                  requirements as well as authorization and interacts with the message bus
                  security system on the receiver to express and enforce the those requirements. </para>
               <para>The typical usage pattern is for the receiver to express its encryption 
                  requirement, signature requirement, identity providers to use (username, x509,
                  windows, etc...) for message authentication, identity map providers for mapping
                  identities to roles for specific resources, and access mappings for mapping
                  specific roles required for particular method access. </para>
               <para> The processing mechanism is approximately as 
                  follows:</para>
               <list type='number'><item>
                  <term>
                     The message is decrypted</term>
               </item>
               <item>
                  <term>
                     The message integrity is verified.</term>
               </item>
               <item>
                  <term>
                     The security token attached to the message is used by
                     the identity provider to check for identity trust</term>
               </item>
               <item>
                  <term>Identity is obtained from the security token.</term>
               </item>
               <item>
                  <term>Identity obtained from previous step, resource being accessed are used by 
                     the IdentityMapProviders to map request to a specific role.</term>
               </item>
               <item>
                  <term>The role granted and the method being accessed are verified against the 
                     AccessMappings to determine if the request is granted access.</term>
               </item>
            </list>
            </remarks>
            <example>
               <code lang='C#'>// an example using configuration
            
            MessageBusConfiguration config = MessageBusConfiguration.GetFromConfig();
            
            // Load our port from config.
            
            this.port = (Port) config[typeof(Port)];
            
            // Allow all messages to be received at this port.
            
            this.securityManager = (SecurityManager) config[typeof(SecurityManager)];
            
            SecurityReceiver myReceiver = this.securityManager.receiver;
               </code>
            </example>
        </member>
        <member name="P:System.MessageBus.Security.SecurityReceiver.IdentityProviders">
            <summary>
               <para>Collection of identity providers.</para>
            </summary>
            <remarks>
               <para>Identity providers extract identities from tokens and perform trust check on 
                  class of tokens they understand. </para>
               <para>Identity providers are used in multiple situations: </para>
               <para>Use identity providers when expressing a symmetric encryption requirement at 
                  the message recipient, to indicate security tokens to be used by sender for
                  encrypting messages. Use identity providers when expressing a sigature
                  requirement at the message recipient, by specifying the identity providers to be
                  used by sender for signing messages. Use identity providers when authenticating
                  a message sender. </para>
               <para> 
                  IdentityProviders for
                  Windows (Kerberos), username/password and X.509 v3 are provided by the message
                  bus in M3. </para>
            </remarks>
            <example>
               <code lang='C#'>// SecurityManager is created
                Hashtable up = new Hashtable();
                up["userName1"] = "userPwd1";
            // add the username password identityprovider
                securityManager.Receiver.IdentityProviders.Add("username", new UsernameIdentityProvider(new SimplePasswordResolver(up)));
            // add the windows identity provider
                securityManager.Receiver.IdentityProviders.Add("windowsIden", new WindowsIdentityProvider());
               </code>
            </example>
        </member>
        <member name="P:System.MessageBus.Security.SecurityReceiver.IdentityMapProviders">
            <summary>
               <para>Collection of IdentityMappingProviders.</para>
            </summary>
            <remarks>
               <para>IdentityMapProviderCollection holds a list of 
                  IdentityMapProviders. An IdentityMapProvider provides information about the
                  identity mappings. A SimpleIdentityMapProvider implemented is provided by the
                  system. Another IdentityMapProvider that can be implemented is a
                  SQLIdentityMapProvider. The identity map providers provide identity mappings by
                  interacting with appropriate storage. The SimpleIdentityMapProvider has an in
                  memory store of IdentityMappings.</para>
               <para>IdentityMappings provide the mapping of identities to 
                  roles for specific resources. For example, a simple identity mapping is
                  "winAuth:SomeUser@example.com" for the resource "SomeMailBox" has the "owner"
                  role. Resource is mapped off the base resource specified in the security
                  manager.</para>
               <para>The SecurityReceiver uses the IdentityProviderCollection 
                  and the IdentityMapProviderCollection to authenticate the message sender and to
                  map the sender of the message to a specific role for the resource in question.</para>
            </remarks>
            <example>
               <code lang='C#'>// Add identity providers.
                securityManager.Receiver.IdentityProviders.Add("windowsAuth", new WindowsIdentityProvider());
            // Add identity mappings. 
            SimpleIdentityMapProvider identityMapProvider = new SimpleIdentityMapProvider();
            identityMapProvider.Mappings.Add(new SimpleIdentityMapping("windowsAuth:SomeUser","SomeMailBox","Owner"));
            // Add identity map providers.
               securityManager.Receiver.IdentityMapProviderCollection.Add(identityMapProvider);
               </code>
            </example>
        </member>
        <member name="P:System.MessageBus.Security.SecurityReceiver.AccessMappings">
            <summary>
               <para>Collection of AccessMapping s. AccessMappings specify 
                  role to method mapping.</para>
            </summary>
            <remarks>
               <para>AccessMappings specify role to method mapping. 
                  AccessMappings specify which role(s) are granted access to which methods.
                  Methods are specified as an XPath filter. Typically to the routing headers
                  action attribute specifies the method being accessed. The system checks the
                  role assigned to a request and the method that the request is trying to
                  perform against the AccessMappingCollection. If a role is granted
                  access to the specified method, then the request succeeds. Otherwise, the
                  request fails.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Security.SecurityReceiver.EncryptionRequirement">
            <summary>
               <para>If this property is null, no Encryption is required.
                  The property can be set to an asymmetric or symmetric requirement.</para>
            </summary>
            <remarks>
               <para>The encryption requirement is either symmetric or 
                  asymmetric. When this property is set and the security system processes policy requests, a security policy
                  is generated indicating the encryption algoritm to use. Symmetric encryption requirements are
                  based on the identity provider to use. The client is
                  hinted on the encryption requirement to use based on the identity provider. Assymetric
                  encryption requirement allows the option of either generating an RSA key pair
                  to use or to use the key pair assosciated with
                  an X.509 certificate. (In M3, only the message body is encrypted/decrypted based on the encryption
                  requirement). </para>
            </remarks>
            <example>
               <code lang='C#'>// Usage of symmetric encryption requirement.
                securityManager.Receiver.IdentityProviders.Add("windows", new WindowsIdentityProvider());
                securityManager.Receiver.EncryptionRequirement = new SymmetricEncryptionRequirement("windows");
               </code>
            </example>
        </member>
        <member name="P:System.MessageBus.Security.SecurityReceiver.SignatureRequirement">
            <summary>
               <para>This field specifies the signature requirements on the message. The allowed 
                  options are either AllIdentiyProviders or AnyIdentityProvider.</para>
            </summary>
            <remarks>
               <para>The signature requirements are based on the identity 
                  providers collection. Signature requirements ensure message integrity. When the
                  signature requirement is specified, a policy is generated indicating that the
                  message needs to be signed using the required/allowed identity
                  type(s). Message header bound for this endpoint and the message body
                  are required to be signed by the key (or a key derived) specified in the
                  required identity provider on the client. The message bus policy system on the
                  sender uses the signature requirement (policy is obtained before actual message transfer)
                  to formulate appropriately signed messages. The message bus policy system on
                  the receiver uses the signature requirement to verify that messages are appropriately signed. </para>
            </remarks>
            <example>
               <code lang='C++'>// securitymanager has been created ahead of time...
            // Specify that we want to use all identiy providers for message integrity
            securityManager.Receiver.SignatureRequirement = SignatureRequirement.AllIdentityProviders
            // Add identity providers... in this case use WindowsAuth
            securityManager.Receiver.IdentityProviders.Add("windowsAuth", new WindowsIdentityProvider());
            // since signature requirement has been specified, the message (body and message header for this actor)
            // is required to be signed using the Windows (kerberos) token and 
            // will be verified using the attached token at the message recipient.
               </code>
            </example>
        </member>
        <member name="P:System.MessageBus.Security.SecurityReceiver.Licensing">
            <summary>
            Gets the object that controls automatic token issuance.
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.SecuritySender">
            <summary>
               <para>This class represents the SecuritySender object.</para>
            </summary>
            <remarks>
               <para>The security sender class contains a reference to a set 
                  of security tokens as a token collections. Username/password, Windows
                  (Kerberos), X.509 and XrML are examples of token providers provided by the
                  message bus system. The security sender object is contained in a security
                  manager. An example usage pattern on the message sender is to create a
                  SecurityManager, access the security sender and add available tokens to the token collection.</para>
            </remarks>
            <example>
               <code lang='C#'>// an example using configuration
            
            MessageBusConfiguration config = MessageBusConfiguration.GetFromConfig();
            
            // Load our port from config.
            
            this.port = (Port) config[typeof(Port)];
            
            // Allow all messages to be received at this port.
            
            this.securityManager = (SecurityManager) config[typeof(SecurityManager)];
            
            SecuritySender mySender = this.securityManager.sender;
               </code>
            </example>
        </member>
        <member name="P:System.MessageBus.Security.SecuritySender.TokenProviders">
            <summary>
               <para>Security token collection to be used by the security 
                  sender. Get property.</para>
            </summary>
            <remarks>
               <para>The security token collection holds the list of tokens to be used when 
                  formulating a secure message send. The security sender holds a reference to
                  the collection of security tokens to be used by the sender application. </para>
            </remarks>
            <example>
               <code lang='C#'>// an example using configuration
            
            MessageBusConfiguration config = MessageBusConfiguration.GetFromConfig();
            
            // Load our port from config.
            
            this.port = (Port) config[typeof(Port)];
            
            // Allow all messages to be received at this port.
            
            this.securityManager = (SecurityManager) config[typeof(SecurityManager)];
            
            SecuritySender mySender = this.securityManager.sender;
            this.securityManager.sender.TokenProviders.Add(new WindowsTokenProvider());
                  </code>
            </example>
        </member>
        <member name="T:System.MessageBus.Security.SecurityTokenCollection">
            <summary>
               <para>This class is a collection used to hold security tokens 
                  (typically at the sender). This collection is used by the send
                  side pipeline and policy engines to select the appropriate tokens to use in
                  service policy conformance. Individual elements of the collection can be accessed by their
                  index location.</para>
            </summary>
            <remarks>
               <para>The collection is resized automatically.</para>
            </remarks>
            <example>
               <para>This is a typical collection object, with methods for 
                  adding, removing, inserting new tokens, etc. An instance of the security
                  collection object is contained in the sender on the security manager.</para>
            </example>
        </member>
        <member name="M:System.MessageBus.Security.SecurityTokenCollection.Add(System.MessageBus.Security.ISecurityToken)">
            <summary>
               <para>Add the token specified to the token collection.</para>
            </summary>
            <param name="ISecurityToken">The security token to be added to the token collection</param>
            <returns>
               <para>Position in the token collection where the token was added. </para>
            </returns>
            <exception cref="T:System.ArgumentNullException">null param specified for the token to add to the collection</exception>
        </member>
        <member name="M:System.MessageBus.Security.SecurityTokenCollection.Contains(System.MessageBus.Security.ISecurityToken)">
            <summary>
               <para>Checkes whether the specified token is already part of 
                  the token collection.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.SecurityTokenCollection.CopyTo(System.MessageBus.Security.ISecurityToken[],System.Int32)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.SecurityTokenCollection.IndexOf(System.MessageBus.Security.ISecurityToken)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.SecurityTokenCollection.Insert(System.Int32,System.MessageBus.Security.ISecurityToken)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Security.SecurityTokenCollection.Remove(System.MessageBus.Security.ISecurityToken)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Security.SecurityTokenCollection.Item(System.Int32)">
            <summary>
               <para>Returns the security token object athe specified index.</para>
            </summary>
            <param name='index'>The position in the security token collection. The token object at this index is returned. </param>
            <value>
               <para>Token at the specified index in the collection. </para>
            </value>
        </member>
        <member name="T:System.MessageBus.Security.SignatureRequirement">
            <summary>
               <para> 
                  Signature requirements specify whether all identity providers or any identity provider in the identity
                  providers collection is to be used for ensuring the message integrity.</para>
            </summary>
            <remarks>
               <para>Signature requirements specify whether all identity providers or any identity 
                  provider in the identity providers collection is to be used for ensuring the
                  message integrity. Policy is generated expressing whether all the specified
                  token types are to be used for signing the message or one of the specified token
                  types can be used for signing the message. Client signs the message using all
                  the specified tokens or one of the specified tokens. Policy is enforced at the
                  receiver. </para>
            </remarks>
            <example>
               <code lang='C++'>// securitymanager has been created ahead of time...
            // Specify that we want to use all identiy providers for message integrity
            securityManager.Receiver.SignatureRequirement = SignatureRequirement.AllIdentityProviders
            // Add identity providers... in this case use WindowsAuth
            securityManager.Receiver.IdentityProviders.Add("windowsAuth", new WindowsIdentityProvider());
            // since signature requirement has been specified, the message (body and message header for this actor)
            // is required to be signed using the Windows (kerberos) token and 
            // will be verified using the attached token at the message recipient.
               </code>
            </example>
        </member>
        <member name="F:System.MessageBus.Security.SignatureRequirement.AllIdentityProviders">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Security.SignatureRequirement.AnyIdentityProvider">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Security.SymmetricEncryptionRequirement">
            <summary>
               <para> Class implementing SymmetricEncryptionRequirement.</para>
            </summary>
            <remarks>
               <para>SymmetricEncryptionRequirement indicates that the message 
                  body is to be encrypted using the specified identiyProvider.
                  SymmetricEncryptionRequirement is based on the IdentityProvider specified.</para>
            </remarks>
            <example>
               <code lang='C#'>// Usage of symmetric encryption requirement.
                securityManager.Receiver.IdentityProviders.Add("windows", new WindowsIdentityProvider());
                securityManager.Receiver.EncryptionRequirement = new SymmetricEncryptionRequirement("windows");
               </code>
            </example>
        </member>
        <member name="M:System.MessageBus.Security.SymmetricEncryptionRequirement.#ctor(System.String)">
            <summary>
               <para>This indicates that all messages for the given action should be encrypted using
                  the token the sender holds for that identityProvider. Policy will be generated
                  indicating this, and the SecurityManager will decrypt messages encrypted for
                  this action.</para>
            </summary>
            <param name='action'>The action that requires encryption. If the value is null, all actions are encrypted.</param>
            <param name='identityProvider'>The identity provider to leverage. THe identity provider must be symmetric key based.</param>
        </member>
        <member name="P:System.MessageBus.Security.SymmetricEncryptionRequirement.IdentityProviderName">
            <summary>
               <para>Specifies the identity provider to use for the encryption.</para>
            </summary>
            <remarks>
               <para> The identityprovider specifies the type of tokens to use when encrypting the message body 
                  at the sender and the type of identity
                  provider to use while decrypting the message body at the recipient. Policy is generated
                  at the server based on the IdentityProvider. The specified identity
                  provider/token(s) must support symmetric key encryption.</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.Transactions.BAEntryPoint">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transactions.BAEntryPoint.Main">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Transactions.PortReference">
            <summary>
               <para>This is the base PortReference class.</para>
               <para>Assume PortReference will be defined in System.MessageBus. </para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.PortReference.Address">
            <summary>
               <para>This is the URI of the target port.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.PortReference.PortType">
            <summary>
               <para>The optional QName of the PortType of the target port.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transactions.ScopePortReference.GetActivityId">
            <summary>
               <para>This is the string that uniquely identifies the business activity.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transactions.ScopePortReference.SetActivityId(System.String)">
            <summary>
               <para>This is the string that uniquely identifies the transaction.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Transactions.WsbaContext">
            <summary>
               <para>This is the information content of a WS-Coordination 
                  CoordinationContext header for a business activity. The serial form will use the correct SOAP
                  header format defined in the spec.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.WsbaContext.CoordinationType">
            <summary>
               <para>The constant indicating that this is a business activity.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.WsbaContext.ActivityId">
            <summary>
               <para>This is the business activity id that is globally unique.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.WsbaContext.Expires">
            <summary>
               <para>If the business activity does not reach the close phase by 
                  this time, it is canceled.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.WsbaContext.RegistrationService">
            <summary>
               <para>This is the reference to the 
                  WS-Coordination Registration service. It is similar to the Whereabouts in DTC. </para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Transactions.IsolationLevel">
            <summary>
               <para>This is included to allow compile to work. The 
                  IsolationLevel in System.Transaction will be used.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.IsolationLevel.Any">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.IsolationLevel.ReadUncommitted">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.IsolationLevel.ReadCommitted">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.IsolationLevel.RepeatableRead">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.IsolationLevel.Serializable">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.IsolationLevel.Snapshot">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Transactions.ConfigOptions">
            <summary>
               <para> These are the transaction configuration options 
                  associated with a message.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.ConfigOptions.AutoPropagate">
            <summary>
               <para> 
                  The rules for when a transaction should be propagated in
                  a message being sent. The possible values are:</para>
               <para>True: The current transaction context will be automatically be added to the 
                  message before sending it.</para>
               <para>False: The current transaction context will not be added 
                  to the message before sending it. This option allows the sender to enforce non-participation of the receiver
                  in a transaction.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.ConfigOptions.Timeout">
            <summary>
               <para> The number of milliseconds before the transaction is automatically 
                  aborted. This applies only to input messages. If the timeout that the
                  sender propagates is later than this value, it will be overridden by this value.
                  If a transaction is started by this input message, this Timeout is placed in
                  the transaction context.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.ConfigOptions.IsolationLevel">
            <summary>
               <para> 
                  The degree to which the
                  tentative actions taken during a transaction are allowed to be seen by
                  other transactions.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.ConfigOptions.AutoBegin">
            <summary>
               <para> 
                  This specifies the rules for when a transaction should automatically begin,
                  be imported, resume or be rejected.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.ConfigOptions.AutoComplete">
            <summary>
               <para>The rules for when a transaction that was automatically 
                  created should be committed. The possible values are:</para>
               <para>True: If a transaction is active that was automatically created (via an 
                  AutoBegin option) during this dialog, then commit will automatically be called
                  just prior to sending the response message. </para>
               <para>False: Commit will not automatically be called. </para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Transactions.AutoBegin">
            <summary>
               <para> 
                  This specifies the rules for when a transaction should automatically begin, be imported, resume
                  or be rejected.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.AutoBegin.Required">
            <summary>
               <para> 
                  The message app code must run in an automatic
                  transaction context. If the dialog already has
                  a transaction context, run the message
                  app code in it. Otherwise, if there is a propagated transaction
                  context, run the message app code in it. Otherwise, create a new transaction.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.AutoBegin.RequiresNew">
            <summary>
               <para> 
                  Automatically start a new transaction each time a
                  message arrives. If the dialog is already in
                  a transaction context, use it. Otherwise, create
                  a new transaction. Any propagated transaction context is ignored.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.AutoBegin.Supported">
            <summary>
               <para> If the dialog already has a transaction context, run the 
                  message app code in it. Otherwise, if there is a propagated transaction context, run
                  the message app code in it. Otherwise, run the message app code
                  without a transaction.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.AutoBegin.NotSupported">
            <summary>
               <para>Must run the message app code without a transaction 
                  context. If a dialog context exists, set the current transaction context to null during the message app code. Any propagated
                  context is ignored.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.AutoBegin.RequiresImport">
            <summary>
               <para> The message app code must run under the propagated 
                  context. If there is no transaction context propagated or if the dialog already
                  has a transaction context, throw a
                  System.MessageBus.Transactions.AutoDelimitConflict exception.The message app code must
                  run under the propagated context. If there is no
                  transaction context propagated, throw a System.MessageBus.Transactions.AutoBeginConflict exception.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Transactions.RegistrationPortReference">
            <summary>
               <para> 
                  This is the PortReference for the Registration service.
                  It travels in app messages in the CoordinationContext, so that web services can
                  register for coordination protocols.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.RegistrationPortReference.TransactionId">
            <summary>
               <para>The WSTX transaction identifier.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Transactions.WstxContext">
            <summary>
               <para>This is the information content of a WS-Transactions 
                  CoordinationContext header. The serial form will use the correct SOAP
                  header format defined in the spec.  Does this go in System.Transactions?</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.WstxContext.CoordinationType">
            <summary>
               <para>The constant indicating that this is an atomic transaction.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.WstxContext.TransactionId">
            <summary>
               <para>This is the transaction id that is globally unique.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.WstxContext.Expires">
            <summary>
               <para>If the transaction does not reach the commit phase by 
                  this time, it is aborted.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Transactions.WstxContext.RegistrationService">
            <summary>
               <para>This is the reference to the 
                  WS-Coordination Registration service. It is similar to the Whereabouts in DTC. </para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Transactions.StateManager">
            <summary>
               <para>The transaction StateManager. There is only 
                  one of these per AppDomain. Its public methods are static. </para>
               <para>This may be adjusted later to conform to a new way to manage state in MB. </para>
            </summary>
            <threadsafe>
               <para>The implementation must support multithreading. There are no 
                  instance variables that relate to a particular transaction or message. Per
                  transaction and message state is maintained in hashtables. </para>
            </threadsafe>
        </member>
        <member name="M:System.MessageBus.Transactions.StateManager.SetCurrentContextFromMessage(System.MessageBus.Message)">
            <summary>
               <para>This is used for transaction context propagation. It sets the current transaction context to be the context in the specified message.</para>
            </summary>
            <param name='message'> The Message instance containing the transaction context. </param>
        </member>
        <member name="M:System.MessageBus.Transactions.StateManager.PutCurrentContextInMessage(System.MessageBus.Message)">
            <summary>
               <para>This is used for transaction propagation. Add the current transaction context to a message as a header named CoordinationContext.</para>
            </summary>
            <param name='message'>The Message instance to which the current context will be added. </param>
        </member>
        <member name="M:System.MessageBus.Transactions.StateManager.BeforeAppCode(System.MessageBus.Message,System.MessageBus.Transactions.ConfigOptions)">
            <summary>
               <para> This tells the StateManager that a message was received and its app code is 
                  about to be executed.</para>
            </summary>
            <param name='message'>The Message instance that was received.</param>
            <param name=' configOptions'> Transaction configuration options.</param>
        </member>
        <member name="M:System.MessageBus.Transactions.StateManager.AfterAppCode(System.MessageBus.Message,System.MessageBus.Transactions.ConfigOptions)">
            <summary>
               <para>This tells the StateManager that a message was received 
                  and its app code has finished execution.</para>
            </summary>
            <param name='message'>The Message instance that was received</param>
            <param name=' configOptions'> Transaction config options.</param>
        </member>
        <member name="M:System.MessageBus.Transactions.StateManager.BeforeSend(System.MessageBus.Message,System.MessageBus.Transactions.ConfigOptions)">
            <summary>
               <para>This tells the StateManager that a message is about to be sent.</para>
            </summary>
            <param name='message'>The Message instance to be sent.</param>
            <param name=' configOptions'> Transaction config options.</param>
        </member>
        <member name="M:System.MessageBus.Transactions.StateManager.Cleanup(System.MessageBus.Message)">
            <summary>
               <para>This tells the state manager that the normal work threw an exception,
                  so cleanup may be needed.</para>
            </summary>
            <param name='message'>The Message instance current being processed when an exception occurred.</param>
        </member>
        <member name="T:System.MessageBus.Transports.CrossProcessTransport">
            <summary>
            <para> Transmits <see cref="T:System.MessageBus.Message"/> s across process boundaries.</para>
            </summary>
            <remarks>
            <para>The cross-process <see cref="T:System.MessageBus.Transports.Transport"/> transmits <see cref="T:System.MessageBus.Message"/> s across process boundaries 
               using named pipes.</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.Transports.Transport">
            <summary>
            <para>Base class for abstractions that transmit <see cref="T:System.MessageBus.Message"/> s over some medium. </para>
            </summary>
            <remarks>
               <para>Transport is an abstraction over both network (e.g., TCP) and on-machine 
                  (e.g., named pipes) transports. </para>
            <para>A Transport is responsible for serializing <see cref="T:System.MessageBus.Message"/> headers and content as 
               appropriate, but typically, a Transport will only read and write the data
               framing that is Transport specific and delegate de/serialization of the data
               payload to a <see cref="T:System.MessageBus.Transports.MessageFormatter"/>. </para>
            <para>A Transport does not transmit <see cref="T:System.MessageBus.MessageHeader"/> s with <see cref="P:System.MessageBus.MessageHeader.IsTransmittable"/> to false. </para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.IMessageHandler">
            <summary>
            <para>Provides base interface for <see cref="T:System.MessageBus.Message"/> processing.</para>
            </summary>
            <remarks>
            <para>A MessageHandler encapsulates the notion of a <see cref="T:System.MessageBus.Message"/> 
            consumer through a simple interface designed around synchronous and asynchronous
            versions of a single method: ProcessMessage.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.IMessageHandler.BeginProcessMessage(System.MessageBus.Message,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for ProcessMessage.</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to process</param>
            <param name=" callback">See Asynchronous Design Pattern</param>
            <param name=" state">See Asynchronous Design Pattern</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.IMessageHandler.EndProcessMessage(System.IAsyncResult)">
            <summary>
               <para>Asynchronous end for ProcessMessage.</para>
            </summary>
            <param name="result">See Asynchronous Design Pattern</param>
            <returns>
            <para><see langword="true"/> if the IMessageHandler has not and will not call 
            <see cref="M:System.MessageBus.Message.Close"/> ; otherwise, 
            <see langword="false"/>.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.IMessageHandler.ProcessMessage(System.MessageBus.Message)">
            <summary>
            <para>Processes a <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to process</param>
            <returns>
            <para><see langword="true"/> if the 
               IMessageHandler has not and will not call <see cref="M:System.MessageBus.Message.Close"/> ; otherwise, <see langword="false"/>.</para>
            </returns>
            <remarks>
            <para>A call to ProcessMessage processes a <see cref="T:System.MessageBus.Message"/> and returns a 
            <see langword="bool"/> 
            .</para>
            <list type="bullet"><item>
               <term>
                  Returning <see langword="true"/> from ProcessMessage implies the
                  IMessageHandler has not and will not call <see cref="M:System.MessageBus.Message.Close"/>. (Someone else should.)
                  The caller is permitted to continue reading and/or processing the <see cref="T:System.MessageBus.Message"/>.</term>
            </item>
            <item>
               <term>
                  Returning <see langword="false"/> from ProcessMessage implies the
                  IMessageHandler has or will call <see cref="M:System.MessageBus.Message.Close"/>. The caller should not continue reading
                  and/or processing the <see cref="T:System.MessageBus.Message"/>.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="P:System.MessageBus.IMessageHandler.CompletesSynchronously">
            <summary>
               <para>Gets whether the implementation of ProcessMessage is 
                  inherently synchronous.</para>
            </summary>
            <value>
            <para><see langword="true"/> if the implementation of ProcessMessage is inherently 
               synchronous; otherwise, <see langword="false"/>.</para>
            </value>
            <remarks>
               <para>A common design pattern is for one IMessageHandler H to call others to 
                  process a <see cref="T:System.MessageBus.Message"/>. Typically the nested IMessageHandlers are
                  called the same way H was called. That is, if H was called with ProcessMessage
                  (synchronous) the nested IMessageHandlers are too. If H was called with Begin /
                  EndProcessMessage (asynchronous), so are the nested IMessageHandlers.</para>
               <para>While this is logical, it may be inefficient. For instance, if H is called asynchronously, 
                  but a nested IMessageHandler is really synchronous, then it would
                  be nice to avoid the overhead of creating objects to manage the asynchronous
                  call (e.g., IAsyncResult) and just call the nested IMessageHandler synchronously.
                  A caller can determine whether the nested IMessageHandler is
                  synchronous or not by checking the CompletesSynchronous property.</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.IMessageProducer">
            <summary>
            <para>Provides a base interface to register an <see cref="T:System.MessageBus.IMessageHandler"/> that is called when there is a <see cref="T:System.MessageBus.Message"/> 
            to process.</para>
            </summary>
            <remarks>
            <para>An IMessageProducer is complementary to an <see cref="T:System.MessageBus.IMessageHandler"/>. An IMessageProducer is a <see cref="T:System.MessageBus.Message"/> 
            generator and provides a means to attach a <see cref="T:System.MessageBus.Message"/> consumer, (i.e., an <see cref="T:System.MessageBus.IMessageHandler"/>) as a property. </para>
            <para>When an IMessageProducer has a <see cref="T:System.MessageBus.Message"/> to process, it calls either 
            <see cref="M:System.MessageBus.IMessageHandler.ProcessMessage(System.MessageBus.Message)"/> or Begin / <see cref="M:System.MessageBus.IMessageHandler.EndProcessMessage(System.IAsyncResult)"/> on the Handler property.</para>
            <para>Because IMessageProducer is a simple interface, no base class implementation 
               is provided.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.IMessageProducer.Handler">
            <summary>
            <para>Gets and sets the <see cref="T:System.MessageBus.IMessageHandler"/> to call.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.#ctor">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.Transports.Transport"/> class.</para>
            </summary>
            <remarks>
               <para>Equivalent to Transport(null).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.#ctor(System.Uri)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.Transports.Transport"/> class.</para>
            </summary>
            <param name="url">The <see cref="T:System.Uri"/> that the Transport will receive <see cref="T:System.MessageBus.Message"/>s on.</param>
            <remarks>
            <para><paramref name="url"/> is 
               the destination of <see cref="T:System.MessageBus.Message"/>s to, and the source of <see cref="T:System.MessageBus.Message"/>s from
               the Transport.</para>
            <para><paramref name="url"/> may be null. A Transport 
            with a null <paramref name="url"/> may be used to send <see cref="T:System.MessageBus.Message"/>s, but it may only receive
            <see cref="T:System.MessageBus.Message"/>s that are in response to those it sends.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.BeginClose(System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for Close using implicit timeout.</para>
            </summary>
            <param name="callback">See Asynchronous Design Pattern.</param>
            <param name=" state">See Asynchronous Design Pattern.</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException">If the Transport is not open.</exception>
            <remarks>
            <para>Equivalent to BeginClose(<see cref="P:System.MessageBus.Transports.Transport.CloseTimeout"/>,<paramref name="callback"/>,<paramref name="state"/>).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.BeginClose(System.TimeSpan,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for Close using an explicit timeout.</para>
            </summary>
            <param name="timeout">The maximum amount of time to wait to gracefully close the Transport.</param>
            <param name=" callback">See Asynchronous Design Pattern.</param>
            <param name=" state">See Asynchronous Design Pattern.</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException">If the Transport is not open.</exception>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.BeginOpen(System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for Open.</para>
            </summary>
            <param name="callback">See Asynchronous Design Pattern.</param>
            <param name=" state">See Asynchronous Design Pattern.</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException">If the Transport is already open.</exception>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.BeginProcessMessage(System.MessageBus.Message,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for ProcessMessage.</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to send on the Transport.</param>
            <param name=" callback">See Asynchronous Design Pattern.</param>
            <param name=" state">See Asynchronous Design Pattern.</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.BeginSendMessage(System.MessageBus.IMessageHandler,System.MessageBus.Message,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for SendMessage.</para>
            </summary>
            <param name="handler"></param>
            <param name=" message">The <see cref="T:System.MessageBus.Message"/> to send.</param>
            <param name=" callback">See Asynchronous Design Pattern.</param>
            <param name=" state">See Asynchronous Design Pattern.</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="message"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">If the Transport is not open.</exception>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.Close">
            <summary>
               <para>Close the Transport with an implicit timeout.</para>
            </summary>
            <returns>
            <para><see langword="true"/> if the 
               Transport closed before CloseTimeout expired; otherwise, <see langword="false"/>.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException">If the Transport is not open.</exception>
            <remarks>
            <para>Equivalent to Close(<see cref="P:System.MessageBus.Transports.Transport.CloseTimeout"/> ).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.Close(System.TimeSpan)">
            <summary>
               <para>Close the Transport with an explicit timeout.</para>
            </summary>
            <param name="timeout">The maximum amount of time to wait to gracefully close the Transport.</param>
            <returns>
            <para><see langword="true"/> if the 
               Transport closed before <paramref name="timeout"/> expired; otherwise, <see langword="false"/>.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException">If the Transport is not open.</exception>
            <remarks>
            <para>When a Transport closes, it immediately stops accepting new <see cref="T:System.MessageBus.Message"/>s to 
               send or receive, begins flushing <see cref="T:System.MessageBus.Transports.MessageFormatter"/>s, and waits for
               partially sent or partially received <see cref="T:System.MessageBus.Message"/>s to complete before closing
               the underlying connection(s).</para>
            <para>To close a Transport abruptly, call Close(new TimeSpan(0)).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.EndClose(System.IAsyncResult)">
            <summary>
               <para>Asynchronous end for Close.</para>
            </summary>
            <param name='result'>See Asynchronous Design Pattern.</param>
            <returns>
            <para><see langword='true'/> if the Transport closed before the timeout expired; 
               otherwise, <see langword='false'/>.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.EndOpen(System.IAsyncResult)">
            <summary>
               <para>Asynchronous end for Open.</para>
            </summary>
            <param name='result'>See Asynchronous Design Pattern.</param>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.EndProcessMessage(System.IAsyncResult)">
            <summary>
               <para>Asynchronous end for ProcessMessage.</para>
            </summary>
            <param name="result">See Asynchronous Design Pattern.</param>
            <returns>
            <para><see langword="true"/> if the <see cref="T:System.MessageBus.Message"/> is 
               not consumed and will not be closed; otherwise, <see langword="false"/>.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.EndSendMessage(System.IAsyncResult)">
            <summary>
               <para>Asynchronous end for SendMessage.</para>
            </summary>
            <param name='result'>See Asynchronous Design Pattern.</param>
            <returns>
            <para><see langword='true'/> if the underlying call to ProcessMessage returns 
            <see langword='true'/> ; otherwise, <see langword='false'/>.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.GetSchemes">
            <summary>
               <para>Gets the URI schemes supported by the Transport.</para>
            </summary>
            <returns>
            <para>An array of <see langword='string'/>. Each 
            <see langword='string'/> represents a URI scheme supported by the 
               Transport.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.OnTransportError(System.Exception)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.OnTransportError(System.Object,System.MessageBus.Transports.TransportErrorEventArgs)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.OnTransportMessageSize(System.Object,System.MessageBus.Transports.TransportMessageSizeEventArgs)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.Open">
            <summary>
               <para>Activates the Transport.</para>
            </summary>
            <exception cref="T:System.InvalidOperationException">If the Transport is already open.</exception>
            <exception cref="T:System.Exception">If the Transport cannot be opened.</exception>
            <remarks>
               <para>When the Transport is opened, the Transport is enabled 
                  to send and receive <see cref="T:System.MessageBus.Message"/> s.
                  Specifically, the Handler will be called to process received Messages,
                  and various events will be raised with Transport-level
                  information.</para>
               <para> The following 
                  table summarizes when Transport properties may be set relative to opening a Transport.</para>
               <list type="table"><listheader>
                  <term>Property</term>
                  <description>Set Before Open</description>
                  <description>Set After Open</description>
               </listheader>
               <item>
                  <term> CloseTimeout</term>
                  <description>MAY</description>
                  <description>MAY</description>
               </item>
               <item>
                  <term> Handler</term>
                  <description>MAY</description>
                  <description>MUST NOT</description>
               </item>
               <item>
                  <term> Url</term>
                  <description>MAY</description>
                  <description>MUST NOT</description>
               </item>
            </list>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.ProcessMessage(System.MessageBus.Message)">
            <summary>
            <para>Sends a <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to send.</param>
            <returns>
            <para><see langword="true"/> if <paramref name="message"/> is not 
               consumed and will not be closed; otherwise, <see langword="false"/> .</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.Transports.Transport.SendMessage(System.MessageBus.IMessageHandler,System.MessageBus.Message)">
            <summary>
            <para> Calls ProcessMessage using <paramref name="handler"/> and 
            <paramref name="message"/>. </para>
            </summary>
            <param name="handler">The <see cref="T:System.MessageBus.IMessageHandler"/> to process the <paramref name="message"/>.</param>
            <param name=" message">The <see cref="T:System.MessageBus.Message"/> to send.</param>
            <returns>
            <para><see langword="true"/> if the 
               underlying call to ProcessMessage returns <see langword="true"/> ; otherwise, <see langword="false"/>.</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="message"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">If the Transport is not open.</exception>
            <remarks>
               <para>This is a helper method for derived classes. It sets 
                  IsProcessingMessages in a thread safe way and calls ProcessMessage
                  on <paramref name="handler"/>.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Transports.Transport.CloseTimeout">
            <summary>
               <para> Gets or sets the close timeout.</para>
            </summary>
            <value>
               <para>The maximum amount of time to wait for the Transport to close gracefully. Defaults to TimeSpan(0).</para>
            </value>
            <remarks>
               <para>When a Transport is closed, this timeout specifies a 
                  maximum amount of time to wait for a graceful shutdown. This timeout may be
                  set before or after the Transport is opened. </para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Transports.Transport.CompletesSynchronously">
            <summary>
            <para>Gets whether the Transport.Handler processes <see cref="T:System.MessageBus.Message"/> s 
               synchronously.</para>
            </summary>
            <value>
            <para><see langword="true"/> if Transport.Handler processes <see cref="T:System.MessageBus.Message"/>s 
               synchronously; otherwise, <see langword="false"/>.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.Transports.Transport.Handler">
            <summary>
               <para>Gets and sets the message handler that processes received 
               <see cref="T:System.MessageBus.Message"/> s.</para>
            </summary>
            <value>
               <para>The IMessageHandler that is called to process 
               <see cref="T:System.MessageBus.Message"/>s received by the Transport.</para>
            </value>
            <exception cref="T:System.InvalidOperationException">If set while the Transport is open.</exception>
            <remarks>
               <para> The Handler must not be set after the Transport is opened. Once the Transport is 
                  opened, Handler.ProcessMessage (or equivalent begin / end methods) will be
                  called for each <see cref="T:System.MessageBus.Message"/> received by the Transport.</para>
               <para>The Handler may be null. For example, a send-only Transport does not need a 
                  Handler.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Transports.Transport.IsOpen">
            <summary>
               <para>Gets whether the Transport is open.</para>
            </summary>
            <value>
            <para><see langword='true'/> if the Transport is open; otherwise, 
            <see langword='false'/>.</para>
            </value>
            <remarks>
               <para>This property is set to true when Open completes and set to false when Close 
                  begins.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Transports.Transport.IsProcessingMessages">
            <summary>
            <para>Gets whether there are any pending <see cref="T:System.MessageBus.Message"/> s.</para>
            </summary>
            <value>
            <para><see langword="true"/> if there are <see cref="T:System.MessageBus.Message"/>s 
               partially sent or received by the Transport; otherwise,
            <see langword="false"/> .</para>
            </value>
        </member>
        <member name="P:System.MessageBus.Transports.Transport.Url">
            <summary>
            <para>Gets and sets the URL that the Transport receives <see cref="T:System.MessageBus.Message"/> s on.</para>
            </summary>
            <value>
               <para>The Url is 
                  the destination of <see cref="T:System.MessageBus.Message"/>s to, and the source of <see cref="T:System.MessageBus.Message"/>s from
                  the Transport.</para>
            </value>
            <exception cref="T:System.InvalidOperationException">If set while the Transport is open.</exception>
            <exception cref="T:System.ArgumentException">If the scheme of the Url is not one of schemes supported by the Transport.</exception>
        </member>
        <member name="E:System.MessageBus.Transports.Transport.TransportError">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="E:System.MessageBus.Transports.Transport.TransportMessageSize">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transports.CrossProcessTransport.#ctor">
            <overload>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.Transports.CrossProcessTransport"/> class.</para>
            </overload>
            <summary>
               <para>Initializes a CrossProcessTransport.</para>
            </summary>
            <remarks>
               <para>Equivalent to 
                  CrossProcessTransport(<see langword="null"/> ).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.CrossProcessTransport.#ctor(System.Uri)">
            <summary>
            <para>Initializes a CrossProcessTransport given a <see cref="T:System.Uri"/> .</para>
            </summary>
            <param name="url">The <see cref="T:System.Uri"/> that the <see cref="T:System.MessageBus.Transports.Transport"/> will receive <see cref="T:System.MessageBus.Message"/>s on.</param>
            <remarks>
            <para>Equivalent to CrossProcessTransport(<paramref name="url"/>, new <see cref="T:System.MessageBus.Transports.DimeFormatterFactory"/>()).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.CrossProcessTransport.#ctor(System.Uri,System.MessageBus.Transports.MessageFormatterFactory)">
            <summary>
            <para>Initializes a CrossProcessTransport given a <see cref="T:System.Uri"/> and a <see cref="T:System.MessageBus.Transports.MessageFormatterFactory"/> .</para>
            </summary>
            <param name="url">The <see cref="T:System.Uri"/> that the <see cref="T:System.MessageBus.Transports.Transport"/> will receive <see cref="T:System.MessageBus.Message"/>s on.</param>
            <param name=" formatterFactory">The <see cref="T:System.MessageBus.Transports.MessageFormatterFactory"/> to generate <see cref="T:System.MessageBus.Transports.MessageFormatter"/>s for each underlying connection.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="formatterFactory"/> is null.</exception>
            <remarks>
            <para><paramref name="url"/> is the destination of <see cref="T:System.MessageBus.Message"/>s to, and the source of 
            <see cref="T:System.MessageBus.Message"/>s from the <see cref="T:System.MessageBus.Transports.Transport"/> .</para>
            <para><paramref name="url"/> must be of the form "ms.soap.xproc://machine/guid".</para>
            <para><paramref name="url"/> may be null. A <see cref="T:System.MessageBus.Transports.Transport"/> with a <see langword="null"/> <paramref name="url"/> may be used to 
            send <see cref="T:System.MessageBus.Message"/>s, but it may only receive <see cref="T:System.MessageBus.Message"/>s that
            are in response to those it sends.</para>
            </remarks>
            <example>
               <para>This example shows constructing a send / receive 
                  CrossProcessTransport.</para>
               <code lang="C#">
            Uri u = new Uri("ms.soap.xproc://localhost/a8ea19f3-210f-4eb2-8da4-4c0f1cbb888e/sender");
            MessageFormatterFactory f = new DimeFormatterFactory();
            Transport t = new CrossProcessTransport(u,f);
               </code>
            </example>
        </member>
        <member name="M:System.MessageBus.Transports.CrossProcessTransport.BeginClose(System.TimeSpan,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for Close.</para>
            </summary>
            <param name="timeout">The maximum amount of time to wait to gracefully close the <see cref="T:System.MessageBus.Transports.Transport"/></param>
            <param name=" callback">See Asynchronous Design Pattern</param>
            <param name=" state">See Asynchronous Design Pattern</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.Transports.CrossProcessTransport.BeginProcessMessage(System.MessageBus.Message,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for ProcessMessage.</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to send on the Transport</param>
            <param name=" callback">See Asynchronous Design Pattern</param>
            <param name=" state">See Asynchronous Design Pattern</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="message"/> is null.</exception>
            <remarks>
            <para>If the <see cref="T:System.MessageBus.MessageEncoding"/> of <paramref name="message"/> is 
               null, sets it to <see cref="M:System.MessageBus.Transports.MessageFormatterFactory.GetDefaultEncoding"/>
               of <paramref name="formatterFactory"/>.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.CrossProcessTransport.EndClose(System.IAsyncResult)">
            <summary>
               <para>Asynchronous end for Close.</para>
            </summary>
            <param name="result">See Asynchronous Design Pattern</param>
            <returns>
            <para><see langword="true"/> if the <see cref="T:System.MessageBus.Transports.Transport"/> closed before the 
               timeout expired; otherwise, <see langword="false"/>.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.Transports.CrossProcessTransport.EndProcessMessage(System.IAsyncResult)">
            <summary>
               <para>Asynchronous end for ProcessMessage.</para>
            </summary>
            <param name="result">See Asynchronous Design Pattern</param>
            <returns>
            <para><see langword="true"/> if the <see cref="T:System.MessageBus.Message"/> is not consumed and will not be closed; 
               otherwise, <see langword="false"/>.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.Transports.CrossProcessTransport.GetSchemes">
            <summary>
               <para>Gets the URI schemes supported by the Transport.</para>
            </summary>
            <returns>
               <para>{"ms.soap.xproc"}</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.Transports.CrossProcessTransport.Open">
            <summary>
            <para>Activates the <see cref="T:System.MessageBus.Transports.Transport"/> .</para>
            </summary>
            <exception cref="T:System.InvalidOperationException">If the <see cref="T:System.MessageBus.Transports.Transport"/> is already open</exception>
            <exception cref="T:System.Exception">If the <see cref="T:System.MessageBus.Transports.Transport"/> cannot be opened</exception>
            <remarks>
            <para>See <see cref="T:System.MessageBus.Transports.Transport"/> for details.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.CrossProcessTransport.ProcessMessage(System.MessageBus.Message)">
            <summary>
            <para>Sends a <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to send.</param>
            <returns>
            <para><see langword="true"/> if <paramref name="message"/> is not consumed and will not be 
               closed; otherwise, <see langword="false"/> .</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="message"/> is null.</exception>
            <remarks>
            <para>If the <see cref="T:System.MessageBus.MessageEncoding"/> of <paramref name="message"/> is null, sets it to <see cref="M:System.MessageBus.Transports.MessageFormatterFactory.GetDefaultEncoding"/> of 
            <paramref name="formatterFactory"/>.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Transports.CrossProcessTransport.CompletesSynchronously">
            <summary>
            <para>Gets whether the <see cref="P:System.MessageBus.Transports.Transport.Handler"/> processes <see cref="T:System.MessageBus.Message"/> s synchronously.</para>
            </summary>
            <value>
            <para><see langword="false"/></para>
            </value>
        </member>
        <member name="P:System.MessageBus.Transports.CrossProcessTransport.IdleTimeout">
            <summary>
               <para>Gets maximum amount of time to wait before closing an idle connection.</para>
            </summary>
            <value>
               <para>Default is 2 minutes.</para>
            </value>
        </member>
        <member name="T:System.MessageBus.Transports.DimeFormatterFactory">
            <summary>
            <para>Creates Dime <see cref="T:System.MessageBus.Transports.MessageFormatter"/> s.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Transports.MessageFormatterFactory">
            <summary>
            <para>Creates <see cref="T:System.MessageBus.Transports.MessageFormatter"/> s.</para>
            </summary>
            <remarks>
               <para>Message formatters are constructed using a factory instead of "new" because 
                  message formatters are plugged into extensibility points in other
                  classes. Those classes are unaware of the specific type(s) of message
                  formatter(s) supplied, and need a polymorphic constructor to create the needed
                  formatters.</para>
            <para>A formatter factory is bound to a given set of <see cref="T:System.MessageBus.MessageEncoding"/> s; to read in, or write out, <see cref="T:System.MessageBus.Message"/> s in 
               a different <see cref="T:System.MessageBus.MessageEncoding"/>, a new formatter factory must be created.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.MessageFormatterFactory.CreateFormatter(System.IO.Stream)">
            <summary>
               <para>Create a message formatter.</para>
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> that the <see cref="T:System.MessageBus.Transports.MessageFormatter"/> will read from (to "receive" messages) and write to (to "send" messages).</param>
            <returns>
            <para>A <see cref="T:System.MessageBus.Transports.MessageFormatter"/> instance. </para>
            </returns>
            <remarks>
            <para>A MessageFormatter is bound to a given <see cref="T:System.IO.Stream" qualify="true"/>; to read to, or write from, a 
               different <see cref="T:System.IO.Stream" qualify="true"/>, a new MessageFormatter must be created.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.MessageFormatterFactory.GetDefaultEncoding">
            <summary>
            <para>Gets the default <see cref="T:System.MessageBus.MessageEncoding"/> .</para>
            </summary>
            <returns>
            <para>The <see cref="T:System.MessageBus.MessageEncoding"/> to use if none is 
               supplied by the <see cref="T:System.MessageBus.Message"/> to be formatted.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.Transports.DimeFormatterFactory.#ctor">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.Transports.DimeFormatterFactory"/> class.</para>
            </summary>
            <remarks>
               <para> 
                  Equivalent to DimeFormatterFactory({ <see cref="T:System.MessageBus.Transports.TextXmlFormatterFactory"/>}).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.DimeFormatterFactory.#ctor(System.MessageBus.Transports.MessageFormatterFactory[])">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.Transports.DimeFormatterFactory"/> class.</para>
            </summary>
            <param name="subFormatters">The <see cref="T:System.MessageBus.Transports.MessageFormatterFactory"/> s to use to format DIME application payloads.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="subFormatters"/> is <see langword="null"/> .</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If length of <paramref name="subFormatters"/> is &lt; 1 </exception>
            <exception cref="T:System.ArgumentException">If any entry in <paramref name="subFormatters"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.MessageBus.Transports.DimeFormatterFactory.CreateFormatter(System.IO.Stream)">
            <nodoc/>
            <summary>
            </summary>
            <param name=''></param>
        </member>
        <member name="M:System.MessageBus.Transports.DimeFormatterFactory.GetDefaultEncoding">
            <summary>
            <para>Gets the default <see cref="T:System.MessageBus.MessageEncoding"/> .</para>
            </summary>
            <returns>
            <para>A <see cref="T:System.MessageBus.DimeEncoding"/> with a sub format of a <see cref="T:System.MessageBus.TextXmlEncoding"/> with <see cref="T:System.Text.UTF8Encoding" qualify="true"/> .</para>
            </returns>
        </member>
        <member name="T:System.MessageBus.Transports.InProcessTransport">
            <summary>
            <para>Transmits <see cref="T:System.MessageBus.Message"/>s within a single process.</para>
            </summary>
            <remarks>
            <para>The in-process Transport transmits a <see cref="T:System.MessageBus.Message"/> 
            within a process by cloning the <see cref="T:System.MessageBus.Message"/>. It does not use a <see cref="T:System.MessageBus.Transports.MessageFormatter"/> to de/serialize the <see cref="T:System.MessageBus.Message"/>.</para>
            <para> InProcessTransport marks the <see cref="T:System.MessageBus.RoutingHeader"/> as understood.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.InProcessTransport.#ctor">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.Transports.InProcessTransport"/> class.</para>
            </summary>
            <remarks>
               <para>Equivalent to InProcessTransport(null).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.InProcessTransport.#ctor(System.Uri)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.Transports.InProcessTransport"/> class.</para>
            </summary>
            <param name="url">The <see cref="T:System.Uri"/> that the Transport will receive <see cref="T:System.MessageBus.Message"/>s on.</param>
            <remarks>
            <para><paramref name="url"/> is the destination of <see cref="T:System.MessageBus.Message"/>s to, and the source of 
            <see cref="T:System.MessageBus.Message"/>s from the Transport.</para>
            <para><paramref name="url"/> may be null. A Transport 
            with a null <paramref name="url"/> may be used to send <see cref="T:System.MessageBus.Message"/>s, but it may only receive
            <see cref="T:System.MessageBus.Message"/>s that are in response to those it sends.</para>
            </remarks>
            <example>
               <para>This example shows constructing a send / receive 
                  InProcessTransport.</para>
               <code lang="C#">
            Uri u = new Uri("ms.soap.inproc://localhost/sender");
            Transport t = new InProcessTransport(u);
               </code>
            </example>
        </member>
        <member name="M:System.MessageBus.Transports.InProcessTransport.BeginClose(System.TimeSpan,System.AsyncCallback,System.Object)">
            <nodoc/>
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transports.InProcessTransport.BeginProcessMessage(System.MessageBus.Message,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for ProcessMessage.</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to send on the Transport.</param>
            <param name=" callback">See Asynchronous Design Pattern.</param>
            <param name=" stage">See Asynchronous Design Pattern.</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="message"/> is null.</exception>
        </member>
        <member name="M:System.MessageBus.Transports.InProcessTransport.EndClose(System.IAsyncResult)">
            <nodoc/>
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transports.InProcessTransport.EndProcessMessage(System.IAsyncResult)">
            <nodoc/>
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transports.InProcessTransport.GetSchemes">
            <summary>
               <para>Gets the URI schemes supported by the Transport.</para>
            </summary>
            <returns>
               <para>{"ms.soap.inproc"}</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.Transports.InProcessTransport.Open">
            <nodoc/>
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transports.InProcessTransport.ProcessMessage(System.MessageBus.Message)">
            <nodoc/>
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Transports.InProcessTransport.CompletesSynchronously">
            <nodoc/>
            <summary>
            </summary>
        </member>
        <member name="T:System.MessageBus.Transports.MessageFormatter">
            <summary>
               <para> 
                  Reads and writes <see cref="T:System.MessageBus.Message"/> (s) into a formatted <see cref="T:System.IO.Stream"/>
                  of Bytes.</para>
            </summary>
            <remarks>
               <para>A MessageFormatter converts between a representation of 
                  the message as a <see cref="T:System.IO.Stream"/>
                  of Bytes and the in-memory, <see cref="T:System.MessageBus.Message"/> instance. This is a general conversion
                  process but is most commonly used when a <see cref="T:System.MessageBus.Message"/>
                  is sent or received
                  over the network.</para>
            <para>When a <see cref="T:System.MessageBus.Message"/> is sent over the network, a 
               MessageFormatter is used to write the in-memory <see cref="T:System.MessageBus.Message"/> instance into the
               required, on-the-wire payload format. In terms of the programming model, a
               MessageFormatter implements <see cref="T:System.MessageBus.IMessageHandler"/> ; writing a
            <see cref="T:System.MessageBus.Message"/>
            is done by calling the ProcessMessage
            method (or the corresponding Begin / End methods) of the formatter.</para>
            <para>When a message is received from the network, a 
               MessageFormatter is used to read the message data from the on-the-wire payload
               format into an in-memory <see cref="T:System.MessageBus.Message"/> instance. In terms of programming
               model, a formatter implements <see cref="T:System.MessageBus.IMessageProducer"/> , so it has a
               Handler property; a read <see cref="T:System.MessageBus.Message"/> is "pushed" by calling the ProcessMessage
               method (or Begin / End) of the <see cref="T:System.MessageBus.IMessageHandler"/>
               in the
               MessageFormatter's Handler property.</para>
            <para> 
               It is the responsibility of a MessageFormatter to
               deliver and receive formatted chunks to the message <see cref="T:System.IO.Stream"/>
               in the appropriate
               sequence. This includes any header information (e.g., for DIME records).</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.SyncMessageHandler">
            <summary>
            <para>Base class for a synchronous <see cref="T:System.MessageBus.IMessageHandler"/> .</para>
            </summary>
            <remarks>
               <para>This class provides a base implementation for Begin / EndProcessMessage 
                  (asynchronous) in terms of the ProcessMessage (synchronous) calling pattern.
                  This allows a class that derives from SynchronousMessageHandler (and implements
                  ProcessMessage) to expose the asynchronous call pattern without having to
                  explicitly implement it.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.SyncMessageHandler.BeginProcessMessage(System.MessageBus.Message,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for ProcessMessage.</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to process</param>
            <param name=" callback">See Asynchronous Design Pattern</param>
            <param name=" state">See Asynchronous Design Pattern</param>
            <returns>
               <para>See Asynchronous Design Pattern</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.SyncMessageHandler.EndProcessMessage(System.IAsyncResult)">
            <summary>
               <para>Asynchronous end for ProcessMessage.</para>
            </summary>
            <param name="result">See Asynchronous Design Pattern</param>
            <returns>
            <para><see langword="true"/> if the <see cref="T:System.MessageBus.IMessageHandler"/> has not and will not call 
            <see cref="M:System.MessageBus.Message.Close"/> ; otherwise, 
            <see langword="false"/>.</para>
            </returns>
            <remarks>
            <para>See <see cref="T:System.MessageBus.IMessageHandler"/> for details.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.SyncMessageHandler.ProcessMessage(System.MessageBus.Message)">
            <summary>
            <para>Processes a <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to process</param>
            <returns>
            <para><see langword="true"/> if the <see cref="T:System.MessageBus.IMessageHandler"/> has not and will not call 
            <see cref="M:System.MessageBus.Message.Close"/> ; otherwise, 
            <see langword="false"/>.</para>
            </returns>
            <remarks>
            <para>See <see cref="T:System.MessageBus.IMessageHandler"/> for details.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.SyncMessageHandler.CompletesSynchronously">
            <summary>
               <para>Gets whether the implementation of ProcessMessage is inherently 
                  synchronous.</para>
            </summary>
            <value>
            <para><see langword="true"/> </para>
            </value>
            <remarks>
            <para>See <see cref="T:System.MessageBus.IMessageHandler"/> for details.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.MessageFormatter.#ctor">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.Transports.MessageFormatter"/> class.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transports.MessageFormatter.BeginProduceMessages(System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for ProduceMessages.</para>
            </summary>
            <param name='callback'>See Asynchronous Design Pattern.</param>
            <param name=' state'>See Asynchronous Design Pattern.</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.Transports.MessageFormatter.EndProduceMessages(System.IAsyncResult)">
            <summary>
               <para>Asynchronous end for ProduceMessages.</para>
            </summary>
            <param name='result'>See Asynchronous Design Pattern.</param>
        </member>
        <member name="M:System.MessageBus.Transports.MessageFormatter.Flush">
            <summary>
               <para>Flush any buffered Bytes.</para>
            </summary>
            <remarks>
               <para>Blocks until internal buffers are flushed to the network 
                  (but doesn't wait for those asynchronous writes to complete).</para>
            <para>Comparable to <see cref="M:System.IO.Stream.Flush"/>.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.MessageFormatter.OnMessageReceived(System.Int32)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transports.MessageFormatter.OnMessageSent(System.Int32)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transports.MessageFormatter.OnTransportError(System.Exception)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transports.MessageFormatter.OnTransportError(System.Object,System.MessageBus.Transports.TransportErrorEventArgs)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transports.MessageFormatter.OnTransportMessageSize(System.Object,System.MessageBus.Transports.TransportMessageSizeEventArgs)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transports.MessageFormatter.ProduceMessages">
            <summary>
               <para>Activate the MessageFormatter to begin processing 
               <see cref="T:System.MessageBus.Message"/> s.</para>
            </summary>
            <remarks>
            <para>Analogous to <see cref="M:System.MessageBus.Port.Open"/> and <see cref="M:System.MessageBus.Transports.Transport.Open"/>, ProduceMessages activates the 
               MessageFormatter. After calling ProduceMessages, the <see cref="T:System.MessageBus.IMessageHandler"/>
               in the
               Handler property should be ready to receive calls to ProcessMessage.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Transports.MessageFormatter.Handler">
            <summary>
            <para>Gets and sets the <see cref="T:System.MessageBus.IMessageHandler"/> that processes <see cref="T:System.MessageBus.Message"/>s read 
               from the <see cref="T:System.IO.Stream"/> . </para>
            </summary>
            <value>
            <para>An <see cref="T:System.MessageBus.IMessageHandler"/> or <see langword="null"/> .</para>
            </value>
            <exception cref="T:System.InvalidOperationException">When setting the Handler, if the MessageFormatter is producing <see cref="T:System.MessageBus.Message"/> s.</exception>
            <remarks>
            <para>The Handler is called to process <see cref="T:System.MessageBus.Message"/>s that 
               are read out of the <see cref="T:System.IO.Stream"/>
               .</para>
            <para>This property implements <see cref="T:System.MessageBus.IMessageProducer"/>. </para>
            </remarks>
        </member>
        <member name="E:System.MessageBus.Transports.MessageFormatter.TransportError">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="E:System.MessageBus.Transports.MessageFormatter.TransportMessageSize">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Transports.TcpTransport">
            <summary>
               <para>Abstraction of TCP/IP transport.</para>
            </summary>
            <remarks>
            <para> TcpTransport transmits <see cref="T:System.MessageBus.Message"/>s using the TCP/IP networking stack. It handles connection pooling.</para>
            <para> CloseTimeout defaults to 1 second.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.TcpTransport.#ctor">
            <overload>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.Transports.TcpTransport"/> class.</para>
            </overload>
            <summary>
               <para> Initializes a TcpTransport to anonymously send 
               <see cref="T:System.MessageBus.Message"/>s encoded as text/XML within DIME.</para>
            </summary>
            <remarks>
               <para>Equivalent to TcpTransport(null).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.TcpTransport.#ctor(System.Uri)">
            <summary>
            <para>Initializes a TcpTransport to send and receive <see cref="T:System.MessageBus.Message"/>s on a specific URL and 
               encoded as text/XML within DIME.</para>
            </summary>
            <param name="url">The <see cref="T:System.Uri"/> that the Transport will receive <see cref="T:System.MessageBus.Message"/>s on.</param>
            <remarks>
            <para>Equivalent to TcpTransport(<paramref name="url"/>, new <see cref="T:System.MessageBus.Transports.DimeFormatterFactory"/>())</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.TcpTransport.#ctor(System.Uri,System.MessageBus.Transports.MessageFormatterFactory)">
            <summary>
            <para>Initializes a TcpTransport to send and receive <see cref="T:System.MessageBus.Message"/>s on a specific URL and 
               encoded using the specified <see cref="T:System.MessageBus.Transports.MessageFormatter"/>.</para>
            </summary>
            <param name="url">The <see cref="T:System.Uri"/> that the Transport will receive <see cref="T:System.MessageBus.Message"/>s on.</param>
            <param name=" formatterFactory">The <see cref="T:System.MessageBus.Transports.MessageFormatterFactory"/> to generate <see cref="T:System.MessageBus.Transports.MessageFormatter"/>s for each underlying connection.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="formatterFactory"/> is null.</exception>
            <remarks>
            <para><paramref name="url"/> is the destination of <see cref="T:System.MessageBus.Message"/>s to, and the source of 
            <see cref="T:System.MessageBus.Message"/>s from the Transport.</para>
            <para><paramref name="url"/> may be null. A Transport with a null <paramref name="url"/> may be used to 
            send <see cref="T:System.MessageBus.Message"/>s, but it may only receive <see cref="T:System.MessageBus.Message"/>s that
            are in response to those it sends.</para>
            </remarks>
            <example>
               <para>This example shows constructing a send / receive 
                  TcpTransport.</para>
               <code lang="C#">
            Uri u = new Uri("soap.tcp://localhost/sender");
            MessageFormatterFactory f = new DimeFormatterFactory();
            Transport t = new TcpTransport(u,f);
               </code>
            </example>
        </member>
        <member name="M:System.MessageBus.Transports.TcpTransport.BeginClose(System.TimeSpan,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for Close using an explicit timeout.</para>
            </summary>
            <param name="timeout">The maximum amount of time to wait to gracefully close the Transport.</param>
            <param name=" callback">See Asynchronous Design Pattern.</param>
            <param name=" state">See Asynchronous Design Pattern.</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
            <exception cref="T:System.InvalidOperationException">If the Transport is not open.</exception>
            <exception cref="T:System.InvalidOperationException">If the Transport is in the process of closing.</exception>
        </member>
        <member name="M:System.MessageBus.Transports.TcpTransport.BeginProcessMessage(System.MessageBus.Message,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for ProcessMessage.</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to send on the Transport.</param>
            <param name=" callback">See Asynchronous Design Pattern.</param>
            <param name=" state">See Asynchronous Design Pattern.</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">If<paramref name="message"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">If Transport is not open.</exception>
            <remarks>
            <para>If the<see cref="T:System.MessageBus.MessageEncoding"/> of<paramref name="message"/> is null, 
               sets it to<see cref="M:System.MessageBus.Transports.MessageFormatterFactory.GetDefaultEncoding"/> of<paramref name="formatterFactory
               "/>.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.TcpTransport.EndClose(System.IAsyncResult)">
            <nodoc/>
        </member>
        <member name="M:System.MessageBus.Transports.TcpTransport.EndProcessMessage(System.IAsyncResult)">
            <nodoc/>
        </member>
        <member name="M:System.MessageBus.Transports.TcpTransport.GetSchemes">
            <summary>
               <para>Gets the URI schemes supported by the Transport.</para>
            </summary>
            <returns>
               <para>{"soap", "soap.tcp"}</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.Transports.TcpTransport.Open">
            <nodoc/>
        </member>
        <member name="M:System.MessageBus.Transports.TcpTransport.ProcessMessage(System.MessageBus.Message)">
            <summary>
            <para>Sends a <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to send on the Transport.</param>
            <returns>
            <para><see langword="true"/> if <paramref name="message"/> is not consumed and will not be 
               closed; otherwise, <see langword="false"/> .</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="message"/> is null.</exception>
            <remarks>
            <para>If the <see cref="T:System.MessageBus.MessageEncoding"/> of <paramref name="message"/> is null, sets it to <see cref="M:System.MessageBus.Transports.MessageFormatterFactory.GetDefaultEncoding"/> of 
            <paramref name="formatterFactory"/>.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Transports.TcpTransport.CompletesSynchronously">
            <summary>
            <para>Gets whether the Transport.Handler processes <see cref="T:System.MessageBus.Message"/> s synchronously.</para>
            </summary>
            <value>
            <para><see langword="false"/>.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.Transports.TcpTransport.IdleTimeout">
            <summary>
            <para>Gets the maximum amount of time to wait between <see cref="T:System.MessageBus.Message"/> s.</para>
            </summary>
            <value>
               <para>Defaults to 2 minutes.</para>
            </value>
            <remarks>
            <para>IdleTimeout is the maximum amount of idle time to wait between <see cref="T:System.MessageBus.Message"/>s 
               before the underlying connection is closed.</para>
            <para>IdleTimeout may be &lt; MessageTimeout. </para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Transports.TcpTransport.MessageTimeout">
            <summary>
            <para>Gets the maximum amount of time to wait for <see cref="T:System.MessageBus.Message"/> to 
               complete.</para>
            </summary>
            <value>
               <para>Defaults to 2 minutes.</para>
            </value>
            <remarks>
            <para>MessageTimeout is the maximum amount of idle time to wait during <see cref="T:System.MessageBus.Message"/>transmission before the underlying connection is 
               closed.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Transports.TcpTransport.IsProcessingMessages">
            <nodoc/>
        </member>
        <member name="T:System.MessageBus.Transports.TextXmlFormatterFactory">
            <summary>
            <para>Creates <see cref="T:System.MessageBus.Transports.MessageFormatter"/>s that 
               parse and generate <see cref="T:System.MessageBus.Message"/>s with <see cref="T:System.MessageBus.TextXmlEncoding"/> .</para>
            </summary>
            <remarks>
            <para>A TextXmlFormatterFactory generates a <see cref="T:System.MessageBus.Transports.MessageFormatter"/> that is bound to a <see cref="T:System.IO.Stream"/> . After 
               constructing the appropriate <see cref="T:System.MessageBus.MessageHeaderCollection"/> from the <see cref="T:System.IO.Stream"/>
               , the table
               below summarizes the type of <see cref="T:System.MessageBus.MessageContent"/> the <see cref="T:System.MessageBus.Transports.MessageFormatter"/> will construct for the remainder
               of the <see cref="T:System.IO.Stream"/>
               .</para>
            <list type="table"><listheader>
               <term>If...</term>
               <description>then generate...</description>
            </listheader>
            <item>
            <term><see cref="T:System.MessageBus.Message"/> is a fault</term>
            <description><see cref="T:System.MessageBus.ExceptionContent"/></description>
            </item>
            <item>
            <term><see cref="T:System.MessageBus.Message"/> 
            has an empty Body (e.g., &lt;Body/&gt;)</term>
            <description><see cref="T:System.MessageBus.EmptyContent"/></description>
            </item>
            <item>
               <term> otherwise</term>
            <description><see cref="T:System.MessageBus.MessageContent"/></description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Transports.TextXmlFormatterFactory.#ctor">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.Transports.TextXmlFormatterFactory"/> class.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transports.TextXmlFormatterFactory.CreateFormatter(System.IO.Stream)">
            <nodoc/>
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Transports.TextXmlFormatterFactory.GetDefaultEncoding">
            <summary>
            <para>Gets the default <see cref="T:System.MessageBus.MessageEncoding"/> .</para>
            </summary>
            <returns>
            <para>A <see cref="T:System.MessageBus.TextXmlEncoding"/> with <see cref="T:System.Text.UTF8Encoding" qualify="true"/> .</para>
            </returns>
        </member>
        <member name="P:System.MessageBus.Transports.TextXmlFormatterFactory.MaxHeaderSize">
            <summary>
            <para>Gets and sets the maximum size of the set of <see cref="T:System.MessageBus.MessageHeader"/> s.</para>
            </summary>
            <value>
            <para>The maximum size (number of Bytes) of the set of <see cref="T:System.MessageBus.MessageHeader"/> s.</para>
            </value>
            <exception cref="T:System.ArgumentOutOfRangeException">When setting MaxHeaderSize, if the new value is less than 1024.</exception>
            <remarks>
               <para>This is the maximum number of Bytes in the formatted 
                  representation of the set of <see cref="T:System.MessageBus.MessageHeader"/> s. (On the <see cref="T:System.IO.Stream"/> side of the
               <see cref="T:System.MessageBus.Transports.MessageFormatter"/>.) It defaults to 32 KBytes.</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.AsyncMessageHandler">
            <summary>
            <para>Base class for an asynchronous <see cref="T:System.MessageBus.IMessageHandler"/> .</para>
            </summary>
            <remarks>
               <para>This class provides a base implementation for 
                  ProcessMessage (synchronous) in terms of the Begin / EndProcessMessage
                  (asynchronous) calling pattern. This allows a class that derives from
                  AsynchronousMessageHandler (and implements Begin / EndProcessMessage) to expose
                  the synchronous call pattern without having to explicitly implement it.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.AsyncMessageHandler.BeginProcessMessage(System.MessageBus.Message,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for ProcessMessage.</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to process</param>
            <param name=" callback">See Asynchronous Design Pattern</param>
            <param name=" state">See Asynchronous Design Pattern</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.AsyncMessageHandler.EndProcessMessage(System.IAsyncResult)">
            <summary>
               <para>Asynchronous end for ProcessMessage.</para>
            </summary>
            <param name="result">See Asynchronous Design Pattern</param>
            <returns>
            <para><see langword="true"/> if the 
            <see cref="T:System.MessageBus.IMessageHandler"/> has not and will not call 
            <see cref="M:System.MessageBus.Message.Close"/> ; otherwise, 
            <see langword="false"/>.</para>
            </returns>
            <remarks>
            <para>See <see cref="T:System.MessageBus.IMessageHandler"/> for details.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.AsyncMessageHandler.ProcessMessage(System.MessageBus.Message)">
            <summary>
            <para>Processes a <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to process</param>
            <returns>
            <para><see langword="true"/> if the 
            <see cref="T:System.MessageBus.IMessageHandler"/> has not and will not call 
            <see cref="M:System.MessageBus.Message.Close"/> ; otherwise, 
            <see langword="false"/>.</para>
            </returns>
            <remarks>
            <para>See <see cref="T:System.MessageBus.IMessageHandler"/> for details.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.AsyncMessageHandler.CompletesSynchronously">
            <summary>
               <para>Gets whether the implementation of ProcessMessage is inherently 
                  synchronous.</para>
            </summary>
            <value>
            <para><see langword="false"/></para>
            </value>
            <remarks>
            <para>See <see cref="T:System.MessageBus.IMessageHandler"/> for details.</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.AsyncResult">
            <summary>
            Base class for common AsyncResult programming scenarios.
            </summary>
        </member>
        <member name="M:System.MessageBus.AsyncResult.Complete(System.Boolean)">
            <summary>
            Call this version of complete when your asynchronous operation is complete.  This will update the state
            of the operation and notify the callback.
            </summary>
            <param name="completedSynchronously"></param>
        </member>
        <member name="M:System.MessageBus.AsyncResult.Complete(System.Boolean,System.Exception)">
            <summary>
            Call this version of complete if you raise an exception during processing.  In addition to notifying
            the callback, it will capture the exception and store it to be thrown during AsyncResult.End.
            </summary>
            <param name="exception"></param>
        </member>
        <member name="M:System.MessageBus.AsyncResult.End(System.IAsyncResult)">
            <summary>
            End should be called when the End function for the asynchronous operation is complete.  It
            ensures the asynchronous operation is complete, and does some common validation.
            </summary>
            <param name="result"></param>
        </member>
        <member name="T:System.MessageBus.CompiledPolicyStatements">
            <summary>
               <para>Policy Statements that are ready to be applied to a message. Compiled by a Policy 
                  Extension.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.CompiledPolicyStatements.#ctor(System.MessageBus.PolicyExtension)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.CompiledPolicyStatements"/> class.</para>
            </summary>
            <param name="policyExtension"> The <see cref="T:System.MessageBus.PolicyExtension"/> that created this class </param>
            <remarks>
               <para>The CompiledPolicyStatements works closely with the PolicyExtension that 
                  created it. </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.CompiledPolicyStatements.EndCalculateForwardPath(System.IAsyncResult,System.MessageBus.MessageHeader[]@)">
            <summary>
               <para>Asynchronous end for CalculateForwardPath.</para>
            </summary>
            <param name='result'>See asynchronous design pattern.</param>
            <param name=' headersToAdd'>When this method returns, contains a MessageHeader array. This parameter is passed uninitialized.</param>
            <returns>
               <para>An array of forward path URIs. Should not be null, but may be "new Uri[0]" if there are no Uris to return.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.CompiledPolicyStatements.CalculateForwardPath(System.MessageBus.Message,System.MessageBus.MessageHeader[]@)">
            <summary>
               <para>The message should not be modified in the 
                  CalculateForwardPath calls.</para>
            </summary>
            <param name='message'>Forward path is calculated for this message.</param>
            <param name=' headersToAdd'>When this method returns, contains a MessageHeader array. This parameter is passed uninitialized.</param>
            <returns>
               <para>An array of forward path URIs. Can be null.</para>
            </returns>
            <remarks>
               <para>Key method for applying policy statements to a message. The returned URI 
                  array should always be non-null.  Either an array of length 0 or longer 
                  if a new endpoint, with new policies, must be added
                  to the forward path above the current top via element.</para>
               The Policy manager will add the array of Message Headers to the message
               before calling the pipeline for the current endpoint.
            </remarks>
        </member>
        <member name="M:System.MessageBus.CompiledPolicyStatements.BeginCalculateForwardPath(System.MessageBus.Message,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for CalculateForwardPath.</para>
            </summary>
            <param name='message'>Forward path is calculated for this message.</param>
            <param name=' callback'>See asynchronous design pattern.</param>
            <param name=' state'>See asynchronous design pattern.</param>
            <returns>
               <para>See asynchronous design pattern.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.CompiledPolicyStatements.GetSendHandlers">
            <summary>
               <para> Returns an array of send handlers to be installed in 
                  the policy processing pipeline.</para>
            </summary>
            <remarks>
               <para>The message may be modified by handlers. The forward path should not be modified by 
                  the handlers. The Policy Manager adds these SendHandlers to the pipelines
                  constructed to process the current message.</para>
               <para>The SendHandlers can depend on the policies and policy statements compiled 
                  into this object, but should not depend on the specific message(s)
                  passed to CalculateForwardPath.</para>
               <para>The SendHandler entries correspond one for one with the Stages returned 
                  by the Policy Extension.</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.ContentType">
            <summary>
               <para>A type of media content.</para>
            </summary>
            <remarks>
               <para> This is a typed wrapper for specific content 
                  types. Content types may be either a MIME media type (media-type per RFC 2616)
                  or a URI (absoluteURI per
                  RFC 2396).</para>
            </remarks>
            <example>
               <para>Examples of MIME media types include: image/jpeg, text/xml, 
                  application/dime.</para>
               <para>Examples of URI types include: http://schemas.xmlsoap.org/soap/envelope/.</para>
            </example>
        </member>
        <member name="M:System.MessageBus.ContentType.#ctor(System.String)">
            <overload>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.ContentType"/> class.</para>
            </overload>
            <summary>
               <para>Initializes ContentType for a given media type.</para>
            </summary>
            <param name="mediaType">The string that indicates a MIME media type.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="mediaType"/> is <see langword="null"/> .</exception>
            <remarks>
               <para>Media types are defined in RFC 2616.</para>
            </remarks>
            <example>
               <para>This example creates a ContentType corresponding to a 
                  JPEG image.</para>
               <code lang="C#">
            ContentType c = new ContentType("image/jpeg");
               </code>
            </example>
        </member>
        <member name="M:System.MessageBus.ContentType.#ctor(System.Uri)">
            <summary>
               <para>Initializes ContentType for a URI-style content type.</para>
            </summary>
            <param name="uriType">The <see cref="T:System.Uri"/> that indicates a URI-style content type.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="uriType"/> is <see langword="null"/> .</exception>
            <remarks>
               <para>URI-style content types are commonly used for XML 
                  namespaces.</para>
            </remarks>
            <example>
               <para>This example creates a ContentType corresponding to the SOAP 1.1 
                  Envelope XML namespace.</para>
               <code lang="C#">
            Uri u = new Uri("http://schemas.xmlsoap.org/soap/envelope/");
            ContentType c = new ContentType(u);
               </code>
            </example>
        </member>
        <member name="P:System.MessageBus.ContentType.IsMediaType">
            <summary>
               <para>Gets whether this ContentType is a MIME media type.</para>
            </summary>
            <value>
            <para><see langword='true'/> if the ContentType is a MIME media type; otherwise, 
            <see langword='false'/>.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.ContentType.IsUriType">
            <summary>
               <para>Gets whether this ContentType is a URI-style content type.</para>
            </summary>
            <value>
            <para><see langword='true'/> if the ContentType 
               is a URI-style type; otherwise, <see langword='false'/>
               .</para>
            </value>
            <example>
               <para>This example illustrates testing the type of a MIME and a URI-style 
                  type.</para>
               <code lang='C#'>
            Uri u = new Uri("http://schemas.xmlsoap.org/soap/envelope/");
            ContentType uContent = new ContentType(u);
            ContentType mContent = new ContentType("image/jpeg");
            uContent.IsUriType; // true
            mContent.IsUriType; // false
               </code>
            </example>
        </member>
        <member name="P:System.MessageBus.ContentType.MediaType">
            <summary>
               <para>The MIME media type of the content.</para>
            </summary>
            <value>
               <para>A string representing the MIME media type of the content.</para>
            </value>
            <exception cref="T:System.InvalidOperationException">If the ContentType is not a MIME media type.</exception>
        </member>
        <member name="P:System.MessageBus.ContentType.UriType">
            <summary>
            <para>The <see cref="T:System.Uri"/> that designates the type of the content.</para>
            </summary>
            <value>
               <para>A string representing the URI-style type of the content. </para>
            </value>
            <exception cref="T:System.InvalidOperationException">If the ContentType is not a URI-style type.</exception>
        </member>
        <member name="T:System.MessageBus.PortExtension">
            <summary>
               <para>Defines behavior of Port channels.</para>
            </summary>
            <remarks>
               <para>Abstractly, a PortExtension describes an aspect or 
                  cross-cutting concern of message processing for a <see cref="T:System.MessageBus.Port"/>. Concretely, a PortExtension
                  describes inputs to a <see cref="T:System.MessageBus.PipelineBuilder"/> for each of the channel types supported by a
               <see cref="T:System.MessageBus.Port"/> 
               . </para>
            <para>Specifically, there are three kinds of methods a PortExtension supports for 
               each channel type:</para>
            <list type="table"><listheader>
               <term>Method</term>
               <description>Does</description>
               <description>May be empty?</description>
               <description>Passed to</description>
            </listheader>
            <item>
               <term> GetXxxAliases</term>
            <description>Returns a list of <see cref="T:System.MessageBus.StageAlias"/>s (AKA refinements) the PortExtension 
               defines. These define new <see cref="T:System.MessageBus.Stage"/>s and their
               ordering.</description>
            <description>yes</description>
            <description><see cref="M:System.MessageBus.PipelineBuilder.#ctor"/></description>
            </item>
            <item>
               <term> GetXxxStages</term>
            <description>Returns <see cref="T:System.MessageBus.Stage"/>s that the PortExtension actually adds 
            <see cref="T:System.MessageBus.IMessageHandler"/>s to. Some <see cref="T:System.MessageBus.Stage"/> 
            s may be unused by a particular
            PortExtension.</description>
            <description>yes</description>
            <description><see cref="M:System.MessageBus.PipelineBuilder.#ctor"/></description>
            </item>
            <item>
               <term> GetXxxHandlers</term>
            <description>Returns <see cref="T:System.MessageBus.IMessageHandler"/>s to add. There must be 
               exactly as many <see cref="T:System.MessageBus.IMessageHandler"/>s as <see cref="T:System.MessageBus.Stage"/>s returned by "get
               stages", and the order of <see cref="T:System.MessageBus.IMessageHandler"/>s corresponds to the
               order of the <see cref="T:System.MessageBus.Stage"/>s returned by "get stages". That is, the
               first <see cref="T:System.MessageBus.IMessageHandler"/> goes in the first <see cref="T:System.MessageBus.Stage"/>
               , the
               second in the second, and so on.</description>
            <description>yes</description>
            <description><see cref="M:System.MessageBus.PipelineBuilder.ToPipeline(System.MessageBus.IMessageHandler[])"/></description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.CreateForwardHandlers(System.Uri[],System.MessageBus.Message)">
            <summary>
            <para><see cref="T:System.MessageBus.IMessageHandler"/>s to add to a forward channel.</para>
            </summary>
            <param name="targets">The <see cref="T:System.Uri"/>s that are the forwarding destinations.</param>
            <param name=" message">The <see cref="T:System.MessageBus.Message"/> to be forwarded.</param>
            <returns>
            <para>An ordered list of zero or more <see cref="T:System.MessageBus.IMessageHandler"/>s to add to a forward channel.</para>
            </returns>
            <remarks>
            <para> There must be exactly as many <see cref="T:System.MessageBus.IMessageHandler"/>s as <see cref="T:System.MessageBus.Stage"/>s returned by
               GetForwardStages, and the order of <see cref="T:System.MessageBus.IMessageHandler"/>s must correspond to the
               order of the <see cref="T:System.MessageBus.Stage"/>s returned by GetForwardStages.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.CreateReceiveHandlers">
            <summary>
            <para><see cref="T:System.MessageBus.IMessageHandler"/>s to add to the ReceiveChannel.</para>
            </summary>
            <returns>
            <para>An ordered list of zero or more <see cref="T:System.MessageBus.IMessageHandler"/>s to add to the ReceiveChannel. </para>
            </returns>
            <remarks>
            <para>There must be exactly as many <see cref="T:System.MessageBus.IMessageHandler"/>s as <see cref="T:System.MessageBus.Stage"/>s 
               returned by GetReceiveStages, and the order of <see cref="T:System.MessageBus.IMessageHandler"/>s must correspond to the order of the <see cref="T:System.MessageBus.Stage"/>s
               returned by GetReceiveStages.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.CreateReceiveStatusHandlers">
            <summary>
            <para><see cref="T:System.MessageBus.IMessageHandler"/>s to add to the ReceiveStatusChannel.</para>
            </summary>
            <returns>
            <para>An ordered list of zero or more <see cref="T:System.MessageBus.IMessageHandler"/>s to add to the ReceiveStatusChannel. </para>
            </returns>
            <remarks>
            <para>There must be exactly as many <see cref="T:System.MessageBus.IMessageHandler"/>s as <see cref="T:System.MessageBus.Stage"/>s 
               returned by GetReceiveStatusStages, and the order of <see cref="T:System.MessageBus.IMessageHandler"/>s must correspond to the order of the <see cref="T:System.MessageBus.Stage"/>s
               returned by GetReceiveStatusStages.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.CreateReverseHandlers(System.MessageBus.Message)">
            <summary>
            <para><see cref="T:System.MessageBus.IMessageHandler"/>s to add to a reverse channel.</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to be sent back on the reverse channel.</param>
            <returns>
            <para>An ordered list of zero or more <see cref="T:System.MessageBus.IMessageHandler"/>s to add to a reverse channel.</para>
            </returns>
            <remarks>
            <para>There must be exactly as many <see cref="T:System.MessageBus.IMessageHandler"/>s as <see cref="T:System.MessageBus.Stage"/>s 
               returned by GetReverseStages, and the order of <see cref="T:System.MessageBus.IMessageHandler"/>s must correspond to the order of the <see cref="T:System.MessageBus.Stage"/>s
               returned by GetReverseStages.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.CreateSendHandlers(System.Uri)">
            <summary>
            <para><see cref="T:System.MessageBus.IMessageHandler"/>s to add to a send channel.</para>
            </summary>
            <param name="to">The <see cref="T:System.Uri"/> that is the destination for messages sent on the channel.</param>
            <returns>
            <para>An ordered list of zero or more <see cref="T:System.MessageBus.IMessageHandler"/>s to add to a send channel.</para>
            </returns>
            <remarks>
            <para>There must be exactly as many <see cref="T:System.MessageBus.IMessageHandler"/>s as <see cref="T:System.MessageBus.Stage"/>s 
               returned by GetSendStages, and the order of <see cref="T:System.MessageBus.IMessageHandler"/>s must correspond to the order of the <see cref="T:System.MessageBus.Stage"/>s
               returned by GetSendStages.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.CreateSendStatusHandlers">
            <summary>
            <para><see cref="T:System.MessageBus.IMessageHandler"/>s to add to the SendStatusChannel.</para>
            </summary>
            <returns>
            <para>An ordered list of zero or more <see cref="T:System.MessageBus.IMessageHandler"/> s to add to the SendStatusChannel.</para>
            </returns>
            <remarks>
            <para>There must be exactly as many <see cref="T:System.MessageBus.IMessageHandler"/>s as <see cref="T:System.MessageBus.Stage"/>s 
               returned by GetSendStatusStages, and the order of <see cref="T:System.MessageBus.IMessageHandler"/>s must correspond to the order of the <see cref="T:System.MessageBus.Stage"/>s
               returned by GetSendStatusStages.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.GetForwardAliases">
            <summary>
            <para><see cref="T:System.MessageBus.StageAlias"/>es for a forward channel.</para>
            </summary>
            <returns>
            <para>A list of zero or more <see cref="T:System.MessageBus.StageAlias"/>es.</para>
            </returns>
            <remarks>
            <para>These define refinements of <see cref="T:System.MessageBus.Stage"/>s for a forward channel.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.GetForwardStages">
            <summary>
            <para>Forward channel <see cref="T:System.MessageBus.Stage"/>s this PortExtension adds 
            <see cref="T:System.MessageBus.IMessageHandler"/>s to.</para>
            </summary>
            <returns>
            <para>A list of zero or more <see cref="T:System.MessageBus.Stage"/>s.</para>
            </returns>
            <remarks>
            <para>Returns <see cref="T:System.MessageBus.Stage"/>s of a forward channel that the PortExtension 
               actually adds <see cref="T:System.MessageBus.IMessageHandler"/>s to.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.GetReceiveAliases">
            <summary>
            <para><see cref="T:System.MessageBus.StageAlias"/>es for the ReceiveChannel.</para>
            </summary>
            <returns>
            <para>A list of zero or more <see cref="T:System.MessageBus.StageAlias"/>es.</para>
            </returns>
            <remarks>
            <para>These define refinements of <see cref="T:System.MessageBus.Stage"/>s for the ReceiveChannel.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.GetReceiveStages">
            <summary>
            <para>ReceiveChannel <see cref="T:System.MessageBus.Stage"/>s this PortExtension adds <see cref="T:System.MessageBus.IMessageHandler"/>s to.</para>
            </summary>
            <returns>
            <para>A list of zero or more <see cref="T:System.MessageBus.Stage"/>s.</para>
            </returns>
            <remarks>
            <para>Returns <see cref="T:System.MessageBus.Stage"/>s of the ReceiveChannel that the PortExtension 
               actually adds <see cref="T:System.MessageBus.IMessageHandler"/>s to.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.GetReceiveStatusAliases">
            <summary>
            <para><see cref="T:System.MessageBus.StageAlias"/>es for the ReceiveStatusChannel.</para>
            </summary>
            <returns>
            <para>A list of zero or more <see cref="T:System.MessageBus.StageAlias"/>es.</para>
            </returns>
            <remarks>
            <para>These define refinements of <see cref="T:System.MessageBus.Stage"/>s for the ReceiveStatusChannel.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.GetReceiveStatusStages">
            <summary>
            <para>ReceiveStatusChannel <see cref="T:System.MessageBus.Stage"/>s this PortExtension adds <see cref="T:System.MessageBus.IMessageHandler"/>s to.</para>
            </summary>
            <returns>
            <para>A list of zero or more <see cref="T:System.MessageBus.Stage"/>s.</para>
            </returns>
            <remarks>
            <para>Returns <see cref="T:System.MessageBus.Stage"/>s of the ReceiveStatusChannel that the 
               PortExtension actually adds <see cref="T:System.MessageBus.IMessageHandler"/>s to.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.GetReverseAliases">
            <summary>
            <para><see cref="T:System.MessageBus.StageAlias"/>es for a reverse channel.</para>
            </summary>
            <returns>
            <para>A list of zero or more <see cref="T:System.MessageBus.StageAlias"/>es.</para>
            </returns>
            <remarks>
            <para>These define refinements of <see cref="T:System.MessageBus.Stage"/>s for a reverse channel.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.GetReverseStages">
            <summary>
            <para>Reverse channel <see cref="T:System.MessageBus.Stage"/>s this PortExtension adds <see cref="T:System.MessageBus.IMessageHandler"/>s to.</para>
            </summary>
            <returns>
            <para>A list of zero or more <see cref="T:System.MessageBus.Stage"/>s.</para>
            </returns>
            <remarks>
            <para>Returns <see cref="T:System.MessageBus.Stage"/>s of a reverse channel that the PortExtension 
               actually adds <see cref="T:System.MessageBus.IMessageHandler"/>s to.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.GetSendAliases">
            <summary>
            <para><see cref="T:System.MessageBus.StageAlias"/>es for a send channel.</para>
            </summary>
            <returns>
            <para>A list of zero or more <see cref="T:System.MessageBus.StageAlias"/>es.</para>
            </returns>
            <remarks>
            <para>These define refinements of <see cref="T:System.MessageBus.Stage"/>s for a send channel.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.GetSendStages">
            <summary>
            <para>Send channel <see cref="T:System.MessageBus.Stage"/>s this PortExtension adds <see cref="T:System.MessageBus.IMessageHandler"/>s to.</para>
            </summary>
            <returns>
            <para>A list of zero or more <see cref="T:System.MessageBus.Stage"/>s.</para>
            </returns>
            <remarks>
            <para>Returns <see cref="T:System.MessageBus.Stage"/>s of a send channel that the PortExtension 
               actually adds <see cref="T:System.MessageBus.IMessageHandler"/>s to.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.GetSendStatusAliases">
            <summary>
            <para><see cref="T:System.MessageBus.StageAlias"/>es for the SendStatusChannel.</para>
            </summary>
            <returns>
            <para>A list of zero or more <see cref="T:System.MessageBus.StageAlias"/>es.</para>
            </returns>
            <remarks>
            <para>These define refinements of <see cref="T:System.MessageBus.Stage"/>s for the SendStatusChannel.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.GetSendStatusStages">
            <summary>
            <para>SendStatusChannel <see cref="T:System.MessageBus.Stage"/>s this PortExtension adds <see cref="T:System.MessageBus.IMessageHandler"/>s to.</para>
            </summary>
            <returns>
            <para>A list of zero or more <see cref="T:System.MessageBus.Stage"/>s.</para>
            </returns>
            <remarks>
            <para>Returns <see cref="T:System.MessageBus.Stage"/>s of the SendStatusChannel that the 
               PortExtension actually adds <see cref="T:System.MessageBus.IMessageHandler"/>s to.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.OnClosed">
            <summary>
               <para>Called when the Port has closed.</para>
            </summary>
            <remarks>
               <para> The OnClosed method is called when all the 
                  work of closing the Port has completed.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.OnClosing">
            <summary>
               <para>Called when the Port has begun to close.</para>
            </summary>
            <remarks>
               <para>When the Port is closed, the OnClosing method is called before channels and 
                  other components are deactivated. The OnClosed method is called when all the
                  work of closing the Port has completed.</para>
               <para>Execution Sequence:</para>
               <list type='number'><item>
                  <term>
                     Call Port.Close()</term>
               </item>
               <item>
                  <term>
                     Call PortExtension.OnClosing()</term>
               </item>
               <item>
                  <term>Return PortExtension.OnClosing()</term>
               </item>
               <item>
                  <term>Deactivate channels etc.</term>
               </item>
               <item>
                  <term>Call PortExtension.OnClosed()</term>
               </item>
               <item>
                  <term>Return PortExtension.OnClosed()</term>
               </item>
               <item>
                  <term>
                     Return Port.Close()</term>
               </item>
            </list>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.OnOpened">
            <summary>
               <para>Called when the Port has opened.</para>
            </summary>
            <remarks>
               <para>The OnOpened method is called when all the work of opening the Port has 
                  completed.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PortExtension.OnOpening">
            <summary>
               <para>Called when the Port has begun to open.</para>
            </summary>
            <remarks>
               <para>When the Port is opened, the OnOpening method is called before channels and 
                  other components are activated. The OnOpened method is called when all the work
                  of opening the Port has completed.</para>
               <para>Execution sequence:</para>
               <list type='number'><item>
                  <term>Call Port.Open()</term>
               </item>
               <item>
                  <term>Call PortExtension.OnOpening()</term>
               </item>
               <item>
                  <term>Return PortExtension.OnOpening()</term>
               </item>
               <item>
                  <term>Activate channels etc.</term>
               </item>
               <item>
                  <term>Call PortExtension.OnOpened()</term>
               </item>
               <item>
                  <term>Return PortExtension.OnOpened()</term>
               </item>
               <item>
                  <term>Return Port.Open()</term>
               </item>
            </list>
            </remarks>
        </member>
        <member name="P:System.MessageBus.PortExtension.Port">
            <summary>
            <para>Gets the <see cref="T:System.MessageBus.Port"/> that this PortExtension was added to.</para>
            </summary>
            <value>
            <para>The <see cref="T:System.MessageBus.Port"/> that this PortExtension was added to.</para>
            </value>
            <remarks>
            <para>When a PortExtension is added to a <see cref="T:System.MessageBus.Port"/>, the Port property is set 
               with that <see cref="T:System.MessageBus.Port"/>.</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.DimeEncoding">
            <summary>
               <para>Message encoding for DIME records.</para>
            </summary>
            <remarks>
            <para>The DIME <see cref="T:System.MessageBus.MessageEncoding"/> identifies the DIME record encoding. DIME 
               records carry application payloads of arbitrary type. The encoding of the
               payload is represented by the <see cref="P:System.MessageBus.DimeEncoding.TypeEncoding"/> property.</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.MessageEncoding">
            <summary>
               <para>Base class for message encodings.</para>
            </summary>
            <remarks>
               <para>When a message is transmitted to another endpoint, it must be encoded into a suitable form. 
                  A message encoding is that form. </para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.MessageEncoding.ContentType">
            <summary>
               <para>Gets the descriptor for the specific message encoding.</para>
            </summary>
            <value>
            <para>A <see cref="T:System.MessageBus.ContentType"/> describing the specific message encoding.</para>
            </value>
        </member>
        <member name="M:System.MessageBus.DimeEncoding.#ctor(System.MessageBus.MessageEncoding)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.DimeEncoding"/> class.</para>
            </summary>
            <param name="typeEncoding">The <see cref="T:System.MessageBus.MessageEncoding"/> for the DIME payload. </param>
            <exception cref="T:System.ArgumentNullException">if <paramref name="typeEncoding"/> is null.</exception>
        </member>
        <member name="P:System.MessageBus.DimeEncoding.ContentType">
            <summary>
               <para>Gets the media type.</para>
            </summary>
            <value>
               <para>new ContentType("application/dime")</para>
            </value>
        </member>
        <member name="P:System.MessageBus.DimeEncoding.TypeEncoding">
            <summary>
            <para>Gets the <see cref="T:System.MessageBus.MessageEncoding"/> of the DIME payload.</para>
            </summary>
            <value>
            <para>The <see cref="T:System.MessageBus.MessageEncoding"/> of the DIME payload.</para>
            </value>
        </member>
        <member name="T:System.MessageBus.Dispatcher">
            <summary>
            <para>Encapsulates an <see cref="T:System.MessageBus.IMessageHandler"/> and provides explicit 
               concurrency control.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Dispatcher.#ctor">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.Dispatcher"/> class.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Dispatcher.BeginProcessMessage(System.MessageBus.Message,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for ProcessMessage.</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to process</param>
            <param name=" callback">See Asynchronous Design Pattern</param>
            <param name=" state">See Asynchronous Design Pattern</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.Dispatcher.EndProcessMessage(System.IAsyncResult)">
            <summary>
               <para>Asynchronous end for Process Message.</para>
            </summary>
            <param name="result">See Asynchronous Design Pattern</param>
            <returns>
            <para><see langword="true"/> if the <see cref="T:System.MessageBus.IMessageHandler"/> has not and will not call 
            <see cref="M:System.MessageBus.Message.Close"/> ; otherwise, 
            <see langword="false"/>.</para>
            </returns>
            <remarks>
            <para>See <see cref="T:System.MessageBus.IMessageHandler"/> for details.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Dispatcher.ProcessMessage(System.MessageBus.Message)">
            <summary>
            <para>Processes a <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to process</param>
            <returns>
            <para><see langword="true"/> if the <see cref="T:System.MessageBus.IMessageHandler"/> has not and will not call 
            <see cref="M:System.MessageBus.Message.Close"/> ; otherwise, 
            <see langword="false"/>.</para>
            </returns>
            <remarks>
            <para>See <see cref="T:System.MessageBus.IMessageHandler"/> for details.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Dispatcher.CompletesSynchronously">
            <summary>
               <para>Gets whether the implementation of ProcessMessage is 
                  inherently synchronous.</para>
            </summary>
            <value>
            <para><see langword="true"/> 
            if the implementation of ProcessMessage is inherently
            synchronous; otherwise, <see langword="false"/>.</para>
            </value>
            <remarks>
            <para>See <see cref="T:System.MessageBus.IMessageHandler"/> for details.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Dispatcher.Concurrency">
            <summary>
               <para>Gets and sets the maximum number of threads that may access the 
               <see cref="T:System.MessageBus.IMessageHandler"/> concurrently.</para>
            </summary>
            <value>
               <para>The default is 1.</para>
            </value>
            <exception cref="T:System.ArgumentOutOfRangeException">If set to &lt; 1</exception>
            <remarks>
               <para>The Concurrency property specifies the maximum number of threads that may 
                  access the encapsulated <see cref="T:System.MessageBus.IMessageHandler"/> concurrently. A value of 1 corresponds to
                  single-threaded access. This is useful to expose non-thread safe,
                  single-threaded code as an <see cref="T:System.MessageBus.IMessageHandler"/>. </para>
               <para>This property may be set to values greater than 1 to 
                  load balance across the threads. </para>
            </remarks>
            <example>
            <para>The following sample shows how to expose a non-thread safe <see cref="T:System.MessageBus.IMessageHandler"/> h: </para>
            <code lang="C#">
            // SyncMessageHandler h;
            Dispatcher d = new Dispatcher();
            d.Handler = h;
            // d.Concurrency defaults to 1
            // Use d as the IMessageHandler instead of h
            </code>
            </example>
        </member>
        <member name="P:System.MessageBus.Dispatcher.Handler">
            <summary>
            <para>Gets and sets the encapsulated <see cref="T:System.MessageBus.IMessageHandler"/> .</para>
            </summary>
            <remarks>
            <para>Dispather implements <see cref="T:System.MessageBus.IMessageProducer"/>.</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.EmptyContent">
            <summary>
            <para>Represents empty <see cref="T:System.MessageBus.MessageContent"/> .</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.MessageContent">
            <summary>
            <para>Base class for representing content of a <see cref="T:System.MessageBus.Message"/>.</para>
            </summary>
            <remarks>
            <para>MessageContent is <see cref="T:System.MessageBus.Message"/> data that is in the domain 
               of the application; a <see cref="T:System.MessageBus.Message"/> always has MessageContent, though the
               MessageContent may be the pre-defined, <see cref="T:System.MessageBus.EmptyContent"/>type.</para>
            <para>Unlike <see cref="T:System.MessageBus.MessageHeader"/>s, MessageContent may be 
            streamed and thus unbounded in size.</para>
            <para>When a message is received, its MessageContent is 
               created by the <see cref="T:System.MessageBus.Transports.Transport"/> and is a read-once, forward-only
            <see cref="T:System.IO.Stream"/>. When 
               TCP is the underlying <see cref="T:System.MessageBus.Transports.Transport"/>, the <see cref="T:System.MessageBus.Transports.Transport"/> implementation
               reads content out of TCP buffers ahead of the application up to a configurable
               quota; the rate at which the application pulls data is directly reflected into
               TCP's flow control mechanism.</para>
            <para>For convenience, GetXmlReader and GetObject allow 
               accessing MessageContent as an <see cref="T:System.Xml.XmlReader"/> or <see langword="object"/>, respectively. Because of the underlying conversions,
               MessageContent should be accessed with only one of these methods.</para>
            <para>Because MessageContent is independent of a specific 
            <see cref="T:System.MessageBus.Transports.Transport"/> and wire format, it must be 
               possible to serialize the MessageContent as needed for transmission over a
               specific <see cref="T:System.MessageBus.Transports.Transport"/> and format. WriteTo serializes the
               MessageContent into a <see cref="T:System.IO.Stream"/> or <see cref="T:System.Xml.XmlWriter"/>. To serialize XML MessageContent, one gets an
            <see cref="T:System.Xml.XmlWriter"/> from the 
               MessageContent. To serialize other MessageContent, one gets a
            <see cref="T:System.IO.Stream"/> 
            from
            the MessageContent.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.MessageContent.Clone">
            <summary>
               <para>Creates a new MessageContent that is a copy of the current instance.</para>
            </summary>
            <remarks>
               <para>Whether the clone is shallow or deep depends on a specific subtype of 
                  MessageContent.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.MessageContent.GetObject(System.Type)">
            <summary>
               <para>Converts the MessageContent into an 
               <see langword="object"/> .</para>
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the <see langword="object"/> to convert the MessageContent into</param>
            <returns>
            <para>An <see langword="object"/> of the given <see cref="T:System.Type"/> that represents the MessageContent.</para>
            </returns>
            <remarks>
            <para>GetObject returns an in-memory <see langword="object"/>. 
               The <see langword="object"/> is created, if necessary, by converting the current
               form of the MessageContent into an <see langword="object"/>. If the
               MessageContent is streamed, accessing it as an <see langword="object"/> will
               involve buffering the MessageContent into memory; this should be used with
               caution. In extreme cases, this may involve serializing and de-serializing the
               MessageContent. This method raises an exception if the MessageContent cannot be
               parsed as the requested type.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.MessageContent.GetXmlReader">
            <summary>
            <para>Creates an <see cref="T:System.Xml.XmlReader"/> to access MessageContent.</para>
            </summary>
            <remarks>
            <para>Calling GetXmlReader should always return an <see cref="T:System.Xml.XmlReader"/> positioned at the beginning of the 
               MessageContent; if a call cannot produce a correctly-positioned <see cref="T:System.Xml.XmlReader"/>, it
               raises an <see cref="T:System.Exception"/>.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.MessageContent.WriteTo(System.Xml.XmlWriter)">
            <summary>
            <para>Serialize the MessageContent using the <see cref="T:System.Xml.XmlWriter"/> ’s encoding.</para>
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/>to serialize the properties into</param>
        </member>
        <member name="P:System.MessageBus.MessageContent.IsEmpty">
            <summary>
               <para>Gets whether the MessageContent is empty.</para>
            </summary>
            <value>
            <para><see langword='true'/> if the MessageContent is empty; otherwise, 
            <see langword='false'/>. The default is <see langword='false'/>.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.MessageContent.IsException">
            <summary>
            <para>Gets whether the MessageContent is an <see cref="T:System.Exception"/> .</para>
            </summary>
            <value>
            <para><see langword="true"/> if the MessageContent is an 
            <see cref="T:System.Exception"/>; otherwise, 
            <see langword="false"/>. The default is <see langword="false"/> .</para>
            </value>
        </member>
        <member name="M:System.MessageBus.EmptyContent.#ctor">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.EmptyContent"/> class.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.EmptyContent.Clone">
            <summary>
               <para>Returns the same instance of EmptyContent.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.EmptyContent.GetObject(System.Type)">
            <summary>
               <para>Converts the MessageContent into an 
               <see langword="object"/> .</para>
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the <see langword="object"/> to convert the EmptyContent into</param>
            <returns>
            <para><see langword="null"/>
            </para>
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="type"/> is <see langword="null"/></exception>
        </member>
        <member name="M:System.MessageBus.EmptyContent.GetXmlReader">
            <summary>
            <para>Creates an <see cref="T:System.Xml.XmlReader"/> to access EmptyContent.</para>
            </summary>
            <remarks>
            <para>Returns an <see cref="T:System.Xml.XmlReader"/> that is at end of file.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.EmptyContent.WriteTo(System.Xml.XmlWriter)">
            <summary>
               <para>Serialize the EmptyContent.</para>
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/> to serialize the EmptyContent into</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="writer"/> is <see langword="null"/></exception>
            <remarks>
               <para>Does nothing.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.EmptyContent.IsEmpty">
            <summary>
               <para>Gets whether the MessageContent is empty.</para>
            </summary>
            <value>
            <para><see langword='true'/></para>
            </value>
        </member>
        <member name="T:System.MessageBus.ExceptionContent">
            <summary>
            <para> Represents an <see cref="T:System.Exception"/> as <see cref="T:System.MessageBus.MessageContent"/> .</para>
            </summary>
            <remarks>
               <para>By convention, a network fault message is represented as 
               <see cref="T:System.MessageBus.Message"/> 
               with ExceptionContent.</para>
            <para>A base class distinct from <see cref="T:System.MessageBus.ObjectContent"/> 
            is provided because the ExceptionContent has a particular XML
            format.</para>
            <para>Note that whether a <see cref="T:System.MessageBus.Message"/> has a <see cref="T:System.MessageBus.MessageContent"/> of type <see cref="T:System.MessageBus.ExceptionContent"/> is orthogonal to whether the 
            <see cref="T:System.MessageBus.Message"/> has a 
            <see cref="T:System.MessageBus.MessageHeader"/> of type <see cref="T:System.MessageBus.ExceptionHeader"/>. Processing of the <see cref="T:System.MessageBus.Message"/> on this <see cref="T:System.MessageBus.Port"/> may have 
            raised an <see cref="T:System.Exception"/> (thus adding an <see cref="T:System.MessageBus.ExceptionHeader"/>), or the
            <see cref="T:System.MessageBus.Message"/> may be 
            a fault sent by another <see cref="T:System.MessageBus.Port"/> (thus having <see cref="T:System.MessageBus.MessageContent"/> of type <see cref="T:System.MessageBus.ExceptionContent"/>), or both. </para>
            </remarks>
            <example>
               <code lang="C#">
            // Message m;
            // Is the message a fault?
            if (m.Content.IsException)
            {
              // It has exception content.
            }
               </code>
            </example>
        </member>
        <member name="M:System.MessageBus.ExceptionContent.#ctor(System.MessageBus.MessageException)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.ExceptionContent"/> class.</para>
            </summary>
            <param name="exception">The <see cref="T:System.Exception"/> to encapsulate as <see cref="T:System.MessageBus.MessageContent"/> .</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="exception"/> is <see langword="null"/></exception>
        </member>
        <member name="M:System.MessageBus.ExceptionContent.Clone">
            <summary>
               <para>Creates a new ExceptionContent that is a copy of the current instance.</para>
            </summary>
            <remarks>
               <para>Makes a deep clone of the ExceptionContent.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.ExceptionContent.GetObject(System.Type)">
            <summary>
            <para>Converts ExceptionContent into an <see langword="object"/> .</para>
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the <see langword="object"/> to convert the ExceptionContent into</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="type"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidCastException">If <paramref name="type"/> is not an <see cref="T:System.Exception"/></exception>
        </member>
        <member name="M:System.MessageBus.ExceptionContent.WriteTo(System.Xml.XmlWriter)">
            <summary>
            <para>Serialize the ExceptionContent using the <see cref="T:System.Xml.XmlWriter"/> ’s encoding.</para>
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/> to serialize the properties into</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="writer"/> is <see langword="null"/></exception>
        </member>
        <member name="P:System.MessageBus.ExceptionContent.IsException">
            <summary>
            <para>Gets whether the MessageContent is an <see cref="T:System.Exception"/> .</para>
            </summary>
            <value>
            <para><see langword="true"/></para>
            </value>
        </member>
        <member name="T:System.MessageBus.ExceptionHandler">
            <summary>
               <para> 
                  Base class for message handlers that catch exceptions.</para>
            </summary>
            <remarks>
               <para>This base class simplifies catching exceptions given both synchronous and 
                  asynchronous message processing calling patterns. It will catch both synchronous
                  and asynchronous message handler exceptions and funnel them through a single
                  call -- Process Exception -- which may be overridden. To catch exceptions,
                  override (Begin / End) Process Message and (Begin / End) Process Exception, and
                  when an exception is raised, the latter will be called with the appropriate
                  a/synchronous calling pattern.</para>
               <para>Like Synchronous Message Handler, you only have to provide an implementation 
                  for the synchronous Process Message; a default asynchronous Begin / End Process
                  Message are provided.</para>
               <para>The base implementation discards the exception and closes the message.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.ExceptionHandler.#ctor(System.MessageBus.IMessageHandler)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.ExceptionHandler"/> class.</para>
            </summary>
            <param name="handler">The message handler to wrap to catch exceptions that are raised.</param>
        </member>
        <member name="M:System.MessageBus.ExceptionHandler.BeginProcessException(System.Exception,System.MessageBus.Message,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for Process Exception.</para>
            </summary>
            <param name='exception'>The exception that was raised.</param>
            <param name=' message'>The message that was being processed when the exception was raised.</param>
            <param name=' callback'>See Asynchronous Design Pattern.</param>
            <param name=' state'>See Asynchronous Design Pattern.</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.ExceptionHandler.BeginProcessMessage(System.MessageBus.Message,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for ProcessMessage.</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to process</param>
            <param name=" callback">See Asynchronous Design Pattern</param>
            <param name=" object">See Asynchronous Design Pattern</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.ExceptionHandler.EndProcessException(System.IAsyncResult)">
            <summary>
               <para> Asynchronous end for Process Exception.</para>
            </summary>
            <param name='result'>See Asynchronous Design Pattern.</param>
            <returns>
               <para>Returns false if the message was closed or true if the message was not 
                  closed.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.ExceptionHandler.EndProcessMessage(System.IAsyncResult)">
            <summary>
               <para>Asynchronous end for ProcessMessage.</para>
            </summary>
            <param name="result">See Asynchronous Design Pattern</param>
            <returns>
            <para><see langword="true"/> if the <see cref="T:System.MessageBus.IMessageHandler"/> has not and will not call <see cref="M:System.MessageBus.Message.Close"/>; otherwise, <see langword="false"/> .</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.ExceptionHandler.ProcessException(System.Exception,System.MessageBus.Message)">
            <summary>
               <para>Callback to process exceptions that are caught during 
                  (Begin / End) Process Message.</para>
            </summary>
            <returns>
               <para>Returns false if the message was closed or true if the message was not 
                  closed.</para>
            </returns>
            <remarks>
               <para>The base implementation discards the exception and closes the message.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.ExceptionHandler.ProcessMessage(System.MessageBus.Message)">
            <summary>
            <para>Processes a <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to process</param>
            <returns>
            <para><see langword="true"/> if the <see cref="T:System.MessageBus.IMessageHandler"/> has not and will not call <see cref="M:System.MessageBus.Message.Close"/>; otherwise, <see langword="false"/>. </para>
            </returns>
        </member>
        <member name="P:System.MessageBus.ExceptionHandler.CompletesSynchronously">
            <summary>
               <para>Whether the underlying implementation is synchronous 
                  (true) or asynchronous (false).</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.ExceptionHeader">
            <summary>
            <para>The <see cref="T:System.Exception"/> that was raised when a <see cref="T:System.MessageBus.Message"/> was processed.</para>
            </summary>
            <remarks>
            <para>If an <see cref="T:System.MessageBus.IMessageHandler"/> in the <see cref="T:System.MessageBus.Pipeline"/> 
            underlying a <see cref="T:System.MessageBus.Port"/>'s send or receive channel raises an <see cref="T:System.Exception"/>, then a new ExceptionHeader is added to
            the <see cref="T:System.MessageBus.Message"/> to
            describe the <see cref="T:System.Exception"/>,
            and the <see cref="T:System.MessageBus.Message"/> is processed by the appropriate status
            channel. (See <see cref="T:System.MessageBus.Port"/> for details.)</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.ExceptionHeader.#ctor(System.Exception)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.ExceptionHeader"/> class.</para>
            </summary>
            <param name="exception">The <see cref="T:System.Exception"/> that was raised when the <see cref="T:System.MessageBus.Message"/> was processed</param>
        </member>
        <member name="M:System.MessageBus.ExceptionHeader.Clone">
            <summary>
               <para>Creates a new ExceptionHeader that is a deep copy of the current 
                  instance.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.ExceptionHeader.Exception">
            <summary>
            <para>Gets the <see cref="T:System.Exception"/> that was raised when the <see cref="T:System.MessageBus.Message"/> was processed.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.FaultCode">
            <summary>
               <para> Base class for SOAP 1.2 Fault Codes.</para>
            </summary>
            <remarks>
               <para>Fault Codes are recursive. Each nested Fault Code is a kind of sub category and refines its parent Fault 
                  Code.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.FaultCode.#ctor(System.Uri,System.String)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.FaultCode"/> class.</para>
            </summary>
            <param name="ns">Namespace qualifier of the Fault Code.</param>
            <param name=" name">Unqualified identifier of the Fault Code.</param>
            <remarks>
               <para>Equivalent to FaultCode(ns, name, null).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.FaultCode.#ctor(System.Uri,System.String,System.MessageBus.FaultCode)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.FaultCode"/> class.</para>
            </summary>
            <param name="ns">Namespace qualifier of the Fault Code.</param>
            <param name=" name">Unqualified identifier for the Fault Code.</param>
            <param name=" subcode">Nested Fault Code.</param>
            <remarks>
               <para>Constructs a Fault Code that nests another Fault Code. The nested Fault Code 
                  is a refinement of its parent.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.FaultCode.CreateReceiverFaultCode(System.Uri,System.String)">
            <summary>
            Creates a FaultCode with the SOAP Receiver Code and the
            supplied Subcode.
            </summary>
            <param name="ns">The Uri of the namespace of the Subcode</param>
            <param name="subCode">The string representing the Subcode</param>
            <returns>A FaultCode for a SOAP Receiver Fault with a Subcode.</returns>
        </member>
        <member name="M:System.MessageBus.FaultCode.CreateSenderFaultCode(System.Uri,System.String)">
            <summary>
            Creates a FaultCode with the SOAP Sender Code and the
            supplied Subcode.
            </summary>
            <param name="ns">The Uri of the namespace of Subcode</param>
            <param name="subCode">The string representing the Subcode</param>
            <returns>A FaultCode for a SOAP Sender Fault with a Subcode</returns>
        </member>
        <member name="P:System.MessageBus.FaultCode.Namespace">
            <summary>
               <para>Gets the namespace qualifier of the Fault Code.</para>
            </summary>
            <remarks>
               <para>Typically this is an XML namespace.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.FaultCode.Name">
            <summary>
               <para>Gets the unqualified identifier for the Fault Code.</para>
            </summary>
            <remarks>
               <para>Typically this is an NCName.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.FaultCode.Subcode">
            <summary>
               <para>Gets the sub category of the Fault Code.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Filter">
            <summary>
            <para>The base XPath 1.0 filter class. Used by the <see cref="T:System.MessageBus.FilterTable"/>, <see cref="T:System.MessageBus.FilterHierarchy"/>, and <see cref="T:System.MessageBus.FilterHierarchyCache"/> .</para>
            </summary>
            <threadsafe>
               <para> Single threaded.</para>
            </threadsafe>
            <remarks>
               <para>The Filter is the base element of the MessageBus's filter engine. It 
                  represents a single XPath 1.0 query. <see cref="T:System.MessageBus.Message"/> objects can be matched against a single XPath
                  query using the Filter or a set of Filters can be added to a <see cref="T:System.MessageBus.FilterTable"/>,
               <see cref="T:System.MessageBus.FilterHierarchy"/>, or <see cref="T:System.MessageBus.FilterHierarchyCache"/> where Messages can be matched more efficently 
                  against the entire set. </para>
               <para>The XPath query is not compiled (and thus validated) when the Filter is constucted. It not 
                  compiled until it is matched against a message or added to a FilterTable,
                  FilterHierarchy, or FilterHierarchyCache.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Filter.#ctor(System.String)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.Filter"/> 
            class.</para>
            </summary>
            <param name="xpath">An XPath string confoming to the XPath 1.0 specificaiton</param>
            <exception cref="T:System.ArgumentNullException">If the <paramref name="xpath"/> is null.</exception>
            <remarks>
               <para>Use this constructor to create a filter using and XPath 1.0 expresion without namespace prefixes. A filter created 
                  this way will only match infosets without namespace prefixes.</para>
                  <para> The XPath
                  expresion is not compiled until it is used to match a
                  message or added to a FilterTable, FilterHierarchy, or FilterHierarchyCache.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Filter.#ctor(System.String,System.Xml.XmlNamespaceManager)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.Filter"/> 
            class.</para>
            </summary>
            <param name="xpath">An XPath query string confoming to the XPath 1.0 specificaiton</param>
            <param name="namespaces">Use an XmlNamespaceManager to define the namespace prefixes used in the <paramref name="XPath"/> query</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="xpath"/> is null</exception>
            <remarks>
               <para>This constructor initializes a filter using an XPath containing namespace 
                  prefixes. </para>
               <para>Note: The XPath is not compiled until it is used to match a message or added to a FilterTable, FilterHierarchy, or FilterHierarchyCache.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Filter.Select(System.MessageBus.Message)">
            <summary>
            <para>Returns the properties matched by the <see cref="P:System.MessageBus.Filter.XPath"/> 
            .</para>
            </summary>
            <param name="message">Message to get properties from.</param>
            <returns>
               <para>Collection of properties extracted from the message.</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="message"/> is null.</exception>
            <remarks>
               <para> 
                  Select retuns selected objects without andy indication of their relative or absolute
                  positions within the message.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Filter.Match(System.MessageBus.Message)">
            <summary>
               <para>Return true if the filter matches the given message.</para>
            </summary>
            <param name="message">The message to match agains the filter.</param>
            <returns>
               <para>true if this filter matched</para>
            </returns>
            <exception cref="!:System.NullArgumentException"><paramref name="If message"/>is null</exception>
            <remarks>
               <para> The Filter matches the 
               <paramref name="message"/> if the result of the XPath query is true 
                  or if the result cast to a boolean using the rules of the XPath 1.0 boolean() function is true. By these rules, a non-empty node
                  set it will return true as will a non-empty string.</para>
               <para>Since this may compile the xpath, xpath exceptions may 
                  be thrown.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Filter.MatchAllFilter">
            <summary>
            <para>This static property gets a <see cref="T:System.MessageBus.Filter"/> instance that will match all messages.</para>
            </summary>
            <value>
            <para>A <see cref="T:System.MessageBus.Filter"/> instance that will match all messages.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.Filter.Namespaces">
            <summary>
            <para>Gets the <see cref="T:System.Xml.XmlNamespaceManager"/> that contains the prefix 
               definitions of the namespace prefixes used in the <see cref="P:System.MessageBus.Filter.XPath"/> .</para>
            </summary>
            <value>
               the <see cref="T:System.Xml.XmlNamespaceManager"/> passed in in the constructor. May be null.
            </value>
        </member>
        <member name="P:System.MessageBus.Filter.XPath">
            <summary>
               <para>Gets the XPath string that defines this filter.</para>
            </summary>
            <value>
               <para>The XPath string that defines this filter.</para>
            </value>
            <remarks>
               <para>The XPath is not compiled or verified until it is used to match a message 
                  thus this property may not be valid XPath.</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.FilterData">
            <summary>
            <para>The FilterData type assocites a <see cref="T:System.MessageBus.Filter"/> with
               any object.</para>
            </summary>
            <remarks>
               This class is used to create a contextual association
               between the filter and some application data. It is used in the <see cref="T:System.MessageBus.FilterTable"/>,
            <see cref="T:System.MessageBus.FilterHierarchy"/>, and <see cref="T:System.MessageBus.FilterHierarchyCache"/>. The Add method of each of these 
               classes returns a FilterData object constucted using the Filter and object
               parameters passed in. In each case, this FilterData instance can be used
               in the classes Remove method to remove the associated Filter form the
               collection.
            </remarks>
        </member>
        <member name="M:System.MessageBus.FilterData.#ctor(System.MessageBus.Filter,System.Object)">
            <summary>
               <para>The constructor takes a Filter and any object.</para>
            </summary>
            <param name="filter">A <see cref="T:System.MessageBus.Filter"/> .</param>
            <param name="data">Application data to be used in contextual associateion with the <paramref name="filter"/> .</param>
            <exception cref="!:System.NullArgumentException">If <paramref name="filter"/> is null</exception>
        </member>
        <member name="P:System.MessageBus.FilterData.Data">
            <summary>
            The contextual object associated with the Filter.
            </summary>
        </member>
        <member name="P:System.MessageBus.FilterData.Filter">
            <summary>
            The Filter.
            </summary>
        </member>
        <member name="T:System.MessageBus.FilterDataCollection">
            <summary>
            <para>A collection of <see cref="T:System.MessageBus.FilterData"/> objects.</para>
            </summary>
            <threadsafe>
               <para>Single threaded.</para>
            </threadsafe>
        </member>
        <member name="M:System.MessageBus.FilterDataCollection.Add(System.MessageBus.FilterData)">
            <summary>
            Internal method only - add filterData to the collection
            </summary>
            <param name="filterData">filterData to add</param>
        </member>
        <member name="M:System.MessageBus.FilterDataCollection.Contains(System.MessageBus.FilterData)">
            <summary>
               <para>Test to see if the collection contains a specific object.</para>
            </summary>
            <param name='filterData'>The FilterData object to test for.</param>
            <returns>
               <para>Returns true if the collection contains the given object, otherwise false.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.FilterDataCollection.CopyTo(System.MessageBus.FilterData[],System.Int32)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.FilterDataCollection.GetEnumerator">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.FilterDataCollection.IndexOf(System.MessageBus.FilterData)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.FilterDataCollection.Remove(System.MessageBus.FilterData)">
            <summary>
            Internal method only. Public collection is read only
            </summary>
            <param name="filterData">filterData to remove</param>
        </member>
        <member name="M:System.MessageBus.FilterDataCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.FilterDataCollection.Count">
            <summary>
            The number of FilterData objects in the collection.
            </summary>
        </member>
        <member name="P:System.MessageBus.FilterDataCollection.Item(System.Int32)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.FilterDataCollection.System#Collections#ICollection#IsSynchronized">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.FilterDataCollection.System#Collections#ICollection#SyncRoot">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.FilterHierarchy">
            <summary>
            <para>Acts like a hierarchy of <see cref="!:System.MessageBus.FilterTables"/> 
            based on a common <see cref="!:System.MessageBus.message"/>
            URI.</para>
            </summary>
            <remarks>
               <para>The FilterHierarchy is useful to applications that 
                  organize filters around a URI found in each message. The destination
                  URI for instance. The FilterHierarcy allows an application to order filters in
                  a hierarchy based on a segment based prefix on the identified URI. Filters at the
                  same node hierarchy are not ordered. </para>
               <para>There are two ways to match messages agains the FilterHierarchy. </para>
               <para>(1) GetNodes() returns a collection of URI prefix nodes 
                  ordered from shortest to longest that represent all the nodes that could
                  match the message. The application may then call GetMatches() on each node to
                  get matching FilterData pairs. </para>
               <para>(2) GetMatches() walks the nodes and returns a FilterHierarchyMatchCollection 
                  collection that has already walked the nodes and gathered the matches for
                  you.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.FilterHierarchy.#ctor(System.MessageBus.Filter)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.FilterHierarchy"/> class.</para>
            </summary>
            <param name="hierarhcyUriPath">The XPath location of the <see cref="T:System.MessageBus.Message"/> URI to constuct the hierarchy around. This XPath will be applied to each Message matched against the constructed FilterHierarchy. If it returns a node set whoes first element is a URI, then this URI will be used to find matching hierarchy nodes. If does not return a node set or the first element is not a URI, then no results will be returned.</param>
            <exception cref="!:System.ArgumentNullExcpeiton">If <paramref name="hierarhcyUriPath"/> is null.</exception>
            <exception cref="!:System.ArgumentExceptoin">If the XPath is not selectable.</exception>
        </member>
        <member name="M:System.MessageBus.FilterHierarchy.Add(System.String,System.MessageBus.Filter,System.Object)">
            <summary>
               <para>Use the Add method to add a Filter and some associated data to a location in the hierarchy.</para>
            </summary>
            <param name="uri"><para>The location in the hierarchy to add the <see cref="T:System.MessageBus.Filter"/> , data pair. Represents a prefix of a URI.</para> <para> Must be one of the following: String.Empty, a scheme followed by a ":", or a valid URI.</para> <para>Anything after a "?" or "#" will be ignored.</para> <para>If no port is specified in the uri and it is a valid URI and it is from a scheme with a default port, then the default port is assumed. For example, "http://a.com" will only match messages where the hierarchyUriPath's URI has port 80 or no port. </para> <para>String.Empty designates the root node. All messges match the root node.</para></param>
            <param name="filter">The <see cref="T:System.MessageBus.Filter"/> to match against the messages that match the URI prefix.</param>
            <param name="data">The context data to return with matches.</param>
            <returns>
            <para>A FilterData object constructed from the <paramref name="filter"/> 
            and <paramref name="data"/> parameters that can be used to remove the filter from the Hierarchy.</para>
            </returns>
            <exception cref="!:System.NullArgumentAcception"><para>If <paramref name="uri"/> is null</para></exception>
            <exception cref="!:System.NullArgumentAcception">If <paramref name="filter"/> is null</exception>
        </member>
        <member name="M:System.MessageBus.FilterHierarchy.Add(System.String,System.MessageBus.FilterData)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.FilterHierarchy.GetMatches(System.MessageBus.Message)">
            <summary>
               <para>Matches a message against the Hierarchy and all filters 
                  at each matching node. </para>
            </summary>
            <param name="message">A Message to match against the FilterHierarchy.</param>
            <returns>
            <para>A <see cref="T:System.MessageBus.FilterHierarchyMatchCollection"/>. Will be and empty collection if there are no matches. 
               Each <see cref="T:System.MessageBus.FilterHierarchyMatch"/> represents a node in the hierarchy with
               matching Filters and contains the corresponding <see cref="T:System.MessageBus.FilterData"/>
               instances.</para>
            </returns>
            <exception cref="!:System.NullArgumentException">If <paramref name="message"/> is null.</exception>
            <remarks>
               <para>GetMatches retrieves a URI from the message using the HierarchyUriPath, finds the matching 
                  nodes, and collects all matching filters at each node. The results are grouped
                  and ordered by node, from shortest URI prefix to longest.</para>
               <para>Only nodes with matches will be returned.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.FilterHierarchy.GetNodes(System.MessageBus.Message)">
            <summary>
               <para>Returns the nodes matching a Message sorted from shortest 
                  URI to longest.</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to match.</param>
            <returns>
            <para>A <see cref="T:System.MessageBus.FilterHierarchyNodeCollection"/> of the matching <see cref="!:System.MessageBus]s"/>.FilterHierarchyNode'/&gt; .</para>
            </returns>
            <exception cref="!:System.NullArgumentException">If <paramref name="message"/> is null</exception>
            <remarks>
               <para>This is a more efficent way to find a subset of matching 
                  filters for performance sensetive matching on large or complex FilterHierarchys.
                  If you are only looking for matching filters on the shortest matching node,
                  enumerate the FilterHierarchyNode s from the beginning and call GetMatches on
                  each until a match is found. To find the longest match, start at the end of the
                  collection and work towards the beginning. </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.FilterHierarchy.OnGetFilters">
            <summary>
            Called just before FilterHierarchyNode.Filters starts collecting filters to return
            </summary>
        </member>
        <member name="M:System.MessageBus.FilterHierarchy.OnGetMatches">
            <summary>
            Called just before FilterHierarchyNode.GetMatches starts
            </summary>
            <param name="hierarchyNode"></param>
        </member>
        <member name="M:System.MessageBus.FilterHierarchy.OnMatchComplete(System.MessageBus.FilterDataCollection)">
            <summary>
               Called whenever FilterHierarchyNode.GetMatches is
               complete.
            </summary>
            <param name="matches">The matching <see cref="T:System.MessageBus.FilterData"/> instances.</param>
            <remarks>
               <para>The overrider can edit the given matches collection and 
                  return a newer set.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.FilterHierarchy.Remove(System.MessageBus.FilterData)">
            <summary>
               <para>Removes a Filter from a FilterHierarchy.</para>
            </summary>
            <param name="filterData">The <see cref="T:System.MessageBus.FilterData"/> instance to remove.</param>
            <exception cref="T:System.ArgumentNullException">If FilterData is null.</exception>
            <remarks>
               <para>No error will be thrown if the FilterData instance is no longer in the 
                  FilterHierarchy.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.FilterHierarchy.Remove(System.String,System.MessageBus.FilterData)">
            <summary>
            Remove filterData OBJECT (references must match) from the given location in the hierarchy
            If the filterData was found in the hierarchy AND successfully removed, returns true
            </summary>
        </member>
        <member name="P:System.MessageBus.FilterHierarchy.Hierarchy">
            <summary>
               <para>Gets the root element of the FilterHierarchy.</para>
            </summary>
            <value>
               <para>The root element of the FilterHierarchy.</para>
            </value>
            <remarks>
               <para>The hierarchy may be navigated directly using this as the root element. The 
                  Hierarchy will only contain non-empty nodes or nodes that have any
                  non-empty ansesters. </para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.FilterHierarchy.HierarchyUriPath">
            <summary>
            <para>Gets the <see cref="T:System.MessageBus.Filter"/> that when applied to a message returns the node or string containing the URI to used to match agains the hierarchy.</para>
            </summary>
            <value>
               <para>The Filter passed in to the constuctor.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.FilterHierarchy.Item(System.String)">
            <summary>
               The accessor may be used to get a specific <see cref="T:System.MessageBus.FilterHierarchyNode"/> from the <see cref="P:System.MessageBus.FilterHierarchy.Hierarchy"/>.
            </summary>
            <param name="uri">The URI prefix of the node to return. The empty string returns the root node.</param>
        </member>
        <member name="T:System.MessageBus.FilterHierarchyCache">
            <summary>
            <para>The Filter Hierarchy Cache is, as it sounds, a <see cref="T:System.MessageBus.FilterHierarchy"/> that stores filter data pairs as cacheable units. The cache manages object expiration times and the size of the cache using relative object weights. The cache uses an internal most recently used (MRU) list of filter-data pairs and actively trims from the bottom when it reaches a weight limit.</para>
            </summary>
            <threadsafe>
               <para>Single Threaded.</para>
            </threadsafe>
            <remarks>
               <para>Expired items are never returned from the cache. </para>
            </remarks>
        </member>
        <member name="F:System.MessageBus.FilterHierarchyCache.DefaultWeight">
            <summary>
               The default weight used for items added without a
               specified weight.
            </summary>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyCache.#ctor(System.MessageBus.Filter,System.Int32,System.Int32)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.FilterHierarchyCache"/> class. When the cache is constructed, it is assigned an optimal weight and a maximum weight.</para>
            </summary>
            <param name="hierarchyUriPath">The <see cref="T:System.MessageBus.Filter"/> used to construct the <see cref="T:System.MessageBus.FilterHierarchy"/> .</param>
            <param name="optimalWeight">The cache will stop trimming when the cache reaches or falls below the optimal weight.</param>
            <param name="maximumWeight">The cache will start trimming when the cache exceeds the maximumWeight.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hierarchyUriPath"/> is null.</exception>
            <permission cref="T:System.ArgumentException"><para>If <paramref name="maximumWeight"/> &lt;= 0.If <paramref name="maximumWeight"/> &lt; <paramref name="optimalWeight"/>.</para></permission>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyCache.Add(System.String,System.MessageBus.Filter,System.Object)">
            <summary>
               <para>Add a filter with context data to the FilterHierarchyCache with no expiration date and a weight of 1.</para>
            </summary>
            <param name='uri'>The location in the hierarchy to add the Filter, data pair. Represents a prefix of a URI.</param>
            <param name='filter'>The Filter to match against the messages that match the URI prefix.</param>
            <param name='data'>The context data to return with matches.</param>
            <returns>
               <para>A FilterData object that can be used to remove the filter from the Hierarchy.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyCache.Add(System.String,System.MessageBus.Filter,System.Object,System.Int32)">
            <summary>
            Add a filter with context data to the FilterHierarchyCache with no expiration date.
            </summary>
            <param name="uri">The location in the hierarchy to add the Filter, data pair. Represents a prefix of a URI.</param>
            <param name="filter">The Filter to match against the messages that match the URI prefix.</param>
            <param name="data">The context data to return with matches.</param>
            <param name="weight">Relative size of this entry. Relative to other entries.</param>
            <returns>A FilterData object that can be used to remove the filter from the Hierarchy.</returns>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyCache.Add(System.String,System.MessageBus.Filter,System.Object,System.Int32,System.DateTime)">
            <summary>
            Add a filter with context data to the FilterHierarchyCache.
            </summary>
            <param name="uri">The location in the hierarchy to add the Filter, data pair. Represents a prefix of a URI.</param>
            <param name="filter">The Filter to match against the messages that match the URI prefix.</param>
            <param name="data">The context data to return with matches.</param>
            <param name="weight">Relative size of this entry. Relative to other entries.</param>
            <param name="utcExpiresAt">This item will be removed from the cache and matches will not be returned after this UTC time.</param>
            <returns>A FilterData object that can be used to remove the filter from the Hierarchy.</returns>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyCache.Add(System.String,System.MessageBus.Filter,System.Object,System.Int32,System.DateTime,System.Boolean)">
            <summary>
            Add a filter with context data to the FilterHierarchyCache.
            </summary>
            <param name="uri">The location in the hierarchy to add the Filter, data pair. Represents a prefix of a URI.</param>
            <param name="filter">The Filter to match against the messages that match the URI prefix.</param>
            <param name="data">The context data to return with matches.</param>
            <param name="weight">Relative size of this entry. Relative to other entries.</param>
            <param name="utcExpiresAt">This item will be removed from the cache and matches will not be returned after this UTC time.</param>
            <param name="permanent">If true, the item will never be removed from the cache.</param>
            <returns>A FilterData object that can be used to remove the filter from the Hierarchy.</returns>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyCache.OnGetFilters">
            <summary>
            Called just before FilterHierarchyNode.Filters starts collecting filters to return
            </summary>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyCache.OnGetMatches">
            <summary>
            Called just before FilterHierarchyNode.GetMatches starts
            </summary>
            <param name="hierarchyNode"></param>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyCache.OnMatchComplete(System.MessageBus.FilterDataCollection)">
            <summary>
            Called whenever FilterHierarchyNode.GetMatches is complete
            The overrider can edit the given matches collection and return a newer set. 
            </summary>
            <param name="matches"></param>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyCache.Remove(System.MessageBus.FilterData)">
            <summary>
               <para>Removes a Filter from a FilterHierarchyCache.</para>
            </summary>
            <param name="filterData">The <see cref="T:System.MessageBus.FilterData"/> instance to remove.</param>
            <remarks>
               <para>No error will be thrown if the FilterData instance is no 
                  longer in the FilterHierarchyCache.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyCache.Trim(System.Int32)">
            <summary>
               <para>Removes expired items then trims all items in the internal MRU list to at least the
                  specified weight.</para>
            </summary>
            <param name='desiredWeight'>The relative weight to trim the FilterHierarchyCahce to.</param>
        </member>
        <member name="P:System.MessageBus.FilterHierarchyCache.MaximumWeight">
            <summary>
            The cache will start trimming when the cache exceeds the maximumWeight.
            </summary>
        </member>
        <member name="P:System.MessageBus.FilterHierarchyCache.OptimalWeight">
            <summary>
            The cache will stop trimming when the cache reaches or falls below the optimal weight.
            </summary>
        </member>
        <member name="P:System.MessageBus.FilterHierarchyCache.Weight">
            <summary>
            The current weight of the cache. The weight is calculated by adding the weights of all the not expired cached items.
            </summary>
        </member>
        <member name="T:System.MessageBus.FilterHierarchyMatch">
            <summary>
            <para>This class is returned as part of the <see cref="T:System.MessageBus.FilterHierarchyMatchCollection"/> from the <see cref="T:System.MessageBus.FilterTable"/> .</para>
            </summary>
            <threadsafe>
               <para>Single Threaded.</para>
            </threadsafe>
        </member>
        <member name="P:System.MessageBus.FilterHierarchyMatch.FilterNode">
            <summary>
               <para>Gets the spot in the hierarchy for which this is a set of matches.</para>
            </summary>
            <value>
               <para>The position in the hierarchy for which this is a set of matches.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.FilterHierarchyMatch.Matches">
            <summary>
            <para>Gets the collection of <see cref="T:System.MessageBus.FilterData"/> instances representing the matching <see cref="!:System.MessageBus.Filters"/>.</para>
            </summary>
            <value>
            <para>The collection of <see cref="T:System.MessageBus.FilterData"/> instances representing the 
               matching <see cref="!:System.MessageBus.Filters"/> .</para>
            </value>
        </member>
        <member name="T:System.MessageBus.FilterHierarchyMatchCollection">
            <summary>
            <para>A collection of <see cref="T:System.MessageBus.FilterHierarchyMatch"/> objects.</para>
            </summary>
            <threadsafe>
               <para>Single Threaded.</para>
            </threadsafe>
            <remarks>
            <para>Returned by <see cref="!:System.MessageBus]."/>.FilterHierarchyMatchCollection.GetMatches'/&gt;</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyMatchCollection.Contains(System.MessageBus.FilterHierarchyMatch)">
            <nodoc/>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyMatchCollection.CopyTo(System.MessageBus.FilterHierarchyMatch[],System.Int32)">
            <nodoc/>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyMatchCollection.IndexOf(System.MessageBus.FilterHierarchyMatch)">
            <nodoc/>
        </member>
        <member name="P:System.MessageBus.FilterHierarchyMatchCollection.Item(System.Int32)">
            <nodoc/>
        </member>
        <member name="T:System.MessageBus.FilterHierarchyNode">
            <summary>
               <para>Comparer used to search FilterHierarchyNodeCollections for children.</para>
            </summary>
            <threadsafe>
               <para>Single Threaded.</para>
            </threadsafe>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyNode.GetFilters">
            <summary>
            Returns the collection of Filters at this hierarchy node
            </summary>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyNode.GetMatches(System.MessageBus.Message)">
            <summary>
            Match filters at this node against the given message. 
            </summary>
            <param name="message">message to match</param>
            <returns>collection of matches</returns>
        </member>
        <member name="P:System.MessageBus.FilterHierarchyNode.FilterTable">
            <summary>
            Return internal filter table. Can be null.
            </summary>
        </member>
        <member name="P:System.MessageBus.FilterHierarchyNode.HasChildren">
            <summary>
               Gets a value indicating whether an instance
               of this class has one or more Children.
            </summary>
            <value>
            <see langword='true'/> if has one or more Children; otherwise, 
            <see langword='false'/>.
            </value>
        </member>
        <member name="P:System.MessageBus.FilterHierarchyNode.HasFilters">
            <summary>
               <para>Gets a value indicating whether has one or more Filter in 
                  Filters.[To be supplied.]</para>
            </summary>
            <value>
            <para><see langword='true'/> if one or more Filter in Filters; otherwise, 
            <see langword='false'/>. </para>
            </value>
        </member>
        <member name="P:System.MessageBus.FilterHierarchyNode.Parent">
            <summary>
               <para>Gets the parent node in the hierarchy. Can be null.</para>
            </summary>
            <value>
               <para>The parent node in the hierarchy.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.FilterHierarchyNode.Uri">
            <summary>
               <para>Gets the uri prefix for this spot in the hierarchy.</para>
            </summary>
            <value>
               <para>The URI prefix for this spot in the hierarchy.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.FilterHierarchyNode.Children">
            <summary>
            Gets the children nodes in the hierarchy.
            </summary>
        </member>
        <member name="T:System.MessageBus.FilterHierarchyNodeCollection">
            <summary>
            <para>A collection of <see cref="T:System.MessageBus.FilterHierarchyNode"/> instances.</para>
            </summary>
            <threadsafe>
               <para>Single threaded.</para>
            </threadsafe>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyNodeCollection.Contains(System.MessageBus.FilterHierarchyNode)">
            <summary>
            </summary>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyNodeCollection.CopyTo(System.MessageBus.FilterHierarchyNode[],System.Int32)">
            <summary>
            </summary>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyNodeCollection.GetEnumerator">
            <summary>
            </summary>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyNodeCollection.IndexOf(System.MessageBus.FilterHierarchyNode)">
            <nodoc/>
            <summary>
            </summary>
        </member>
        <member name="M:System.MessageBus.FilterHierarchyNodeCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <nodoc/>
            <summary>
            </summary>
        </member>
        <member name="P:System.MessageBus.FilterHierarchyNodeCollection.Count">
            <summary>
               The number of items in this collection.
            </summary>
        </member>
        <member name="P:System.MessageBus.FilterHierarchyNodeCollection.Item(System.Int32)">
            <summary>
               <para>The indexer.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.FilterHierarchyNodeCollection.System#Collections#ICollection#IsSynchronized">
            <nodoc/>
            <summary>
            </summary>
        </member>
        <member name="P:System.MessageBus.FilterHierarchyNodeCollection.System#Collections#ICollection#SyncRoot">
            <summary>
            </summary>
        </member>
        <member name="T:System.MessageBus.FilterTable">
            <summary>
            <para>A collection of <see cref="T:System.MessageBus.Filter"/> objects that can efficently 
               calculate all matching Filters for a given <see cref="T:System.MessageBus.Message"/>
               .</para>
            </summary>
            <threadsafe>
               <para>Single threaded.</para>
               <para>Although it is not fully multithread safe, it is safe 
                  for multiple readers with a single writer.</para>
            </threadsafe>
            <remarks>
            <para>The <see cref="T:System.MessageBus.FilterTable"/> stores <see cref="T:System.MessageBus.FilterData"/> instances and when <see cref="M:System.MessageBus.FilterTable.GetMatches(System.MessageBus.Message)"/> is called with a <see cref="T:System.MessageBus.Message"/>, it
               returns a collection of matching <see cref="T:System.MessageBus.FilterData"/> instances. <see cref="T:System.MessageBus.Filter"/> instances are defined
               using an XPath query and are added to the FilterTable along with some contextual
               data object using the <see cref="M:System.MessageBus.FilterTable.Add(System.MessageBus.Filter,System.Object)"/> method. The FilterTable combines these and stores and returns a FilterData instance.
               This FilterData instance can be used later with the <see cref="M:System.MessageBus.FilterTable.Remove(System.MessageBus.FilterData)"/> method to remove the Filter from the
               FilterTable.</para>
            <para>The FilterTable optimizes matching for a subset of XPath that covers most messaging scenarios but 
               supports the full XPath
               1.0 grammar. </para>
            <para>The results of GetMatches are unordred. The <see cref="T:System.MessageBus.FilterHierarchy"/> some relative 
            ording of match results.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.FilterTable.#ctor">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.FilterTable"/>
            class.</para>
            </summary>
            <remarks>
               <para>The FilterTable </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.FilterTable.Add(System.MessageBus.Filter,System.Object)">
            <summary>
            <para>Adds a <see cref="T:System.MessageBus.Filter"/> 
            and some associated context data to the FilterTable.</para>
            </summary>
            <param name="filter">filter to add to the filter table</param>
            <param name="data">associated context data to be returned with matches</param>
            <returns>
               <para> Returns a FilterData object, containing the passed in Filter and object, that may be used to remove this filter.</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="filter"/> is null.</exception>
            <exception cref="!:System.Xml.XPathException">If the XPath query in the filter does not validate.</exception>
            <remarks>
            <para>The XPath query in the Filter (<see cref="P:System.MessageBus.Filter.XPath"/> ) is validated 
               during add. If it does not validate, an exception is thrown.</para>
            <para>No attempt is made to eliminate duplicates.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.FilterTable.Contains(System.MessageBus.FilterData)">
            <summary>
               Test to see if <see cref="T:System.MessageBus.FilterData"/> instance is contained in a
               FilterTable instance.
            </summary>
            <param name="filterData">The <see cref="T:System.MessageBus.FilterData"/> instance to test for inclusion.</param>
            <returns>
            <see langword="true"/> if <paramref name="filterData"/> is contained in the 
               FilterTable; otherwise, <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">If filterData is null.</exception>
        </member>
        <member name="M:System.MessageBus.FilterTable.CopyTo(System.MessageBus.FilterData[],System.Int32)">
            <nodoc/>
        </member>
        <member name="M:System.MessageBus.FilterTable.GetMatches(System.MessageBus.Message)">
            <summary>
            <para>Evaluates all <see cref="T:System.MessageBus.Filter"/> instnace in the FilterTable
               and returns a collection of FilterData instance representing the matching
               Filters.</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to match using all the Filters in the FilterTable. </param>
            <returns>
               <para>A FilterDataCollection containing all of the 
                  FilterTable's FilterData instances that matched the <paramref name="message"/> .</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="message"/> is null.</exception>
            <remarks>
            <para>The Filter matches the <paramref name="message"/> if the result 
               of the XPath query is true or if the result cast to a boolean using the
               rules of the XPath 1.0 boolean() function is true. By these rules, a non-empty
               node set it will return true as will a non-empty string.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.FilterTable.IndexOf(System.MessageBus.FilterData)">
            <nodoc/>
            <summary>
            <para>Retreives the index value of a <see cref="T:System.MessageBus.FilterData"/> instance.</para>
            </summary>
            <param name="filterData">The <see cref="T:System.MessageBus.FilterData"/> instance to retreive the index of.</param>
            <returns>
               <para>An integer index value.</para>
            </returns>
            <exception cref="!:System.ArgumentOutOfRange">If <paramref name="filterData"/> is null.</exception>
            <remarks>
               <para>The index returned can be used with the indexer to 
                  retrieve this FilterData instance again in the future.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.FilterTable.OnInsert(System.Int32,System.Object)">
            <nodoc/>
        </member>
        <member name="M:System.MessageBus.FilterTable.OnRemove(System.Int32,System.Object)">
            <nodoc/>
            <summary>
            </summary>
        </member>
        <member name="M:System.MessageBus.FilterTable.OnValidate(System.Object)">
            <nodoc/>
            <summary>
            </summary>
        </member>
        <member name="M:System.MessageBus.FilterTable.Remove(System.MessageBus.FilterData)">
            <summary>
               Removes the <see cref="T:System.MessageBus.FilterData"/> instance from the
               FilterTable.
            </summary>
            <param name="filterData">The <see cref="T:System.MessageBus.FilterData"/> instance to remove.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="filterData"/> is null.</exception>
            <remarks>
               <para>Remove with not throw an exception if the FilterData 
                  instance does not exist in the FilterTable.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.FilterTable.Item(System.Int32)">
            <nodoc/>
            <summary>
            <para>The Indexer allows direct access to <see cref="T:System.MessageBus.FilterData"/> 
            instances contained in a FilterTable.</para>
            </summary>
            <param name="index">Index value of the FilterData instance to retreive.</param>
            <exception cref="!:"></exception>
        </member>
        <member name="T:System.MessageBus.ForwardAddressStyle">
            <summary>
               <para> Specifies how forward channels should affect the forward path when forwarding.</para>
            </summary>
            <example>
               <code lang='C#'>
            // Port p;
            // Destinations Uri[];
            p.Open;
            p.CreateForwardChannel(Destinations, ForwardAddressStyle.Insert);
               </code>
            </example>
        </member>
        <member name="F:System.MessageBus.ForwardAddressStyle.None">
            <summary>
               <para>Use the target URL as the physical hop. (Do nothing to the forward path.)</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.ForwardAddressStyle.Replace">
            <summary>
               <para>Use the target URL as the physical hop, copy the topmost 
                  via from the forward path to the reverse path, and replace the topmost via of the forward path with the target URL.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.ForwardAddressStyle.Insert">
            <summary>
               <para>Use the target URL as the physical hop, and insert the target URL at the top of the forward path.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Gate">
            <summary>
            Used to coordinate/maximize processor usage during 
            handling of received messages
            </summary>
        </member>
        <member name="T:System.MessageBus.IInfosetAttribute">
            <summary>
               An interface to expose an object as an XML infoset
               attribute.
            </summary>
            <remarks>
               <para>Objects need to impement IInfosetAttribute in order to 
                  be added to an IInfosetNode's IInfosetAttributeCollection.</para>
               <para>The IInfoset* interfaces are used to enable XML infoset navigation of objects 
                  by the <see cref="T:System.MessageBus.Filter"/>, <see cref="T:System.MessageBus.FilterTable"/>, and <see cref="T:System.MessageBus.FilterHierarchy"/>.</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.IInfosetAttributeCollection">
            <summary>
               <para>An interface for collections of IInfosetAttribute items.</para>
            </summary>
            <remarks>
               <para>Classes the implement IInfosetNode must implement an IInfosetAttributeCollection 
                  property.</para>
               <para>The IInfoset* interfaces are used to enable XML infoset navigation of objects 
                  by the <see cref="T:System.MessageBus.Filter"/>, <see cref="T:System.MessageBus.FilterTable"/>, and <see cref="T:System.MessageBus.FilterHierarchy"/>.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.IInfosetAttributeCollection.Find(System.String,System.Uri)">
            <summary>
               <para>Used to find a specific attribute in the collection.</para>
            </summary>
            <param name='name'>Non-qualified attribute name of the attribute to find.</param>
            <param name=' ns'>The namespace of the attribute to find.</param>
            <returns>
               <para>Returns the IInfosetAttribute instance requested.</para>
            </returns>
        </member>
        <member name="T:System.MessageBus.IInfosetElementCollection">
            <summary>
               <para>An interface for collections of IInfosetElement items.</para>
            </summary>
            <remarks>
               <para>Classes the implement IInfosetNode must implement a IInfosetElementCollection 
                  property.</para>
               <para>The IInfoset* interfaces are used to enable XML infoset navigation of objects 
                  by the <see cref="T:System.MessageBus.Filter"/>, <see cref="T:System.MessageBus.FilterTable"/>, and <see cref="T:System.MessageBus.FilterHierarchy"/>.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.IInfosetElementCollection.Find(System.String,System.Uri)">
            <summary>
               <para>Used to find a specific element in the collection.</para>
            </summary>
            <param name="name">Non-qualified element name of the element to find.</param>
            <param name=" ns">The namespace of the element to find.</param>
            <returns>
               <para>Returns the IInfosetAttribute instance requested.</para>
            </returns>
            <remarks>
               The IInfoset* interfaces are used to enable XML infoset navigation of objects
               by the <see cref="T:System.MessageBus.Filter"/>, <see cref="T:System.MessageBus.FilterTable"/>, and <see cref="T:System.MessageBus.FilterHierarchy"/>.
            </remarks>
        </member>
        <member name="T:System.MessageBus.IInfosetNode">
            <summary>
               <para>An interface that exposes a class as a XML infoset for 
                  navigation by message filtering.</para>
            </summary>
            <remarks>
               <para>The IInfoset* interfaces are used to enable XML infoset navigation of objects 
                  by the <see cref="T:System.MessageBus.Filter"/>, <see cref="T:System.MessageBus.FilterTable"/>, and <see cref="T:System.MessageBus.FilterHierarchy"/>. This is most useful for classes derived from
               <see cref="T:System.MessageBus.MessageHeader"/>.</para>
               <para>This interface provides similar funtionality as the Infoset* 
                  attributes with more flexablity. Use the interfaces if the
                  infoset representation of a class does not map well to the CLR
                  representation.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.IInfosetNode.Attributes">
            <summary>
               <para>The XML infoset attributes for this node.</para>
            </summary>
            <value>
               <para>The XML infoset attributes for this node.</para>
            </value>
            <remarks>
               <para>All object in this class must implement IInfosetAttribute.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.IInfosetNode.Elements">
            <summary>
               The XML infoset elements for this node.
            </summary>
            <value>
               <para>The XML infoset elements for this node.</para>
            </value>
            <remarks>
               <para>All object in this collection must implement 
                  IInfosetElement;</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.IMessageQueue">
            <summary>
               <para>Defines queue-like methods for message processing.</para>
            </summary>
            <remarks>
               <para>This interface exposes methods to inspect the queue without changing it 
                  (Peek), retrieve a message from the queue (Receive Message), either with or
                  without a timeout, as well as the corresponding asynchronous Begin / End
                  methods.</para>
               <para>A class implementing this interface may also 
                  implement <see cref="T:System.MessageBus.IMessageHandler"/>, allowing such a class to be plugged into the
                  "push" callback style of message processing while exposing the "pull" calling
                  style.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.IMessageQueue.BeginPeek(System.TimeSpan,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for Peek.</para>
            </summary>
            <param name='timeout'>The maximum amount of time the method will wait before failing. </param>
            <param name=' callback'>See Asynchronous Design Pattern.</param>
            <param name=' state'>See Asynchronous Design Pattern.</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.IMessageQueue.BeginReceive(System.TimeSpan,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for Receive.</para>
            </summary>
            <param name='timeout'>The maximum amount of time the method will wait before failing.</param>
            <param name=' callback'>See Asynchronous Design Pattern.</param>
            <param name=' state'>See Asynchronous Design Pattern.</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.IMessageQueue.EndPeek(System.IAsyncResult)">
            <summary>
               <para>Asynchronous end for Peek.</para>
            </summary>
            <param name='result'>See Asynchronous Design Pattern.</param>
            <returns>
               <para>Either a message (first in the queue) or null (if none).</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.IMessageQueue.EndReceive(System.IAsyncResult)">
            <summary>
               <para>Asynchronous end for Receive.</para>
            </summary>
            <param name='result'>See Asynchronous Design Pattern.</param>
            <returns>
               <para>Either a message (first in the queue) or null (if none).</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.IMessageQueue.Peek">
            <summary>
               <para>Returns the first message in the queue (if any) without changing the queue.</para>
            </summary>
            <returns>
               <para>Either a message (first in the queue) or null (if none).</para>
            </returns>
            <remarks>
               <para>Same behavior as Peek(new TimeSpan(0)).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.IMessageQueue.Peek(System.TimeSpan)">
            <summary>
               <para>Returns the first message in the queue (if any) without changing the queue.</para>
            </summary>
            <param name='timeout'>The maximum amount of time the method will wait before failing.</param>
            <returns>
               <para>Either a message (first in the queue) or null (if none).</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.IMessageQueue.Receive">
            <summary>
               <para>Removes the first message (if any) from the queue and 
                  returns the message.</para>
            </summary>
            <returns>
               <para>Either a message (first in the queue) or null (if none).</para>
            </returns>
            <remarks>
               <para>Same behavior as Receive(TimeSpan.MaxValue).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.IMessageQueue.Receive(System.TimeSpan)">
            <summary>
               <para>Removes the first message (if any) from the queue and returns the message.</para>
            </summary>
            <param name='timeout'>The maximum amount of time the method will wait before failing.</param>
            <returns>
               <para>Either a message (first in the queue) or null (if none).</para>
            </returns>
        </member>
        <member name="T:System.MessageBus.InfosetAttributeAttribute">
            <summary>
               <para> 
                  Decorates Instance Properties. If found, indicates that this is an attribute in
                  the Infoset for this Type.</para>
            </summary>
            <remarks>
               <para>The Infoset* attributes are used to enable XML infoset navigation of objects 
                  by the <see cref="T:System.MessageBus.Filter"/>, <see cref="T:System.MessageBus.FilterTable"/>, and <see cref="T:System.MessageBus.FilterHierarchy"/>. </para>
               <para>This attribute is looked at only if InfosetAttribute is not decorating a 
                  static property of the type.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.InfosetAttributeAttribute.#ctor(System.String)">
            <summary>
               <para>Use to indicate an unqualified attribute name.</para>
            </summary>
            <param name='name'>The unqualified attribute name.</param>
            <remarks>
               <para>The namespace will be inherited based in the XML infoset specification.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.InfosetAttributeAttribute.#ctor(System.String,System.String)">
            <summary>
               <para>Used to indicate a qualified attribute name.</para>
            </summary>
            <param name='name'>The unqualified attribute name.</param>
            <param name=' ns'>The namespace of the attribute name.</param>
        </member>
        <member name="P:System.MessageBus.InfosetAttributeAttribute.Name">
            <summary>
               <para>The unqualified attribute name.</para>
            </summary>
            <value>
               <para>The unqualified attribute name.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.InfosetAttributeAttribute.Namespace">
            <summary>
               <para>The namespace of the attribute name.</para>
            </summary>
            <value>
               <para>The namespace of the attribute name.</para>
            </value>
        </member>
        <member name="T:System.MessageBus.InfosetElementAttribute">
            <summary>
            Decorates Instance Properties
            If found, indicates that this is an element in the Infoset for this Type
            Note: this attribute is looked at only InfosetAttribute is not decorating a
            static property of the type
            </summary>    
        </member>
        <member name="T:System.MessageBus.InfosetItemAttribute">
            <summary>
            Decorates a class. A class so decorated is considered as an InfosetItem
            provider
            </summary>
        </member>
        <member name="T:System.MessageBus.InfosetItemCollectionAttribute">
            <summary>
            Summary description for InfosetCollection.
            </summary>
        </member>
        <member name="T:System.MessageBus.MemoryQueue">
            <summary>
            <para>Provides an in-memory queue of <see cref="T:System.MessageBus.Message"/> s.</para>
            </summary>
            <remarks>
            <para>MemoryQueue stores <see cref="T:System.MessageBus.Message"/>s in memory. It buffers as 
               many <see cref="T:System.MessageBus.Message"/>s as the underlying <see cref="T:System.MessageBus.Transports.Transport"/>
               allows.</para>
            <para>A MemoryQueue is a simple mechanism to convert the "push" 
               callback style into a "pull" calling style for processing new <see cref="T:System.MessageBus.Message"/>s. By
               default, <see cref="!:System.MessageBus.IMessageHandlers"/> are called when there is a new <see cref="T:System.MessageBus.Message"/> to
               process -- this is a "push" callback style. However, in some circumstances, it
               is useful to "pull", or poll for new <see cref="T:System.MessageBus.Message"/>
               s. A MemoryQueue converts the "push" into the "pull" style.</para>
            </remarks>
            <example>
               <code lang="C#">
            // Port p;
            MemoryQueue q = new MemoryQueue();
            p.ReceiveChannel.Handler = q;
            p.Open();
            // Later
            Message m = q.Peek();
               </code>
            </example>
        </member>
        <member name="M:System.MessageBus.MemoryQueue.#ctor">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.MemoryQueue"/> class.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.MemoryQueue.BeginPeek(System.TimeSpan,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for Peek.</para>
            </summary>
            <param name='timeout'>The maximum amount of time the method will wait before failing </param>
            <param name=' callback'>See Asynchronous Design Pattern</param>
            <param name=' state'>See Asynchronous Design Pattern</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.MemoryQueue.BeginReceive(System.TimeSpan,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for Receive.</para>
            </summary>
            <param name='timeout'>The maximum amount of time the method will wait before failing</param>
            <param name=' callback'>See Asynchronous Design Pattern</param>
            <param name=' state'>See Asynchronous Design Pattern</param>
            <returns>
               <para>See Asynchronous Design Pattern.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.MemoryQueue.EndPeek(System.IAsyncResult)">
            <summary>
               <para>Asynchronous end for Peek.</para>
            </summary>
            <param name="result">See Asynchronous Design Pattern</param>
            <returns>
            <para>Either a <see cref="T:System.MessageBus.Message"/> (first in the <see cref="T:System.MessageBus.IMessageQueue"/>) or <see langword="null"/> 
            (if none).</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.MemoryQueue.EndReceive(System.IAsyncResult)">
            <summary>
               <para>Asynchronous end for Receive.</para>
            </summary>
            <param name="result">See Asynchronous Design Pattern</param>
            <returns>
            <para>Either a <see cref="T:System.MessageBus.Message"/> (first in the <see cref="T:System.MessageBus.IMessageQueue"/> ) or <see langword="null"/> (if none).</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.MemoryQueue.Peek">
            <summary>
            <para>Returns the first <see cref="T:System.MessageBus.Message"/> in the <see cref="T:System.MessageBus.IMessageQueue"/> 
            (if any) without changing the <see cref="T:System.MessageBus.IMessageQueue"/> .</para>
            </summary>
            <returns>
            <para>Either a <see cref="T:System.MessageBus.Message"/> (first in the <see cref="T:System.MessageBus.IMessageQueue"/>) or <see langword="null"/> (if none).</para>
            </returns>
            <remarks>
               <para>Same behavior as Peek(new TimeSpan(0)).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.MemoryQueue.Peek(System.TimeSpan)">
            <summary>
            <para>Returns the first <see cref="T:System.MessageBus.Message"/> in the <see cref="T:System.MessageBus.IMessageQueue"/> 
            (if any) without changing the <see cref="T:System.MessageBus.IMessageQueue"/> .</para>
            </summary>
            <param name="timeout">The maximum amount of time the method will wait before failing</param>
            <returns>
            <para>Either a <see cref="T:System.MessageBus.Message"/> (first in the <see cref="T:System.MessageBus.IMessageQueue"/>) or <see langword="null"/> (if none).</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.MemoryQueue.Receive">
            <summary>
            <para>Removes the first <see cref="T:System.MessageBus.Message"/> (if any) from the <see cref="T:System.MessageBus.IMessageQueue"/> 
            and returns the <see cref="T:System.MessageBus.Message"/>
            .</para>
            </summary>
            <returns>
            <para>Either a <see cref="T:System.MessageBus.Message"/> (first in the <see cref="T:System.MessageBus.IMessageQueue"/>) or <see langword="null"/> (if none).</para>
            </returns>
            <remarks>
               <para>Same behavior as Receive(TimeSpan.MaxValue).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.MemoryQueue.Receive(System.TimeSpan)">
            <summary>
            <para>Removes the first <see cref="T:System.MessageBus.Message"/> (if any) from the <see cref="T:System.MessageBus.IMessageQueue"/> 
            and returns the <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <param name="timeout">The maximum amount of time the method will wait before failing</param>
            <returns>
            <para>Either a <see cref="T:System.MessageBus.Message"/> (first in the <see cref="T:System.MessageBus.IMessageQueue"/>) or <see langword="null"/> (if none).</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.MemoryQueue.ProcessMessage(System.MessageBus.Message)">
            <summary>
            <para>Processes a <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> to process</param>
            <returns>
            <para><see langword="true"/> if the <see cref="T:System.MessageBus.IMessageHandler"/> 
            has not and will not call <see cref="M:System.MessageBus.Message.Close"/> ; otherwise, <see langword="false"/>.</para>
            </returns>
        </member>
        <member name="T:System.MessageBus.Message">
            <summary>
               <para> Represents an in-memory message consisting of content and a 
                  set of headers.</para>
            </summary>
            <threadsafe>
               <para>Single threaded.</para>
            </threadsafe>
            <remarks>
               <para> A Message is the fundamental unit of communication 
                  between endpoints. Messages consist of <see cref="T:System.MessageBus.MessageContent"/> and a <see cref="T:System.MessageBus.MessageHeaderCollection"/>. Roughly, <see cref="T:System.MessageBus.MessageContent"/> is the domain of the application, while
               <see cref="T:System.MessageBus.MessageHeader"/> 
               s are the domain of
               system processing.</para>
            <para>A Message does not have an explicit destination. A useful analogy is that of 
               a drive-up bank teller. The teller puts the carrier with the results of the
               banking transaction into the pneumatic tube corresponding to the correct
               customer. Like the Message, the carrier does not know where the customer is; the
               tube does. Compared to the traditional addressed-letter-in-the-mailbox analogy,
               this model allows clean abstraction of destination and connection for
               higher-level programming models. The analogy breaks down, however, because
               information about the destination is eventually encoded within the Message,
               e.g., in a WS-Routing <see cref="T:System.MessageBus.RoutingHeader"/>.</para>
            <para>Because a Message is changed by message processing, a single Message is 
               either received or sent, but not both. Similarly, a single Message may not be
               sent more than once.</para>
            <para>A Message is created whenever a message is received by a 
            <see cref="T:System.MessageBus.Transports.Transport"/> 
            . You can program your XML Web Service to respond as needed
            by your particular application. In general, the following steps occur when
            handling a message:</para>
            <list type="number"><item>
               <term>
                  The message is received and handed to your application in the form of a
                  new <see cref="T:System.MessageBus.Message"/>.</term>
            </item>
            <item>
               <term>
                  If appropriate, your program examines the collection
                  of <see cref="T:System.MessageBus.MessageHeader"/>
                  s, accessed through the
               <see cref="P:System.MessageBus.Message.Headers"/> 
               property.</term>
            </item>
            <item>
               <term>
                  Your program examines the MessageContent, read through the <see cref="P:System.MessageBus.Message.Content"/>
                  property.</term>
            </item>
            </list>
            <para>When a Message is no longer needed, it must be closed. 
               Similar to closing a file, this is typically done when the application has
               extracted the information it needs from the Message. When a Message is sent, the
               send channel typically closes the Message. Closing a Message asserts that any
               content or resources referenced by the Message are no longer needed. This may,
               but does not necessarily include MessageContent that has not yet been read from
               the underlying <see cref="T:System.IO.Stream"/>
               . If multiple Messages are being sent on the same connection
               between endpoints, failure to close one Message may prevent additional message processing, effectively blocking read
               of the next message until the entire content of the current Message
               has been either buffered or consumed. When a Message is closed, the
               Closed event is triggered. Other message processing code may choose to hook this event to know when to
               clean up Message-specific state.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Message.#ctor">
            <overload>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.Message"/> class.</para>
            </overload>
            <summary>
            <para>Initializes a Message with <see langword="null"/>
            <see cref="P:System.MessageBus.Message.Action"/>, empty <see cref="P:System.MessageBus.Message.Content"/>, and default <see cref="T:System.MessageBus.MessageEncoding"/> .</para>
            </summary>
            <remarks>
               <para> 
                  Equivalent to Message(<see langword="null"/>
                  ).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Message.#ctor(System.Uri)">
            <summary>
            <para>Initializes a Message with a specific <see cref="P:System.MessageBus.Message.Action"/>, but empty <see cref="P:System.MessageBus.Message.Content"/>, and default 
            <see cref="T:System.MessageBus.MessageEncoding"/>.</para>
            </summary>
            <param name="action">The <see cref="T:System.Uri"/> that summarizes the intent of the Message.</param>
            <remarks>
            <para>Equivalent to (<paramref name="action"/>, new 
               EmptyContent()).</para>
            </remarks>
            <example>
            <para>This example creates a Message with a simple <see cref="P:System.MessageBus.Message.Action"/>, <see cref="T:System.MessageBus.EmptyContent"/>, and a default <see cref="T:System.MessageBus.MessageEncoding"/>.</para>
            <code lang="C#">
            Uri action = new Uri("http://schemas.microsoft.com/mb/2002/09/Samples/Hello");
            Message m = new Message(action);
            </code>
            </example>
        </member>
        <member name="M:System.MessageBus.Message.#ctor(System.Uri,System.Object)">
            <summary>
            <para>Initializes a Message with a specific <see cref="P:System.MessageBus.Message.Action"/> and an <see cref="T:System.Object"/> as <see cref="P:System.MessageBus.Message.Content"/>, but with default 
            <see cref="T:System.MessageBus.MessageEncoding"/>.</para>
            </summary>
            <param name="action">The <see cref="T:System.Uri"/> that summarizes the intent of the Message.</param>
            <param name="object">The <see cref="T:System.Object"/> that is the content of the Message.</param>
            <remarks>
            <para>If <paramref name="object"/> is 
            <see langword="null"/> , equivalent to 
               Message(<paramref name="action"/>,
               new EmptyContent(), <see langword="null"/> ); otherwise, equivalent to
               Message(<paramref name="action"/>, new ObjectContent(<paramref name="object"/> ), <see langword="null"/> ).</para>
            </remarks>
            <example>
            <para>This example creates a Message with a simple <see cref="P:System.MessageBus.Message.Action"/>, string <see cref="P:System.MessageBus.Message.Content"/>, and default <see cref="T:System.MessageBus.MessageEncoding"/>.</para>
            <code lang="C#">
            Uri action = new Uri("http://schemas.microsoft.com/mb/2002/09/Samples/Hello");
            Message m = new Message(action,"Hello World!");
            </code>
            </example>
        </member>
        <member name="M:System.MessageBus.Message.#ctor(System.Uri,System.MessageBus.MessageContent)">
            <summary>
            <para>Initializes a Message with a specific <see cref="P:System.MessageBus.Message.Action"/> and <see cref="P:System.MessageBus.Message.Content"/>, but with default 
            <see cref="T:System.MessageBus.MessageEncoding"/>.</para>
            </summary>
            <param name="action">The <see cref="T:System.Uri"/> that summarizes the intent of the Message.</param>
            <param name="content">The <see cref="T:System.MessageBus.MessageContent"/> that contains the content of the Message.</param>
            <remarks>
            <para>Equivalent to Message(<paramref name="action"/>, <paramref name="content"/>, <see langword="null"/> ).</para>
            </remarks>
            <example>
            <para>This example creates a Message with a simple <see cref="P:System.MessageBus.Message.Action"/>, string <see cref="P:System.MessageBus.Message.Content"/>, and default <see cref="T:System.MessageBus.MessageEncoding"/>.</para>
            <code lang="C#">
            Uri action = new Uri("http://schemas.microsoft.com/mb/2002/09/Samples/Hello");
            MessageContent content = new ObjectContent("Hello World!");
            Message m = new Message(action,content);
            </code>
            </example>
        </member>
        <member name="M:System.MessageBus.Message.#ctor(System.Uri,System.MessageBus.MessageContent,System.MessageBus.MessageEncoding)">
            <summary>
            <para>Initializes a Message with a specific <see cref="P:System.MessageBus.Message.Action"/>, <see cref="P:System.MessageBus.Message.Content"/>, and <see cref="T:System.MessageBus.MessageEncoding"/>.</para>
            </summary>
            <param name="action">The <see cref="T:System.Uri"/> that summarizes the intent of the Message.</param>
            <param name="content">The <see cref="T:System.MessageBus.MessageContent"/> that contains the content of the Message.</param>
            <param name="encoding">The <see cref="T:System.MessageBus.MessageEncoding"/> that describes the wire-format encoding of the Message.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="content"/> is <see langword="null"/> .</exception>
            <remarks>
            <para>New Messages are initialized with a default set of <see cref="T:System.MessageBus.MessageHeader"/>s.</para>
            </remarks>
            <example>
            <para>This example creates a Message with a simple <see cref="P:System.MessageBus.Message.Action"/>, string <see cref="P:System.MessageBus.Message.Content"/>, and <see cref="T:System.MessageBus.TextXmlEncoding"/>.</para>
            <code lang="C#">
            Uri action = new Uri("http://schemas.microsoft.com/mb/2002/09/Samples/Hello");
            MessageContent content = new ObjectContent("Hello World!");
            MessageEncoding encoding = new TextXmlEncoding(new UTF8Encoding(false));
            Message m = new Message(action, content, encoding);
            </code>
            </example>
        </member>
        <member name="M:System.MessageBus.Message.#ctor(System.MessageBus.MessageException)">
            <summary>
            <para>Initializes a Message with an <see cref="T:System.Exception"/> as <see cref="T:System.MessageBus.MessageContent"/>, but with a null <see cref="P:System.MessageBus.Message.Action"/> and default 
            <see cref="T:System.MessageBus.MessageEncoding"/>.</para>
            </summary>
            <param name="exception">The <see cref="T:System.Exception"/> that contains the content of the Message.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="exception"/> is <see langword="null"/> .</exception>
            <remarks>
            <para>Equivalent to Message(<see langword="null"/> , new ExceptionContent(<paramref name="exception"/>)).</para>
            </remarks>
            <example>
            <para>This example creates a Message from an <see cref="T:System.Exception"/>, with a 
            <see langword="null"/>
            <see cref="P:System.MessageBus.Message.Action"/> and default <see cref="T:System.MessageBus.MessageEncoding"/> . </para>
            <code lang="C#">
            Exception exception = new ArgumentException("Greeting too brief");
            Message m = new Message(exception);
            </code>
            </example>
        </member>
        <member name="M:System.MessageBus.Message.Clone">
            <summary>
               <para>Creates a deep copy of the Message.</para>
            </summary>
            <returns>
               <para>A deep copy of the Message.</para>
            </returns>
            <remarks>
               <para>Clone makes a deep copy of the Message and calls Clone on the Content.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Message.Close">
            <summary>
               <para>Informs all interested listeners that the Message has been closed.</para>
            </summary>
            <remarks>
               <para>Close is idempotent. Calling it repeatedly does not raise an exception.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Message.Action">
            <summary>
               <para>Gets or sets the intent of the Message.</para>
            </summary>
            <value>
            <para>A <see cref="T:System.Uri"/> that summarizes the intent of the Message. </para>
            </value>
            <example>
               <para>This example shows setting the Action to a hypothetical intent to say "Hello". </para>
               <code lang="C#">
            Message m = new Message();
            m.Action = new Uri("http://schemas.microsoft.com/mb/2002/09/Samples/Hello");
               </code>
            </example>
        </member>
        <member name="P:System.MessageBus.Message.Content">
            <summary>
               <para> Gets or sets the content of 
                  the Message.</para>
            </summary>
            <value>
            <para>A <see cref="T:System.MessageBus.MessageContent"/> containing the content of the Message.</para>
            </value>
            <exception cref="T:System.ArgumentNullException">If <paramref name="message"/> is <see langword="null"/>.</exception>
            <example>
               <para>This example shows setting the Content of the Message to a 
               <see langword="string"/>.</para>
               <code lang="C#">
            Message m = new Message();
            m.Content = new ObjectContent("Hello World!");
               </code>
            </example>
        </member>
        <member name="P:System.MessageBus.Message.Encoding">
            <summary>
               <para>Gets or sets the on-the-wire encoding of the Message.</para>
            </summary>
            <value>
            <para>An <see cref="T:System.MessageBus.MessageEncoding"/> that describes the wire-format encoding of the Message.</para>
            </value>
            <example>
            <para>This example shows setting the Encoding of a Message to <see cref="T:System.MessageBus.TextXmlEncoding"/>.</para>
            <code lang="C#">
            Message m = new Message();
            m.Encoding = new TextXmlEncoding(new UTF8Encoding(false));
            </code>
            </example>
        </member>
        <member name="P:System.MessageBus.Message.Headers">
            <summary>
            <para>Gets the collection of <see cref="T:System.MessageBus.MessageHeader"/> 
            s of the Message.</para>
            </summary>
            <value>
            <para>A <see cref="T:System.MessageBus.MessageHeaderCollection"/> that contains all <see cref="T:System.MessageBus.MessageHeader"/>s for the <see cref="T:System.MessageBus.Message"/> .</para>
            </value>
        </member>
        <member name="E:System.MessageBus.Message.Closed">
            <summary>
               <para> Occurs when the Message has been fully 
                  processed.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.MessageBusConfiguration">
            <summary>
               <para>The collection containing the config 
                  built MessageBus objects returned from .Net config by the
                  MessageBusConfigHandler.</para>
            </summary>
            <threadsafe>
               <para>Single Threaded.</para>
            </threadsafe>
            <remarks>
               <para>The 
                  Sytem.MessageBus.Configuration.MessageBusConfigHanlder .Net config handler is
                  used declaritively in configuration to create a MessageBusConfiguration
                  collection containing each of the configured MessageBus objects. In the example
                  below, the MessageBusConfigHanlder parses the &lt;System.MessageBus&gt; XML node
                  and builds a collection of configured MessageBus objects.</para>
               <para>Example of a configuration file:</para>
               <code>
            (001)&lt;configuration&gt;
            (002)    &lt;configSections&gt;
            (003)    &lt;section name="System.MessageBus" type="System.MessageBus.Configuration.MessageBusConfigHandler, System.MessageBus, Version=1.0.0.0, Culture=neutral, PublicKeyToken=9a87270ea44d98f1" /&gt;
            (004)    &lt;/configSections&gt;
            (005)    &lt;System.MessageBus&gt;
            (006)    ...
            (007)    &lt;/System.MessageBus&gt;
            (008)&lt;/configuration&gt;
               </code>
               <para>The MessageBusConfiguration collection is indexed by CLR type. The 
                  following example shows how to get a MessageBusConfiguration collection from
                  config. The GetFromConfig static method is used as a shortcut to call
                  config.</para>
               <para>Example of using thhe MessageBusConfiguration collection:</para>
               <code lang='C#'>
            // get the configuration
            MessageBusConfiguration c = MessageBusConfiguration.GetFromConfig();
            
            // get the port from the configuration
            port = (Port)c[typeof(Port)];
               </code>
            </remarks>
        </member>
        <member name="M:System.MessageBus.MessageBusConfiguration.Add(System.Object)">
            <summary>
               Adds an item to the MessageBusConfiguration collection.
            </summary>
            <param name="item">The object to add to the collection.</param>
            <returns>
               <para>Returns the index id of the collection item.</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">If item is null.</exception>
            <remarks>
               <para>If an item of that type already exits, it will be overriden.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.MessageBusConfiguration.Contains(System.Object)">
            <summary>
               Test to see if an intance exists in the collection.
            </summary>
            <param name="item">Item to test for inclusion.</param>
            <returns>
            <para><see langword="true"/> if the item exists in the collection; otherwise, 
            <see langword="false"/>.</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="item"/> is null.</exception>
        </member>
        <member name="M:System.MessageBus.MessageBusConfiguration.CopyTo(System.Object[],System.Int32)">
            <nodoc/>
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.MessageBusConfiguration.GetFromConfig">
            <summary>
               <para>A static shortcut to load the &lt;System.MessageBus&gt; 
                  configuration section and retrieve the resulting MessageBusConfiguration.</para>
            </summary>
            <returns>
               <para>A newly generated MessageBusConfiguration collection.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.MessageBusConfiguration.IndexOf(System.Object)">
            <summary>
               <para>Gets the index id of the item.</para>
            </summary>
            <param name="item">The object to get the id of.</param>
            <returns>
               <para>The integer index id.</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="item"/> is null.</exception>
        </member>
        <member name="M:System.MessageBus.MessageBusConfiguration.Insert(System.Int32,System.Object)">
            <nodoc/>
            <summary>
               <para>Inserts the object in the collection at the particular index</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.MessageBusConfiguration.OnValidate(System.Object)">
            <nodoc/>
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.MessageBusConfiguration.Remove(System.Object)">
            <nodoc/>
            <summary>
               <para>Removes the object from the collection</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.MessageBusConfiguration.Item(System.Int32)">
            <summary>
               <para>Indexer to get items by index id.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.MessageBusConfiguration.Item(System.Type)">
            <summary>
               <para>Indexer to retrieve items by CLR type.</para>
            </summary>
            <param name='type'>Pass in the CLR type of the object to retrieve from the collection.</param>
        </member>
        <member name="T:System.MessageBus.MessageException">
            <summary>
               <para> The in-memory representation of a SOAP 1.2 Fault.</para>
            </summary>
            <remarks>
               <para>To create a Message containing a SOAP 1.2 Fault, create a Message Exception 
                  to represent the Fault, and create a Message whose Content is of type Exception
                  Content containing the Message Exception.</para>
               <para>Most of the fields of a SOAP 1.2 Fault are exposed in specifically-defined 
                  properties. However, note that the Reason of the Fault is stored as the Message
                  property of the exception.</para>
            </remarks>
            <example>
               <code lang='C#'>
            // MessageException e;
            // Message m;
            m.Content = new ExceptionContent(e);
               </code>
            </example>
        </member>
        <member name="M:System.MessageBus.MessageException.#ctor(System.MessageBus.FaultCode,System.String)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.MessageException"/> class.</para>
            </summary>
            <param name="code">Fault Code of the Fault.</param>
            <param name=" reason">Human-readable explanation of the Fault.</param>
            <remarks>
               <para>Equivalent to MessageException(code, reason, null, null, null).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.MessageException.#ctor(System.MessageBus.FaultCode,System.String,System.Uri,System.Uri,System.Xml.XmlNode)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.MessageException"/> class.</para>
            </summary>
            <param name="code">Fault Code of the Fault.</param>
            <param name=" reason">Human-readable explanation of the Fault.</param>
            <param name=" node">SOAP node that caused the Fault.</param>
            <param name=" role">Role the node was operating in at the time of the Fault.</param>
            <param name=" detail">Application-specific error information related to the SOAP Body.</param>
        </member>
        <member name="M:System.MessageBus.MessageException.CreateUnknownException(System.Exception)">
            <summary>
               <para>Creates an in-memory representation of the WS-Routing Unknown Fault.</para>
            </summary>
            <param name='exception'></param>
        </member>
        <member name="P:System.MessageBus.MessageException.Code">
            <summary>
               <para>Gets the Fault Code corresponding to this SOAP Fault.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.MessageException.Detail">
            <summary>
               <para>Gets the Detail of the SOAP Fault.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.MessageException.Headers">
            <summary>
               <para>Gets the Message Headers of the SOAP Fault.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.MessageException.Node">
            <summary>
               <para>Gets the Node of the SOAP Fault.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.MessageException.Role">
            <summary>
               <para>Gets the Role of the SOAP Fault.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.MessageException.XmlLang">
            <summary>
               <para>Gets the Language of the Reason of the SOAP Fault.</para>
            </summary>
            <remarks>
               <para>The Reason of the SOAP Fault is stored as the Message property of the 
                  exception.</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.MulticastRoute">
            <summary>
               <para>Route with multicast endpoints.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Route">
            <summary>
               <para>Basic 1-1 route. 
               The Route class is the base class for any type of route that MessageBus implements.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.Route.PolicyStartTagName">
            <summary>
               <para>The name that is used to denote a policy statement of this type</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Route.#ctor(System.Uri,System.Uri)">
            <summary>
               <para>Initializes a new instance of the <see cref="T:System.MessageBus.Route"/> class.</para>
            </summary>
            <param name="destination">The URI for which this is a route.</param>
            <param name="nextHop">The URI where a message that matches this route should be forwarded.</param> 
        </member>
        <member name="M:System.MessageBus.Route.#ctor(System.Uri,System.Uri,System.MessageBus.Filter)">
            <summary>
               <para>Initializes a new instance of the <see cref="T:System.MessageBus.Route"/> class.</para>
            </summary>
            <param name="destination">The URI for which this is a route.</param>
            <param name="nextHop">The URI where a message that matches this route should be forwarded.</param> 
            <param name="filter">Additional logic to qualify this route.</param>
        </member>
        <member name="M:System.MessageBus.Route.#ctor(System.Uri,System.Uri,System.Boolean)">
            <summary>
               <para>Initializes a new instance of the <see cref="T:System.MessageBus.Route"/> class.</para>
            </summary>
            <param name="destination">The URI for which this is a route.</param>
            <param name="nextHop">The URI where a message that matches this route should be forwarded.</param> 
            <param name="continueProcessing">Continue looking for more specific routes even if this route matches.</param>
        </member>
        <member name="M:System.MessageBus.Route.#ctor(System.Uri,System.Uri,System.MessageBus.Filter,System.Boolean)">
            <summary>
               <para>Initializes a new instance of the <see cref="T:System.MessageBus.Route"/> class.</para>
            </summary>
            <param name="destination">The URI for which this is a route.</param>
            <param name="nextHop">The URI where a message that matches this route should be forwarded.</param> 
            <param name="filter">Additional logic to qualify this route.</param>
            <param name="continueProcessing">Continue looking for more specific routes even if this route matches.</param>
        </member>
        <member name="M:System.MessageBus.Route.#ctor(System.Uri,System.Uri,System.MessageBus.Filter,System.Boolean,System.Guid)">
            <summary>
               <para>Initializes a new instance of the <see cref="T:System.MessageBus.Route"/> class.</para>
            </summary>
            <param name="destination">The URI for which this is a route.</param>
            <param name="nextHop">The URI where a message that matches this route should be forwarded.</param> 
            <param name="filter">Additional logic to qualify this route.</param>
            <param name="continueProcessing">Continue looking for more specific routes even if this route matches.</param>
            <param name="routeID">The unique ID of this route.</param>
        </member>
        <member name="M:System.MessageBus.Route.#ctor(System.Uri,System.MessageBus.RouteEntry[],System.MessageBus.Filter,System.Boolean,System.Guid)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.Route"/> class.
            Used by derived classes to correctly initialize the data members embedded in the Route class</para>
            </summary>
            <param name="destination">The URI for which this is a route.</param>
            <param name="nextHops">The set of URIs where a message that matches this route may be forwarded.</param> 
            <param name="filter">Additional logic to qualify this route.</param>
            <param name="continueProcessing">Continue looking for more specific routes even if this route matches.</param>
            <param name="routeID">The unique ID of this route.</param>
        </member>
        <member name="M:System.MessageBus.Route.SerializeToPolicy(System.Xml.XmlWriter)">
            <summary>
               <para>Write out the route into the policy.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Route.GetNextHops(System.MessageBus.Message)">
            <summary>
            Set of RouteEntries where this message should be sent next.
            </summary>
        </member>
        <member name="M:System.MessageBus.Route.DeserializeFromPolicy(System.MessageBus.Policy,System.Xml.XmlNode)">
            <summary>
               <para>Recreate the route from the policy and the associated XML.</para>
            </summary>
            <param name='policy'>Policy where this route is being deserialized from</param>
            <param name='node'>Route specific Xml</param>
        </member>
        <member name="P:System.MessageBus.Route.ContinueProcessing">
            <summary>
               <para>true - Continue looking for more specific routes even if this route matches.
               false - otherwise.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Route.Destination">
            <summary>
               <para>The URI for which this is a route.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Route.Filter">
            <summary>
               <para>Additional logic that qualifies this route.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Route.PolicyStatement">
            <summary>
               <para>PolicyStatement object for this route</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Route.RouteEntries">
            <summary>
               <para>The complete set of RouteEntries where a message that matches this route may be forwarded.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Route.RouteID">
            <summary>
               <para>The unique ID of this route.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.MulticastRoute.PolicyStartTagName">
            <summary>
               <para>The name that is used to denote a policy statement of this type</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.MulticastRoute.#ctor(System.Uri,System.MessageBus.MulticastRouteEntry[])">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.MulticastRoute"/> class.</para>
            </summary>
            <param name="destination">The URI for which this is a route.</param>
            <param name="nextHops">The URIs where a message that matches this route should be forwarded.</param> 
        </member>
        <member name="M:System.MessageBus.MulticastRoute.#ctor(System.Uri,System.MessageBus.MulticastRouteEntry[],System.MessageBus.Filter)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.MulticastRoute"/> class.</para>
            </summary>
            <param name="destination">The URI for which this is a route.</param>
            <param name="nextHops">The URIs where a message that matches this route should be forwarded.</param> 
            <param name="filter">Additional logic to qualify this route.</param>
        </member>
        <member name="M:System.MessageBus.MulticastRoute.#ctor(System.Uri,System.MessageBus.MulticastRouteEntry[],System.Boolean)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.MulticastRoute"/> class.</para>
            </summary>
            <param name="destination">The URI for which this is a route.</param>
            <param name="nextHops">The URIs where a message that matches this route should be forwarded.</param> 
            <param name="continueProcessing">Continue looking for more specific routes even if this route matches.</param>
        </member>
        <member name="M:System.MessageBus.MulticastRoute.#ctor(System.Uri,System.MessageBus.MulticastRouteEntry[],System.MessageBus.Filter,System.Boolean)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.MulticastRoute"/> class.</para>
            </summary>
            <param name="destination">The URI for which this is a route.</param>
            <param name="nextHops">The URIs where a message that matches this route should be forwarded.</param> 
            <param name="filter">Additional logic to qualify this route.</param>
            <param name="continueProcessing">Continue looking for more specific routes even if this route matches.</param>
        </member>
        <member name="M:System.MessageBus.MulticastRoute.#ctor(System.Uri,System.MessageBus.MulticastRouteEntry[],System.MessageBus.Filter,System.Boolean,System.Guid)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.MulticastRoute"/> class.</para>
            </summary>
            <param name="destination">The URI for which this is a route.</param>
            <param name="nextHops">The URIs where a message that matches this route should be forwarded.</param> 
            <param name="filter">Additional logic to qualify this route.</param>
            <param name="continueProcessing">Continue looking for more specific routes even if this route matches.</param>
            <param name="routeID">The unique ID of this route.</param>
        </member>
        <member name="M:System.MessageBus.MulticastRoute.SerializeToPolicy(System.Xml.XmlWriter)">
            <summary>
               <para>Writes out this route to policy</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.MulticastRoute.GetNextHops(System.MessageBus.Message)">
            <summary>
               <para>Returns where the message should go next</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.MulticastRoute.DeserializeFromPolicy(System.MessageBus.Policy,System.Xml.XmlNode)">
            <summary>
               <para>Recreate the route from the policy and the associated XML.</para>
            </summary>
            <param name='policy'>Policy where this route is being deserialized from</param>
            <param name='node'>Route specific Xml</param>
        </member>
        <member name="T:System.MessageBus.MulticastRouteEntry">
            <summary>
               <para>Route entry that allows multicasting among destinations.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.RouteEntry">
            <summary>
               <para>Base class for Route Entries.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RouteEntry.#ctor(System.Uri)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.RouteEntry"/> class.</para>
            </summary>
            <param name="nextHop">The URI which this route entry represents.</param>
        </member>
        <member name="P:System.MessageBus.RouteEntry.Enabled">
            <summary>
               <para>true - This route entry is available for use. Messages may be forwarded to the URI represented by this entry
               false - otherwise</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.RouteEntry.NextHop">
            <summary>
               <para>The URI which this route entry represents.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.MulticastRouteEntry.#ctor(System.Uri)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.MulticastRouteEntry"/> class.</para>
            </summary>
            <param name="nextHop">The URI which this route entry represents.</param>
        </member>
        <member name="T:System.MessageBus.ObjectContent">
            <summary>
            <para>Represents an <see langword="object"/> in <see cref="T:System.MessageBus.MessageContent"/> .</para>
            </summary>
            <remarks>
               <para>When an application creates a new Message, its 
                  MessageContent may be an arbitrary <see langword="object"/> wrapped in an
                  instance of ObjectContent. </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.ObjectContent.#ctor(System.Object)">
            <overload>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.ObjectContent"/> class.</para>
            </overload>
            <summary>
               <para>Initializes ObjectContent given an 
               <see langword="object"/> .</para>
            </summary>
            <param name="obj">The <see langword="object"/> that is the <see cref="T:System.MessageBus.MessageContent"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="obj"/> is <see langword="null"/></exception>
            <remarks>
            <para>Equivalent to ObjectContent(<paramref name="obj"/>, <paramref name="obj"/> 
            != <see langword="null"/> ? <paramref name="obj"/>.GetType() : <see langword="null"/>)</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.ObjectContent.#ctor(System.Object,System.Type)">
            <summary>
               <para>Initializes ObjectContent given an 
               <see langword="object"/> and a <see cref="T:System.Type"/> .</para>
            </summary>
            <param name="obj">The <see langword="object"/> that is the <see cref="T:System.MessageBus.MessageContent"/></param>
            <param name=" type">The <see cref="T:System.Type"/> of <paramref name="obj"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="obj"/> or <paramref name="type"/> are <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="obj"/> is not of <see cref="T:System.Type"/> <paramref name="type"/></exception>
        </member>
        <member name="M:System.MessageBus.ObjectContent.Clone">
            <summary>
               <para>Creates a new ObjectContent that is a copy of the current instance.</para>
            </summary>
            <remarks>
               <para>Makes a deep clone of the ObjectContent.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.ObjectContent.GetObject(System.Type)">
            <summary>
               <para>Converts the ObjectContent into an 
               <see langword="object"/> .</para>
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of the <see langword="object"/> to convert the ObjectContent into</param>
            <returns>
            <para>An <see langword="object"/> of the given <see cref="T:System.Type"/> that represents the ObjectContent.</para>
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="type"/> is <see langword="null"/></exception>
        </member>
        <member name="M:System.MessageBus.ObjectContent.WriteTo(System.Xml.XmlWriter)">
            <summary>
            <para>Serialize the ObjectContent using the <see cref="T:System.Xml.XmlWriter"/> ’s encoding.</para>
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/> to serialize the properties into </param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="writer"/> is <see langword="null"/></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:System.MessageBus.XmlTextWriterNoDeclaration" -->
        <member name="T:System.MessageBus.PipelineBuilder">
            <summary>
            <para>A <see cref="T:System.MessageBus.Pipeline"/> factory.</para>
            </summary>
            <remarks>
            <para>One drawback of <see cref="T:System.MessageBus.Pipeline"/>s is that it can be difficult to calculate the 
               correct ordering of <see cref="T:System.MessageBus.IMessageHandler"/>s without complete knowledge of the effects of
               each <see cref="T:System.MessageBus.IMessageHandler"/> on the <see cref="T:System.MessageBus.Message"/>. For instance, when a
               development team is building a set of <see cref="T:System.MessageBus.IMessageHandler"/>s, it can be difficult to
               understand the appropriate interleaving of the <see cref="T:System.MessageBus.IMessageHandler"/>s. PipelineBuilder facilitates this.</para>
            <para>A PipelineBuilder takes a declarative description of the ordering of <see cref="T:System.MessageBus.IMessageHandler"/>s and builds a <see cref="T:System.MessageBus.Pipeline"/> with the <see cref="T:System.MessageBus.IMessageHandler"/>s in the correct order. <see cref="T:System.MessageBus.Stage"/> and 
            <see cref="T:System.MessageBus.StageAlias"/> are used to describe the ordering of <see cref="T:System.MessageBus.IMessageHandler"/>s. </para>
            <para>Here is an example. Assume that each <see cref="T:System.MessageBus.Stage"/> is named with a single 
            letter. Assume that a <see cref="T:System.MessageBus.StageAlias"/> is written as { b, x, { x, e, f } }, where b
            is refined into { x, e, f }, and x is the placeholder for any <see cref="T:System.MessageBus.IMessageHandler"/> attached to b. (This <see cref="T:System.MessageBus.StageAlias"/> inserts two
            <see cref="T:System.MessageBus.Stage"/>s { e, f } 
            after b.) Given:</para>
            <list type="bullet"><item>
               <term>
                  Initial <see cref="T:System.MessageBus.Stage"/>s = { a, b, c }</term>
            </item>
            <item>
               <term>
               <see cref="T:System.MessageBus.StageAlias"/>es = { b, x, { x, e, f }}, { c, y, { g, h, y 
                  }, { x, z, { i, z, j } }</term>
            </item>
            </list>
            <para>Substituting the <see cref="T:System.MessageBus.StageAlias"/>es into the initial <see cref="T:System.MessageBus.Stage"/>s gives:</para>
            <list type="bullet"><item>
               <term>
                  Substitutes as { a, i, z, j, e, f, g, h, y }</term>
            </item>
            </list>
            <para>And resolving back to the original <see cref="T:System.MessageBus.Stage"/>s gives:</para>
            <list type="bullet"><item>
               <term>
                  Resolves as { a, i, b, j, e, f, g, h, c }</term>
            </item>
            </list>
            <para> To build a <see cref="T:System.MessageBus.Pipeline"/>, a
            PipelineBuilder also needs to know which <see cref="T:System.MessageBus.IMessageHandler"/>s are associated with which
            <see cref="T:System.MessageBus.Stage"/>s. As an efficiency step, the relationship 
            between <see cref="T:System.MessageBus.IMessageHandler"/>s and <see cref="T:System.MessageBus.Stage"/>s is encoded as a pair of
            arrays, where the ith IMessageHandler in the first array is associated with the
            ith Stage in the second array. </para>
            <para>A PipelineBuilder may be used to create more than one 
            <see cref="T:System.MessageBus.Pipeline"/> from the same description of <see cref="T:System.MessageBus.Stage"/>s. To 
               make this efficient, the PipelineBuilder constructor takes the <see cref="T:System.MessageBus.Stage"/>
               information and ToPipeline creates the <see cref="T:System.MessageBus.Pipeline"/>
               s.</para>
            <para>Note that PipelineBuilder isn't doing anything one couldn't, in principle, do 
               in code. The resulting <see cref="T:System.MessageBus.Pipeline"/>(s) could have been created by constructing a
            <see cref="T:System.MessageBus.Pipeline"/> and adding <see cref="T:System.MessageBus.IMessageHandler"/>s to its collection. PipelineBuilder is a 
               convenience mechanism to help minimize the need to centralize knowledge about
            <see cref="T:System.MessageBus.IMessageHandler"/> ordering.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PipelineBuilder.#ctor(System.MessageBus.Stage[],System.MessageBus.StageAlias[],System.MessageBus.Stage[])">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.PipelineBuilder"/> class.</para>
            </summary>
            <param name="stages">An ordered list of initial, unique <see cref="T:System.MessageBus.Stage"/>s</param>
            <param name=" aliases">A list of <see cref="T:System.MessageBus.StageAlias"/>es</param>
            <param name=" pipelineStages">An ordered list of <see cref="T:System.MessageBus.Stage"/>s that is parallel to the list of <see cref="T:System.MessageBus.IMessageHandler"/>s passed to ToPipeline</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="stages"/>, <paramref name="aliases"/>, or <paramref name="pipelineStages"/> are <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">If any <see cref="T:System.MessageBus.Stage"/> in <paramref name="pipelineStages"/> is not defined applying <paramref name="aliases"/> to <paramref name="stages"/></exception>
            <exception cref="T:System.ArgumentException">If there are any duplicate <see cref="T:System.MessageBus.Stage"/>s</exception>
            <exception cref="T:System.ArgumentException">If any <see cref="T:System.MessageBus.StageAlias"/> in <paramref name="aliases"/> recurses</exception>
            <remarks>
            <para><paramref name="aliases"/> may be an empty array.</para>
            <para><paramref name="pipelineStages"/> should not be empty. If it is, there will be no 
            <see cref="T:System.MessageBus.IMessageHandler"/>s in the resulting <see cref="T:System.MessageBus.Pipeline"/>s.</para>
            <para>The PipelineBuilder may be used to create multiple <see cref="T:System.MessageBus.Pipeline"/>s 
            that share the same ordered list of <see cref="T:System.MessageBus.Stage"/>s. Once created,
            there is no way to change the definition of <see cref="T:System.MessageBus.Stage"/>s within a PipelineBuilder.
            To do this, one must construct a new PipelineBuilder.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PipelineBuilder.Substitute(System.MessageBus.Stage,System.MessageBus.StageAlias[],System.Collections.ArrayList)">
            <summary>
            Here's an example of the resolution process:
             Initial stages = { a, b, c }
             Aliases = { b, x, { x, e, f }}, { c, y, { g, h, y }, { x, z, { i, z, j } }
             Substitutes as { a, i, z, j, e, f, g, h, y }
             Resolves as { a, i, b, j, e, f, g, h, c }
            </summary>
            <param name="stage"></param>
            <param name="aliases"></param>
            <param name="flattened"></param>
        </member>
        <member name="M:System.MessageBus.PipelineBuilder.ToPipeline(System.MessageBus.IMessageHandler[])">
            <summary>
            <para>Generates a <see cref="T:System.MessageBus.Pipeline"/> .</para>
            </summary>
            <param name="handlers">An ordered list of <see cref="T:System.MessageBus.IMessageHandler"/>s that must be parallel to the <see cref="T:System.MessageBus.Stage"/>s passed to the constructor</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="handlers"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="handlers"/>.Length != number of <see cref="T:System.MessageBus.Stage"/>s passed to the constructor as "pipelineStages"</exception>
            <remarks>
            <para>ToPipeline takes a list of <see cref="T:System.MessageBus.IMessageHandler"/>s and creates a <see cref="T:System.MessageBus.Pipeline"/>. The 
               items in this list of <see cref="T:System.MessageBus.IMessageHandler"/>s must be ordered in agreement with the
            <see cref="T:System.MessageBus.Stage"/>s passed to the constructor 
               ("pipelineStages"); there must be exactly the same number of items in each list.
               The resulting <see cref="T:System.MessageBus.Pipeline"/> has exactly as many <see cref="T:System.MessageBus.IMessageHandler"/>s as are passed to ToPipeline, and these
            <see cref="T:System.MessageBus.IMessageHandler"/>s are in the order defined by the <see cref="T:System.MessageBus.Stage"/>s and 
            <see cref="T:System.MessageBus.StageAlias"/>es passed to the PipelineBuilder 
               constructor.</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.Policy">
            <summary>
               <para>Encapsulates a Policy.</para>
            </summary>
            <remarks>
               <para>Not generally manipulated directly. Constructed by the Policy Manager from 
                  policies headers in messages, and by Policy Extensions when creating policies
                  headers.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Policy.#ctor">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.Policy"/> class.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Policy.#ctor(System.MessageBus.Policy)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.Policy"/> class that is a copy of an existing 
               policy.</para>
            </summary>
            <param name="policy">The policy to be cloned.</param>
        </member>
        <member name="M:System.MessageBus.Policy.Load(System.Xml.XmlReader)">
            <summary>
               <para>Deserializes and creates a 
                  new Policy object from XML.</para>
            </summary>
            <param name='reader'>Reader over XML containing Policy </param>
            <returns>
               <para>Newly created Policy object.</para>
            </returns>
            <remarks>
               <para> Reverse of WriteTo.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Policy.WriteTo(System.Xml.XmlWriter)">
            <summary>
               <para>Writes a Policy object to XML.</para>
            </summary>
            <param name='writer'>Points to where XML should be written.</param>
            <remarks>
               <para>Reverse of Load.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Policy.System#ICloneable#Clone">
            <summary>
               <para>Clones this policy object.</para>
            </summary>
            <returns>
               <para>Object that is the Policy clone.</para>
            </returns>
            <remarks>
               <para>Returned Policy an be cast to a Policy object.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Policy.DestinationPrefix">
            <summary>
               <para>Gets or sets destination prefix URI.</para>
            </summary>
            <remarks>
               <para>This part of the policy scope is matched against a 
                  message's destination (top most forward via path element). The domain is the basis for evaluation
                  of whether a sender of a policy is trusted.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Policy.ExpiresAt">
            <summary>
               <para> Gets or sets when the policy will expire in local 
                  time.</para>
            </summary>
            <remarks>
               <para> Using the UTC version is recommended.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Policy.UtcExpiresAt">
            <summary>
               <para> Gets or sets when the policy will expire in universal 
                  coordinated time (UTC).</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Policy.Filter">
            <summary>
               <para>Gets or sets the Filter object that defines 
                  the scope of messages to which this policy applies.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Policy.PolicyID">
            <summary>
               <para>Get or set the policy identifier used to refer to the 
                  policy when serialized to XML.</para>
            </summary>
            <remarks>
               <para>Policy Manager will only cache the latest policy received with a 
                  particular policy identifier.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Policy.PolicyStatements">
            <summary>
               <para>Gets the collection of Policy Statements included in this Policy.</para>
            </summary>
            <remarks>
               <para>Policy Statements can be added to a Policy by adding them to this 
                  collection.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Policy.RoleType">
            <summary>
               <para>Gets or sets the Policy Role Type.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.PolicyCache">
            <summary>
               <para>Where policies are stored in a Policy Manager.</para>
            </summary>
            <remarks>
               <para> Only general use is to pre-populate a Policy Manager with policies.</para>
               <para>Threadsafe.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PolicyCache.#ctor(System.Int32)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.PolicyCache"/> class.</para>
            </summary>
            <param name="cacheWeight">Weight used for cache trimming.</param>
        </member>
        <member name="M:System.MessageBus.PolicyCache.Add(System.MessageBus.Policy,System.Boolean)">
            <summary>
               <para> Adds a policy to the policy cache.</para>
            </summary>
            <param name='policy'>The policy to be added.</param>
            <param name=' permanent'>Flag whether policy cannot be trimmed from the cache.</param>
        </member>
        <member name="M:System.MessageBus.PolicyCache.Clear">
            <summary>
               <para>Removes all policies from the cache.</para>
            </summary>
            <remarks>
               <para>Including policies marked as permanent.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PolicyCache.GetSnapshot">
            <summary>
               <para>Returns an array of Policies present in the cache at the 
                  time of the call.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PolicyCache.Remove(System.MessageBus.Policy)">
            <summary>
               <para>Removes the passed policy from the policy cache.</para>
            </summary>
            <param name='policy'>The policy to be removed from the cache.</param>
            <remarks>
               <para>If a policy to be removed is at a particular level in the namespace 
                  heirarchy, then all policies with names at and below that level are removed as well
                  for consistency.</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.PolicyExtension">
            <summary>
               <para> Abstract class for adding functionality to the PolicyManager.</para>
            </summary>
            <remarks>
               <para>This is the mechanism by which policy statement processing can be extended. A 
                  PolicyExtension implements both creating policy and policy statements (policy
                  generation), and policy application for one or more classes of policy
                  statements.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PolicyExtension.#ctor">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.PolicyExtension"/> class.</para>
            </summary>
            <remarks>
               <para>The PolicyExtension must be extended by a class that inherits from it to be 
                  useful.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PolicyExtension.GetSendStages">
            <summary>
               <para> The stages in the pipeline inside of the Policy
                  Manager needed by this PolicyExtension.</para>
            </summary>
            <returns>
               <para>Array of Stages.</para>
            </returns>
            <remarks>
               <para>Analogous to the GetXxxStages in the <see cref="T:System.MessageBus.PortExtension"/> class. 
               The stages correspond to where the <see cref="T:System.MessageBus.CompiledPolicyStatements"/>.GetSendHandlers() will be added to 
               the pipeline created for each endpoint. Used for policy application.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PolicyExtension.GetSendAliases">
            <summary>
               <para>The stage aliases for the pipeline inside of the Policy
                  Manager needed by this Policy Extension.</para>
            </summary>
            <remarks>
               <para>Analogous to the GetXxxAliases in the <see cref="T:System.MessageBus.PortExtension"/> class.
               The stage aliases used in creating the pipeline created for each endpoint. Used for policy 
                  application.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PolicyExtension.GetRecognizedPolicyStatements">
            <summary>
               <para>The qualified names of Policy Statements that can be handled by this Policy Extension.</para>
            </summary>
            <returns>
               <para>The qualified names (namespace and name) of Policy
                  Statements.</para>
            </returns>
            <remarks>
               <para>The Policy Extension is expected to be able to compile any Policy Statement that has a qualified 
                  name from this list. Used for policy application.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PolicyExtension.GetPolicies(System.MessageBus.Message)">
            <summary>
               <para>Returns the generated policies for this GetPolicy
                  message.</para>
            </summary>
            <param name='message'>The GetPolicy message</param>
            <remarks>
               <para>Gives the policies this Policy Extension wants the Policy Manager to send to the 
                  requestor in response to a GetPolicy message. Used for policy generation.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PolicyExtension.CompilePolicyStatements(System.MessageBus.Policy[],System.MessageBus.PolicyStatement[])">
            <summary>
               <para>Takes policy statements from an XML format to one that 
                  can be executed more quickly.</para>
            </summary>
            <param name='policies'>The policies from which the policyStatements came</param>
            <param name='policyStatements'>The Policy Statements to compile</param>
            <returns>
               <para> Null if
                  the Policy Statements cannot be compiled.</para>
            </returns>
            <remarks>
               <para> The Policy Statements will all have the same qualified
                  name. The Policy Statement and Policy arrays have the same number of
                  elements. A particular Policy Statement array entry came from the
                  corresponding Policy in the Policy array. For example, if the scope of the
                  policy that help a policy statement is useful in processing the policy
                  statement, the scope can be extracted from the policy array.</para>
               <para>The Compiled Policy Statements are expected to encapsulate all important 
                  information for this Policy Extension, so the policy statements can be
                  applied to a message. Used for policy application.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.PolicyExtension.PolicyManager">
            <summary>
            <para>Gets the <see cref="T:System.MessageBus.PolicyManager"/> that this PolicyExtension was added to.</para>
            </summary>
            <value>
            <para>The <see cref="T:System.MessageBus.PolicyManager"/> that this PolicyExtension was added to.</para>
            </value>
            <remarks>
            <para>When a PolicyExtension is added to a <see cref="T:System.MessageBus.PolicyManager"/>, the PolicyManager property is set 
               with that <see cref="T:System.MessageBus.PolicyManager"/>.</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.PolicyExtensionCollection">
            <summary>
               <para>A collection of PolicyExtensions.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PolicyExtensionCollection.#ctor(System.MessageBus.PolicyManager)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.PolicyExtensionCollection"/> class.</para>
            </summary>
            <param name="policyManager">The Policy Manager in which this Policy Extension Collection is contained.</param>
        </member>
        <member name="M:System.MessageBus.PolicyExtensionCollection.Add(System.MessageBus.PolicyExtension)">
            <summary>
               <para>Adds a Policy Extension to the collection.</para>
            </summary>
            <param name='policyExtension'>The Policy Extension to be added to the collection.</param>
            <returns>
               <para>Index where policyExtension was added.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.PolicyExtensionCollection.Contains(System.MessageBus.PolicyExtension)">
            <summary>
               <para>Returns true if the policyExtension is already in the collection.</para>
            </summary>
            <param name='policyExtension'>The Policy Extension whose presence is questioned. </param>
        </member>
        <member name="M:System.MessageBus.PolicyExtensionCollection.CopyTo(System.MessageBus.PolicyExtension[],System.Int32)">
            <summary>
               <para>Same behavior as the System.Collections.List CopyTo method.</para>
            </summary>
            <param name='array'>Where policy extension is to be copied.</param>
            <param name=' index'>Index of policy extension to be copied</param>
        </member>
        <member name="M:System.MessageBus.PolicyExtensionCollection.IndexOf(System.MessageBus.PolicyExtension)">
            <summary>
               <para>Returns the index (position) of a Policy Extension 
                  in the collection.</para>
            </summary>
            <param name='policyExtension'>The policy extension whose index is desired.</param>
            <remarks>
               <para>Same behavior as System.Collections.List IndexOf method.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PolicyExtensionCollection.Insert(System.Int32,System.MessageBus.PolicyExtension)">
            <summary>
               <para>Inserts a Policy Extension in the collection at an index position.</para>
            </summary>
            <param name='index'>Where the policy extension should be inserted.</param>
            <param name=' policyExtension'>The policy extension to be inserted.</param>
            <remarks>
               <para>Same behavior as System.Collections.List Insert method.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PolicyExtensionCollection.Remove(System.MessageBus.PolicyExtension)">
            <summary>
               <para>Removes a Policy Extension from the collection.</para>
            </summary>
            <param name='policyExtension'>The policy extension to be removed.</param>
        </member>
        <member name="M:System.MessageBus.PolicyExtensionCollection.OnRemoveComplete(System.Int32,System.Object)">
            <summary>
               <para>Exposes List implementation method for classes that inherit from Policy 
                  Extension Collection.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PolicyExtensionCollection.OnClearComplete">
            <summary>
               <para>Exposes List implementation method for classes that 
                  inherit from Policy Extension Collection.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PolicyExtensionCollection.OnInsertComplete(System.Int32,System.Object)">
            <summary>
               <para>Exposes List implementation method for classes that 
                  inherit from Policy Extension Collection.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PolicyExtensionCollection.OnSetComplete(System.Int32,System.Object,System.Object)">
            <summary>
               <para>Exposes List implementation method for classes that 
                  inherit from Policy Extension Collection.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PolicyExtensionCollection.OnValidate(System.Object)">
            <summary>
               <para>Exposes List implementation method for classes that 
                  inherit from Policy Extension Collection.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PolicyExtensionCollection.OnRemove(System.Int32,System.Object)">
            <summary>
               <para>Exposes List implementation method for classes that 
                  inherit from Policy Extension Collection.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PolicyExtensionCollection.OnInsert(System.Int32,System.Object)">
            <summary>
               <para>Exposes List implementation method for classes that 
                  inherit from Policy Extension Collection.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PolicyExtensionCollection.OnSet(System.Int32,System.Object,System.Object)">
            <summary>
               <para>Exposes List implementation method for classes that 
                  inherit from Policy Extension Collection.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.PolicyExtensionCollection.Item(System.Int32)">
            <summary>
               <para>Get or set access to a policy extension as an 
                  indexed array entry.</para>
            </summary>
            <param name='index'>The policy extension array position to be accessed. </param>
        </member>
        <member name="T:System.MessageBus.PolicyManager">
            <summary>
               <para>Provides policy support to a port.</para>
            </summary>
            <remarks>
               <para>Other objects that interact with policy, should take the Policy Manager in their
                  constructor* and add themselves to the appropriate collection (PolicyExtension,
                  Policy, PolicyProfile).
                  
                  * Or if starting from config, find the PolicyManager in the MessageBusConfiguration object
                  during the WireUp method. For example, 
                  "PolicyManager policyManager = configuration[typeof(PolicyManager)] as PolicyManager;"
                  </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PolicyManager.#ctor">
            <summary>
               Initializes a new instance of the <see cref="T:System.MessageBus.PolicyManager"/>
               class.
            </summary>
        </member>
        <member name="M:System.MessageBus.PolicyManager.#ctor(System.MessageBus.Port,System.MessageBus.RequestManager)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.PolicyManager"/> class.</para>
            </summary>
            <param name="port">Port to which the PolicyManager will be attached as a PortExtension.</param>
            <param name=" requestManager">Used to send GetPolicy messages.  This relationship must exist 
            between the first two parameters requestManager.Port == port.</param>
            <remarks>
               <para>Same as PolicyManager(port, requestManager,100, 30).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PolicyManager.#ctor(System.MessageBus.Port,System.MessageBus.RequestManager,System.Int32,System.Int32)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.PolicyManager"/> class.</para>
            </summary>
            <param name="port">Port to which the PolicyManager will be attached as a PortExtension.</param>
            <param name=" requestManager">Used to send GetPolicy messages.  This relationship must exist 
            between the first two parameters requestManager.Port == port.</param>
            <param name=" destinationCacheWeight">The number of policies to store in the destination policy cache.  Used for cache trimming.</param>
            <param name=" profileCacheWeight">The number of profiles to store in the profile cache.  Used for cache trimming.</param>
            <remarks>
               <para>Generally, cache weights should not be explicitly set. Instead, 
                  PolicyManager(port,requestManager) should be used instead.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PolicyManager.BeginGetPolicies(System.MessageBus.Message,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for GetPolicies.</para>
            </summary>
            <param name='message'>Message for which policies are returned</param>
            <param name=' callback'>See asynchronous design pattern</param>
            <param name=' state'>See asynchronous design pattern</param>
            <returns>
               <para>See asynchronous design pattern</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.PolicyManager.BeginGetPolicyProfile(System.Uri,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for GetPolicyProfile.</para>
            </summary>
            <param name='url'>URL where PolicyProfile can be retrieved</param>
            <param name='callback'>See asynchronous design pattern</param>
            <param name='state'>See asynchronous design pattern</param>
            <returns>
               <para>See asynchronous design pattern</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.PolicyManager.EndGetPolicies(System.IAsyncResult)">
            <summary>
               <para>Asynchronous end for GetPolicies.</para>
            </summary>
            <param name='result'>See asynchronous design pattern</param>
            <returns>
               <para>See GetPolicies.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.PolicyManager.EndGetPolicyProfile(System.IAsyncResult)">
            <summary>
               <para>Asynchronous end for GetPolicyProfile.</para>
            </summary>
            <param name='result'>See asynchronous design pattern</param>
            <returns>
               <para>See GetPolicyProfile.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.PolicyManager.GetPolicies(System.MessageBus.Message)">
            <summary>
               <para>Returns the set of policies that match the message.</para>
            </summary>
            <param name='message'>Message for which policies should be found</param>
            <returns>
               <para>Collection of Policies matching the message.</para>
            </returns>
            <remarks>
               <para>If no policies in the cache match the message, a 
                  GetPolicy request message is sent.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PolicyManager.GetPolicyProfile(System.Uri)">
            <summary>
               <para>Get a policy profile (a set of policy statements) for a
                  given URI.</para>
            </summary>
            <param name='url'>URL where PolicyProfile can be retrieved</param>
            <returns>
               <para>Policy profile returned from the requested URL.</para>
            </returns>
            <remarks>
               <para>This checks a local cache, then sends a message if the policy profile is not 
                  in the cache.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.PolicyManager.DropUntrustedPolicies">
            <summary>
               Gets or sets a value indicating whether untrusted
               policies should be dropped.
            </summary>
            <remarks>
               <para>Not for general use. Default value is false.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.PolicyManager.TrustTestRootCertificate">
            <summary>
               <para>Gets or sets a value indicating whether the test root 
                  certificate should be trusted.</para>
            </summary>
            <remarks>
               <para>Not for general use. Default value is false.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.PolicyManager.DestinationPolicyCache">
            <summary>
               <para>Gets or sets Destination Policy Cache.</para>
            </summary>
            <remarks>
               <para>Not for general use. Contains the PolicyCache object 
                  used for the destination (send channel) policy cache. Can be used to populate the
                  policy cache with entries.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.PolicyManager.PolicyExtensions">
            <summary>
               <para>Gets or sets Policy Extension collection.</para>
            </summary>
            <remarks>
               <para>Contains the set of Policy Extensions installed on the this Policy Manager. 
                  Generally only used by Policy Extensions to add themselves to the Policy
                  Manager.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.PolicyManager.PolicyProfileCache">
            <summary>
               <para>Gets or sets the Policy Profile Cache.</para>
            </summary>
            <remarks>
               <para>Not for general use. Can be used to populate the profile 
                  cache with entries.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.PolicyManager.Port">
            <summary>
               <para>Gets or sets Port.</para>
            </summary>
            <value>
               <para>Port to which the PolicyManager is added as a Port Extension.</para>
            </value>
            <remarks>
               <para>Normally only used when PolicyManager was initialized with the default 
                  constructor.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.PolicyManager.RequestManager">
            <summary>
               <para>Gets or sets the RequestManager.</para>
            </summary>
            <value>
               <para>RequestManager used to send GetPolicy messages.</para>
            </value>
            <remarks>
               <para>Normally only used when PolicyManager was initialized with the default 
                  constructor.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.PolicyManager.X509Certificate">
            <summary>
               <para> 
                  Gets or
                  sets the X509 certificate used for signing policy
                  headers. </para>
            </summary>
            <remarks>
               <para>It is not possible to change the certificate once the port has been 
                  opened.</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.PolicyProfile">
            <summary>
               <para>A named collection of Policy Statements that can be included in 
                  one or more Policies by a Reference Policy Statement.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PolicyProfile.#ctor">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.PolicyProfile"/> class.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PolicyProfile.Load(System.Xml.XmlReader)">
            <summary>
               <para>Deserializes an XML policy profile into a policy profile object.</para>
            </summary>
            <param name='xmlPolicy'>The policy profile in XML format including the "item" tag.</param>
            <returns>
               <para>Policy Profile object loaded from the XML.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.PolicyProfile.WriteTo(System.Xml.XmlWriter)">
            <summary>
               <para>Serializes this Policy Profile to XML</para>
            </summary>
            <param name='writer'>Points to where XML Policy Profile should be placed.</param>
        </member>
        <member name="P:System.MessageBus.PolicyProfile.PolicyStatements">
            <summary>
               <para>Gets the collection of Policy Statements contained in the Policy Profile.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.PolicyProfile.Url">
            <summary>
               <para>Gets and sets the URL name of Policy Profile.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.PolicyProfileCache">
            <summary>
               <para>Used by the Policy Manager to contain a set of Policy Profiles.</para>
            </summary>
            <remarks>
               <para>Threadsafe.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PolicyProfileCache.#ctor(System.Int32)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.PolicyProfileCache"/> class.</para>
            </summary>
            <param name="cacheWeight">Weight used for cache tirmming.</param>
        </member>
        <member name="M:System.MessageBus.PolicyProfileCache.Add(System.MessageBus.PolicyProfile,System.Boolean)">
            <summary>
               <para>Adds a Policy Profile to the Policy Profile Cache.</para>
            </summary>
            <param name='policyProfile'>The policy profile to be added.</param>
            <param name=' permanent'>fFag whether the policy profile cannot be trimmed from the cache.</param>
        </member>
        <member name="M:System.MessageBus.PolicyProfileCache.Clear">
            <summary>
               <para>Removes all Policy Profiles from the cache.</para>
            </summary>
            <remarks>
               <para>Including Policy Profiles marked as permanent.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PolicyProfileCache.GetSnapshot">
            <summary>
               <para>Returns an array of Policy Profiles present in the cache at the time of 
                  the call.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PolicyProfileCache.Remove(System.MessageBus.PolicyProfile)">
            <summary>
               <para>Removes a policy profile from the cache.</para>
            </summary>
            <param name='policyProfile'>The policy proflie to be removed from the cache.</param>
        </member>
        <member name="T:System.MessageBus.PolicySendStages">
            <summary>
               <para>Encapsulates the stages where policy extension send handlers are installed.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PolicySendStages.#ctor">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.PolicySendStages"/> class.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PolicySendStages.GetStages">
            <summary>
               <para>Gets the stages in order on the
                  IMessageHandler's in the policy transform pipeline.</para>
            </summary>
            <remarks>
               <para>Stages are during the policy application in the send pipeline. Will be used 
                  once for each endpoint.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.PolicySendStages.RoutingPolicy">
            <summary>
               <para>Gets the standard routing policy stage.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.PolicySendStages.SecurityPolicy">
            <summary>
               <para>Gets the standard security policy stage.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.PolicyStatement">
            <summary>
               <para>Abstract base Policy Statement class for a Policy or PolicyProfile.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PolicyStatement.#ctor(System.String,System.String)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.PolicyStatement"/> class.</para>
            </summary>
            <param name="name">The XML element name for this Policy Statement</param>
            <param name=" ns">The XML namespace for the Policy Statement element name.</param>
        </member>
        <member name="M:System.MessageBus.PolicyStatement.WriteTo(System.Xml.XmlWriter)">
            <summary>
               <para>When overridden in a derived class, serializes the 
                  Policy Statement to XML.</para>
            </summary>
            <param name='writer'>Points to where the Policy Statement should be written.</param>
        </member>
        <member name="M:System.MessageBus.PolicyStatement.GetXmlReader">
            <summary>
               <para>Returns an XML Reader for the Policy Statement.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.PolicyStatement.Name">
            <summary>
               <para>Gets the XML element name of this Policy Statement.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.PolicyStatement.Namespace">
            <summary>
               <para>Gets the namespace for the XML element name of this Policy Statement.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.PolicyStatementCollection">
            <summary>
               <para>A collection of Policy Statements.</para>
            </summary>
            <remarks>
               <para>Follows the pattern of System.Collections.List.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.PolicyStatementCollection.#ctor">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.PolicyStatementCollection"/> class.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PolicyStatementCollection.Add(System.MessageBus.PolicyStatement)">
            <summary>
               <para>Adds a Policy Statement to the collection.</para>
            </summary>
            <param name='policyStatement'>The Policy Statement to be added.</param>
            <returns>
               <para>The index of the added Policy Statement.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.PolicyStatementCollection.Contains(System.MessageBus.PolicyStatement)">
            <summary>
               <para>Returns whether or not a policyStatement is contained in the collection.</para>
            </summary>
            <param name='policyStatement'>The Policy Statement whose existence is questioned.</param>
            <returns>
               <para>True if the Policy Statement is present.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.PolicyStatementCollection.CopyTo(System.MessageBus.PolicyStatement[],System.Int32)">
            <summary>
               <para>Copies all the Policy Statements starting 
                  at the index position to the end of the collection to the array.</para>
            </summary>
            <param name='array'>Where the Policy Statements are copied.</param>
            <param name=' index'>Index of first Policy Statement to be copied.</param>
        </member>
        <member name="M:System.MessageBus.PolicyStatementCollection.IndexOf(System.MessageBus.PolicyStatement)">
            <summary>
               <para>Gets index of a Policy Statement in the collection.</para>
            </summary>
            <param name='policyStatement'>The Policy Statements whose index is desired.</param>
            <returns>
               <para>The index of the Policy Statement.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.PolicyStatementCollection.Insert(System.Int32,System.MessageBus.PolicyStatement)">
            <summary>
               <para>Inserts a Policy Statement in the collection at the index position.</para>
            </summary>
            <param name='index'>Index where Policy Statement should be placed.</param>
            <param name=' policyStatement'>The Policy Statement to be inserted.</param>
        </member>
        <member name="M:System.MessageBus.PolicyStatementCollection.Remove(System.MessageBus.PolicyStatement)">
            <summary>
               <para>Removes a Policy Statement from the collection.</para>
            </summary>
            <param name='policyStatement'>The Policy Statement to be removed.</param>
        </member>
        <member name="M:System.MessageBus.PolicyStatementCollection.OnValidate(System.Object)">
            <summary>
               <para>Overridden by classes inheriting from this collection to perform validation 
                  of a object when it is being added to the collectoin.</para>
            </summary>
            <param name='value'>The object to be validated.</param>
        </member>
        <member name="P:System.MessageBus.PolicyStatementCollection.Item(System.Int32)">
            <summary>
               <para>Gets and sets a Policy Statement from this 
                  collection as an array.</para>
            </summary>
            <param name='index'>The index of the Policy Statement to be accessed.</param>
        </member>
        <member name="T:System.MessageBus.Port">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Port.#ctor">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Port.#ctor(System.Uri)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Port.CanCreateReverseChannel(System.MessageBus.Message)">
            <summary>
               <para>Whether a Reverse Channel can be created from the given message.</para>
            </summary>
            <param name='message'>Candidate message to create a Reverse Channel for.</param>
            <returns>
               <para>true if the Routing Header of the message has a non-empty reverse path; false 
                  otherwise.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.Port.BeginClose(System.AsyncCallback,System.Object)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Port.BeginOpen(System.AsyncCallback,System.Object)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Port.Close">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Port.CreateForwardChannel(System.Uri)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Port.CreateForwardChannel(System.Uri[])">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Port.CreateForwardChannel(System.Uri[],System.MessageBus.ForwardAddressStyle)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Port.CreateReverseChannel(System.MessageBus.Message)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Port.CreateSendChannel">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Port.CreateSendChannel(System.Uri)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Port.EndClose(System.IAsyncResult)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Port.EndOpen(System.IAsyncResult)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Port.Open">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Port.CloseTimeout">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Port.Extensions">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Port.IsOpen">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Port.ReceiveChannel">
            <summary>
            <para>Gets the channel that processes received <see cref="T:System.MessageBus.Message"/> s.</para>
            </summary>
            <value>
            <para>The <see cref="T:System.MessageBus.ReceiveChannel"/> that processes <see cref="T:System.MessageBus.Message"/>s received by the Port.</para>
            </value>
            <exception cref="T:System.InvalidOperationException">If <see cref="P:System.MessageBus.ReceiveChannel.Handler"/> is set while the Port is open.</exception>
        </member>
        <member name="P:System.MessageBus.Port.ReceiveStatusChannel">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Port.SendStatusChannel">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Port.Transports">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Port.Url">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.PortReceiveStages">
            <summary>
               <para> Defines initial stages for all Port 
                  receive channels. Stages are in the following order: Spy
                  (first), Logging, Policy, Security, Route, DidUnderstand,
                  ReceiveReply, Handler (last).</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PortReceiveStages.GetStages">
            <summary>
               <para>Returns the initial set of Port receive channel stages in order.</para>
            </summary>
            <returns>
               <para>An array of stages, ordered according to their relative place in the 
                  pipeline.</para>
            </returns>
        </member>
        <member name="P:System.MessageBus.PortReceiveStages.DidUnderstand">
            <summary>
            <para>Where <see cref="T:System.MessageBus.MessageHeader"/>s that are marked Must 
               Understand are checked to see if they were, in fact, processed by some <see cref="T:System.MessageBus.IMessageHandler"/> .</para>
            </summary>
            <value>
               <para>http://schemas.microsoft.com/mb/2002/07/PortReceiveStages.DidUnderstand</para>
            </value>
        </member>
        <member name="P:System.MessageBus.PortReceiveStages.Logging">
            <summary>
            <para>Where the <see cref="T:System.MessageBus.Message"/> is logged.</para>
            </summary>
            <value>
               <para>http://schemas.microsoft.com/mb/2002/07/PortReceiveStages.Logging</para>
            </value>
        </member>
        <member name="P:System.MessageBus.PortReceiveStages.Policy">
            <summary>
               <para>Where unsolicted incoming policies are extracted from 
                  the <see cref="T:System.MessageBus.Message"/>
                  and stored in the
                  policy cache, and where Get Policy requests are handled.</para>
            </summary>
            <value>
               <para>http://schemas.microsoft.com/mb/2002/07/PortReceiveStages.Policy</para>
            </value>
        </member>
        <member name="P:System.MessageBus.PortReceiveStages.Handler">
            <summary>
            <para>Where the application <see cref="T:System.MessageBus.IMessageHandler"/> processes the <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <value>
               <para>http://schemas.microsoft.com/mb/2002/07/PortReceiveStages.Handler</para>
            </value>
        </member>
        <member name="P:System.MessageBus.PortReceiveStages.ReceiveReply">
            <summary>
            <para>Where Reply <see cref="T:System.MessageBus.Message"/>s are detected and passed to 
               the waiting request call.</para>
            </summary>
            <value>
               <para>http://schemas.microsoft.com/mb/2002/07/PortReceiveStages.ReceiveReply</para>
            </value>
        </member>
        <member name="P:System.MessageBus.PortReceiveStages.Route">
            <summary>
            <para> Where the <see cref="T:System.MessageBus.Message"/> is matched against routes in 
               the router. If a match occurs, the <see cref="T:System.MessageBus.Message"/>
               is forwarded to the next hop.</para>
            </summary>
            <value>
               <para>http://schemas.microsoft.com/mb/2002/07/PortReceiveStages.Route</para>
            </value>
        </member>
        <member name="P:System.MessageBus.PortReceiveStages.Security">
            <summary>
            <para>Where the security header of the <see cref="T:System.MessageBus.Message"/> is processed
               for signature and encryption requirements, and where
               token processing and authentication and authorization
               decisions are made.</para>
            </summary>
            <value>
               <para>http://schemas.microsoft.com/mb/2002/07/PortReceiveStages.Security</para>
            </value>
        </member>
        <member name="P:System.MessageBus.PortReceiveStages.Spy">
            <summary>
               <para> Where debugging and/or spy mechanisms hook the 
               <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <value>
               <para>http://schemas.microsoft.com/mb/2002/07/PortReceiveStages.Spy</para>
            </value>
        </member>
        <member name="T:System.MessageBus.PortReceiveStatusStages">
            <summary>
               <para>Defines initial stages for all Port receive status 
                  channels. Stages are in the following order: Spy (first),
                  SendFault, Handler (last).</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PortReceiveStatusStages.GetStages">
            <summary>
               <para>Returns the initial set of Port receive status channel 
                  stages in order.</para>
            </summary>
            <returns>
               <para>An array of stages, ordered according to their relative 
                  place in the pipeline.</para>
            </returns>
        </member>
        <member name="P:System.MessageBus.PortReceiveStatusStages.Handler">
            <summary>
            <para>Where the application <see cref="T:System.MessageBus.IMessageHandler"/> processes the 
               exception <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <value>
               <para>http://schemas.microsoft.com/mb/2002/07/PortReceiveStatusStages.Handler</para>
            </value>
        </member>
        <member name="P:System.MessageBus.PortReceiveStatusStages.SendFault">
            <summary>
            <para>Where a fault <see cref="T:System.MessageBus.Message"/> is constructed from the 
               exception <see cref="T:System.MessageBus.Message"/>, and where the fault <see cref="T:System.MessageBus.Message"/> is
               returned to the sender.</para>
            </summary>
            <value>
               <para>http://schemas.microsoft.com/mb/2002/07/PortReceiveStatusStages.SendFault</para>
            </value>
        </member>
        <member name="P:System.MessageBus.PortReceiveStatusStages.Spy">
            <summary>
            <para>Where debugging and/or spy mechanisms hook the exception <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <value>
               <para>http://schemas.microsoft.com/mb/2002/07/PortReceiveStatusStages.Spy</para>
            </value>
        </member>
        <member name="T:System.MessageBus.PortSendStages">
            <summary>
               <para> 
                  Defines initial stages for all Port send
                  channels. Stages are in the following order: Address
                  (first), Policy, Security, Logging, Transmit, Spy (last).</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PortSendStages.GetStages">
            <summary>
               <para>Returns the initial set of Port send channel stages in order.</para>
            </summary>
            <returns>
               <para>An array of stages, ordered according to their relative place in the 
                  pipeline. </para>
            </returns>
        </member>
        <member name="P:System.MessageBus.PortSendStages.Address">
            <summary>
            <para>Where a <see cref="T:System.MessageBus.RoutingHeader"/> is added to the <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <value>
               <para>http://schemas.microsoft.com/mb/2002/07/PortSendStages.Address </para>
            </value>
        </member>
        <member name="P:System.MessageBus.PortSendStages.Spy">
            <summary>
            <para>Where debugging and/or spy mechanisms hook the <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <value>
               <para>http://schemas.microsoft.com/mb/2002/07/PortSendStages.Spy</para>
            </value>
        </member>
        <member name="P:System.MessageBus.PortSendStages.Logging">
            <summary>
            <para>Where the <see cref="T:System.MessageBus.Message"/> is logged.</para>
            </summary>
            <value>
               <para>http://schemas.microsoft.com/mb/2002/07/PortSendStages.Logging</para>
            </value>
        </member>
        <member name="P:System.MessageBus.PortSendStages.Policy">
            <summary>
            <para>Where policy is retrieved and applied to the <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <value>
               <para>http://schemas.microsoft.com/mb/2002/07/PortSendStages.Policy</para>
            </value>
        </member>
        <member name="P:System.MessageBus.PortSendStages.Security">
            <summary>
            <para>Where the <see cref="T:System.MessageBus.Message"/> is formulated to be 
               compliant with the recipient's security requirements. This includes signing,
               encrypting, and attaching relevant tokens that will be used by the recipient to
               make authentication and authorization decisions.</para>
            </summary>
            <value>
               <para>http://schemas.microsoft.com/mb/2002/07/PortSendStages.Security</para>
            </value>
        </member>
        <member name="P:System.MessageBus.PortSendStages.Transmit">
            <summary>
            <para>Where the <see cref="T:System.MessageBus.Message"/> is transmitted to another endpoint.</para>
            </summary>
            <value>
               <para>http://schemas.microsoft.com/mb/2002/07/PortSendStages.Transmit</para>
            </value>
        </member>
        <member name="T:System.MessageBus.PortSendStatusStages">
            <summary>
               <para>Defines initial stages for all Port send status 
                  channels. Stages are in the following order: Handler (first), Spy (last).</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PortSendStatusStages.GetStages">
            <summary>
               <para>Returns the initial set of Port send status channel 
                  stages in order.</para>
            </summary>
            <returns>
               <para>An array of stages, ordered according to their relative place in the 
                  pipeline. </para>
            </returns>
        </member>
        <member name="P:System.MessageBus.PortSendStatusStages.Spy">
            <summary>
            <para>Where debugging and/or spy mechanisms hook the <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <value>
               <para>http://schemas.microsoft.com/mb/2002/07/PortSendStatusStages.Spy</para>
            </value>
        </member>
        <member name="P:System.MessageBus.PortSendStatusStages.Handler">
            <summary>
            <para>Where the application <see cref="T:System.MessageBus.IMessageHandler"/> processes the exception <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <value>
               <para>http://schemas.microsoft.com/mb/2002/07/PortSendStatusStages.Handler</para>
            </value>
        </member>
        <member name="T:System.MessageBus.PriorityRoute">
             <summary> 
            Route with weights and priorities amongst destinations.
            </summary>
        </member>
        <member name="F:System.MessageBus.PriorityRoute.PolicyStartTagName">
            <summary>
               <para>The name that is used to denote a policy statement of this type</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PriorityRoute.#ctor(System.Uri,System.MessageBus.PriorityRouteEntry[])">
            <summary>
               <para>Initializes a new instance of the <see cref="T:System.MessageBus.PriorityRoute"/> class.</para>
            </summary>
            <param name="destination">The URI for which this is a route.</param>
            <param name="nextHops">The URIs where a message that matches this route may be forwarded.</param> 
        </member>
        <member name="M:System.MessageBus.PriorityRoute.#ctor(System.Uri,System.MessageBus.PriorityRouteEntry[],System.MessageBus.Filter)">
            <summary>
               <para>Initializes a new instance of the <see cref="T:System.MessageBus.PriorityRoute"/> class.</para>
            </summary>
            <param name="destination">The URI for which this is a route.</param>
            <param name="nextHops">The URIs where a message that matches this route may be forwarded.</param> 
            <param name="filter">Additional logic to qualify this route.</param>
        </member>
        <member name="M:System.MessageBus.PriorityRoute.#ctor(System.Uri,System.MessageBus.PriorityRouteEntry[],System.Boolean)">
            <summary>
               <para>Initializes a new instance of the <see cref="T:System.MessageBus.PriorityRoute"/> class.</para>
            </summary>
            <param name="destination">The URI for which this is a route.</param>
            <param name="nextHops">The URIs where a message that matches this route may be forwarded.</param> 
            <param name="continueProcessing">Continue looking for more specific routes even if this route matches.</param>
        </member>
        <member name="M:System.MessageBus.PriorityRoute.#ctor(System.Uri,System.MessageBus.PriorityRouteEntry[],System.MessageBus.Filter,System.Boolean)">
            <summary>
               <para>Initializes a new instance of the <see cref="T:System.MessageBus.PriorityRoute"/> class.</para>
            </summary>
            <param name="destination">The URI for which this is a route.</param>
            <param name="nextHops">The URIs where a message that matches this route may be forwarded.</param> 
            <param name="filter">Additional logic to qualify this route.</param>
            <param name="continueProcessing">Continue looking for more specific routes even if this route matches.</param>
        </member>
        <member name="M:System.MessageBus.PriorityRoute.#ctor(System.Uri,System.MessageBus.PriorityRouteEntry[],System.MessageBus.Filter,System.Boolean,System.Guid)">
            <summary>
               <para>Initializes a new instance of the <see cref="T:System.MessageBus.PriorityRoute"/> class.</para>
            </summary>
            <param name="destination">The URI for which this is a route.</param>
            <param name="nextHops">The URIs where a message that matches this route may be forwarded.</param> 
            <param name="filter">Additional logic to qualify this route.</param>
            <param name="continueProcessing">Continue looking for more specific routes even if this route matches.</param>
            <param name="routeID">The unique ID of this route.</param>
        </member>
        <member name="M:System.MessageBus.PriorityRoute.SerializeToPolicy(System.Xml.XmlWriter)">
            <summary>
               <para>Writes out this route to policy</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PriorityRoute.GetNextHops(System.MessageBus.Message)">
            <summary>
               <para>Returns where the message should go next</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PriorityRoute.DeserializeFromPolicy(System.MessageBus.Policy,System.Xml.XmlNode)">
            <summary>
               <para>Recreate the route from the policy and the associated XML.</para>
            </summary>
            <param name='policy'>Policy where this route is being deserialized from</param>
            <param name='node'>Route specific Xml</param>
        </member>
        <member name="T:System.MessageBus.PriorityRouteEntry">
            <summary>
               <para>Route entry that allows setting priority and weight for the nextHop.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.PriorityRouteEntry.#ctor(System.Uri)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.PriorityRouteEntry"/> class.</para>
            </summary>
            <param name="nextHop">The URI which this route entry represents.</param>
        </member>
        <member name="M:System.MessageBus.PriorityRouteEntry.#ctor(System.Uri,System.Int32)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.PriorityRouteEntry"/> class.</para>
            </summary>
            <param name="nextHop">The URI which this route entry represents.</param>
            <param name="priority">The priority of this route entry compared to others. Higher number =&gt; Higher priority.</param>
        </member>
        <member name="M:System.MessageBus.PriorityRouteEntry.#ctor(System.Uri,System.Int32,System.Int32)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.PriorityRouteEntry"/> class.</para>
            </summary>
            <param name="nextHop">The URI which this route entry represents.</param>
            <param name="priority">The priority of this route entry compared to others. Higher number =&gt; Higher priority.</param>
            <param name="weigth">The weigth of this route entry compared to others. Higher the weight the greater the probability of this entry being chosen.</param>
        </member>
        <member name="P:System.MessageBus.PriorityRouteEntry.Enabled">
            <summary>
               <para>true - This route entry is available for use. Messages may be forwarded to the URI represented by this entry
               false - otherwise</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.PriorityRouteEntry.Priority">
            <summary>
               <para>Priority of this route entry</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.PriorityRouteEntry.Weight">
            <summary>
               <para>Weight of this route entry</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.ReferencePolicyStatement">
            <summary>
               <para>Policy statement that refers to a Policy Profile.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.ReferencePolicyStatement.#ctor(System.Uri)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.ReferencePolicyStatement"/> class.</para>
            </summary>
            <param name="url">Points to the policy profile.</param>
        </member>
        <member name="M:System.MessageBus.ReferencePolicyStatement.#ctor(System.Xml.XmlReader)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.ReferencePolicyStatement"/> class.</para>
            </summary>
            <param name="reader">Points to a reference policy statement XML element.</param>
            <remarks>
               <para> Positioned at the beginning of a reference policy statement element.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.ReferencePolicyStatement.WriteTo(System.Xml.XmlWriter)">
            <summary>
               <para>Serializes the Reference Policy Statement to XML.</para>
            </summary>
            <param name='writer'>Points to where reference policy statement XML element should be written.</param>
        </member>
        <member name="M:System.MessageBus.ReferencePolicyStatement.BeginResolveReferencedProfile(System.MessageBus.PolicyManager,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for ResolveReferencedProfile.</para>
            </summary>
            <param name='policyManager'>Policy Manager to be used to access profile.</param>
            <param name=' callback'>See asynchronous design pattern.</param>
            <param name=' state'>See asynchronous design pattern.</param>
            <returns>
               <para> See asynchronous design pattern.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.ReferencePolicyStatement.EndResolveReferencedProfile(System.IAsyncResult)">
            <summary>
               <para>Asynchronous end for ResolveReferencedProfile.</para>
            </summary>
            <param name='result'>See asynchronous design pattern.</param>
            <returns>
               <para>Policy Profile to which this refers.</para>
            </returns>
        </member>
        <member name="M:System.MessageBus.ReferencePolicyStatement.ResolveReferencedProfile(System.MessageBus.PolicyManager)">
            <summary>
               <para>Returns the Policy Profile to which this refers.</para>
            </summary>
            <param name='policyManager'>Policy Manager to be used to access profile.</param>
            <remarks>
               <para>Policy Manager will either have the referenced policy profile in a cache or 
                  will fetch it.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.ReferencePolicyStatement.Url">
            <summary>
               <para>Gets or sets the URL reference to the Policy Profile.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.RequestManager">
            <summary>
               <para>Factory for SendRequestChannels.</para>
            </summary>
            <remarks>
               <para>A RequestManager generates SendRequestChannel(s) that 
                  provide a simple means to send request messages and wait for corresponding
                  reply messages. These channels may resend if a maximum amount of time to wait is
                  exceeded while waiting for a given reply, and will raise an exception if an
                  overall maximum amount of time to wait is exceeded for a given reply. These
                  timeouts (and whether to resend) are set in the RequestManager before a given
                  SendRequestChannel is created.</para>
               <para>One must create the underlying Port separately and must explicitly open that 
                  Port before creating any SendRequestChannel(s).</para>
               <para>RequestManager (and SendRequestChannel) is a requester (client-side) concept; 
                  the recipient of the request message may construct a reply using the
                  CreateReverseChannel method of a Port.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.RequestManager.#ctor">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.RequestManager"/> class.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RequestManager.#ctor(System.MessageBus.Port)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.RequestManager"/> class.</para>
            </summary>
            <param name="port">The port to use to send requests and receive replies.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="port"/> is null.</exception>
        </member>
        <member name="M:System.MessageBus.RequestManager.CreateSendRequestChannel(System.Uri)">
            <summary>
               <para>Creates a Request Channel to a given server.</para>
            </summary>
            <param name='to'> Destination of requests.</param>
            <remarks>
               <para>Equivalent to CreateSendRequestChannel(to, timeout), where timeout is the 
                  value of the Timeout property.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.RequestManager.CreateSendRequestChannel(System.Uri,System.TimeSpan)">
            <summary>
               <para>Creates a Request Channel to a given server with an overall maximum amount of 
                  time to wait for a reply.</para>
            </summary>
            <param name='to'>Destination of requests.</param>
            <param name=' timeout'>Overall maximum amount of time to wait for a reply.</param>
            <remarks>
               <para>Equivalent to CreateSendRequestChannel(to, timeout, retry), where retry is 
                  the value of the Retry property.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.RequestManager.CreateSendRequestChannel(System.Uri,System.TimeSpan,System.Boolean)">
            <summary>
               <para>Creates a Request Channel to a given server that retries each 
                  request with an overall maximum amount of time to wait for a reply.</para>
            </summary>
            <param name='to'>Destination of requests.</param>
            <param name=' timeout'>Overall maximum amount of time to wait for a reply.</param>
            <param name=' retry'>Whether to resend a request if there is no reply.</param>
            <remarks>
               <para>Equivalent to CreateSendRequestChannel(to, timeout, retry, retryInterval), 
                  where retryInterval is the value of the RetryInterval property.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.RequestManager.CreateSendRequestChannel(System.Uri,System.TimeSpan,System.Boolean,System.TimeSpan)">
            <summary>
               <para>Creates a Request Channel to a given server that retries each request after a 
                  maximum amount of time, with an overall maximum amount of time to wait for a
                  reply.</para>
            </summary>
            <param name='to'>Destination of requests.</param>
            <param name='timeout'>Overall maximum amount of time to wait for a reply.</param>
            <param name='retry'>Whether to resend a request if there is no reply.</param>
            <param name='retryInterval'>Maximum amount of time to wait before resending a request.</param>
        </member>
        <member name="P:System.MessageBus.RequestManager.Port">
            <summary>
               <para>Gets or sets the Port used to send requests and receive replies.</para>
            </summary>
            <exception cref="T:System.Exception">If one tries to set this property but the property is already an open Port.</exception>
            <remarks>
               <para>The Port must be constructed separately and explicitly opened.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.RequestManager.Retry">
            <summary>
               <para>Gets or sets whether requests should be retried.</para>
            </summary>
            <remarks>
               <para>Retry must not be set to true unless the request messages are idempotent.</para>
               <para>This property may be set through configuration.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.RequestManager.RetryInterval">
            <summary>
               <para>Gets or sets the maximum amount of time to wait for a 
                  reply before retrying the request.</para>
            </summary>
            <remarks>
               <para> 
                  RetryInterval is ignored if Retry if false.</para>
               <para>Typically, the RetryInterval is smaller than the overall Timout property. If 
                  the RetryInterval is greater than or equal to the Timeout, the entire request
                  will timeout before the request is retried.</para>
               <para>This property may be set through configuration. </para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.RequestManager.Timeout">
            <summary>
               <para>Gets or sets the maximum amount of time to wait for a 
                  reply before raising an exception.</para>
            </summary>
            <remarks>
               <para>This property may be set through configuration.</para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.RoleType">
            <summary>
               <para>Specifies the role a Policy takes.</para>
            </summary>
            <remarks>
               <para>Next Policies are treated differently from the rest. They are applied to a message after all others have 
                  been applied during the next hop processing stage by the Policy Manager.</para>
            </remarks>
        </member>
        <member name="F:System.MessageBus.RoleType.All">
            <summary>
               <para>Policy applies when the endpoint is in any role (not 
                  applied twice to top most role).</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.RoleType.Next">
            <summary>
               <para>Policy applies when the endpoint is in the next hop endpoint only.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.RoleType.Primary">
            <summary>
               <para>Policy applies when the endpoint is the bottom most via 
                  (first) endpoint only.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.RoleType.Intermediary">
            <summary>
               <para>Policy applies when the endpoint is not the first (bottom 
                  most via) endpoint.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.RoutedMessageType">
            <summary>
               <para>Indicates what type of message the router is 
                  routing.Different message types go through different processing logic when being routed.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.RoutedMessageType.Normal">
            <summary>
               <para>A message that does not invoke any special processing.</para>
            </summary>
        </member>
        <member name="F:System.MessageBus.RoutedMessageType.GetPolicy">
            <summary>
               <para>A message sent to retrieve policy. The router does the 
                  extra work of merging its scope with the scope of the policy returned by the endpoint.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.RouteEntryCollection">
            <summary>
               <para>A collection of route entries.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RouteEntryCollection.Contains(System.MessageBus.RouteEntry)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RouteEntryCollection.CopyTo(System.MessageBus.RouteEntry[],System.Int32)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RouteEntryCollection.IndexOf(System.MessageBus.RouteEntry)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.RouteEntryCollection.Item(System.Int32)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.RouteEventArgs">
            <summary>
               <para>This EventArgs class is passed to the RouteEventHandler 
                  when the Route event is fired. It includes the destination of the message and
                  the list of endpoints of the message.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.RouteEventArgs.Destination">
            <summary>
               <para>The URI from the message's routing header that was used for matching</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.RouteEventArgs.Message">
            <summary>
               <para>The message being forwarded</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.RouteEventArgs.Recipients">
            <summary>
               <para>The set of recipients that the message will be forwarded to</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.RouteEventArgs.RouteID">
            <summary>
               <para>The unique ID of the route that was matched to the message</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.RouteEventArgs.RoutedMessageType">
            <summary>
               <para>The type of message being routed</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.RouteEventHandler">
            <summary>
               <para>Represents the method that a consumer of the router uses 
                  to register for routing events.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.RoutePolicyStatement">
            <summary>
               <para>This class encapsulates routing policy for a given route. The policy manager
                  uses the RoutePolicyStatement to write out a route to policy.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RoutePolicyStatement.#ctor(System.String,System.String,System.MessageBus.Route)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.RoutePolicyStatement"/> class.</para>
            </summary>
            <param name="name">The XML element name for the Route Policy Statement.</param>
            <param name=" nameSpace">The namespace for the XML element.</param>
            <param name=" route">The route to be included in the policy.</param>
        </member>
        <member name="M:System.MessageBus.RoutePolicyStatement.WriteTo(System.Xml.XmlWriter)">
            <summary>
               <para>Serializes the Policy Statement to XML.</para>
            </summary>
            <param name='writer'>Points to where the Policy Statement should be written.</param>
        </member>
        <member name="P:System.MessageBus.RoutePolicyStatement.Route">
            <summary>
               <para>Gets the Route in this Route Policy Statement.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.Router">
            <summary>
               <para>Central class for Message Bus routing functionality. 
                  When instantiated, adds it self as both a MB Port extension, and as a MB Policy
                  extension (if available).</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Router.#ctor">
            <summary>
               <para> Router is not useful until Port property 
                  is set.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Router.#ctor(System.MessageBus.Port)">
            <summary>
               <para> Router is unable to generate routing policy or consume 
                  it until PolicyManager is set.</para>
            </summary>
            <param name='Port'> Used by router to send and receive messages.</param>
        </member>
        <member name="M:System.MessageBus.Router.#ctor(System.MessageBus.Port,System.MessageBus.PolicyManager)">
            <summary>
               <para>Constructs completely initialized router.</para>
            </summary>
            <param name='Port'><para>See description in previous constructors</para></param>
            <param name='PolicyManager'><para>Used to generate and process routing policy</para></param>
        </member>
        <member name="M:System.MessageBus.Router.AcquireRoutingTableReaderLock">
            <summary>
               <para>Intrinsically, the routing table is not thread safe. If 
                  code that manipulates the table by adding or deleting table
                  entries acquires appropriate lock, the code will be thread safe.
                  Locks routing table for reading so that nobody else can modify it</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Router.AcquireRoutingTableWriterLock">
            <summary>
               <para>Locks routing table for modification.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Router.ReleaseRoutingTableReaderLock">
            <summary>
               <para>Releases read lock</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.Router.ReleaseRoutingTableWriterLock">
            <summary>
               <para>Releases write lock</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Router.PolicyManager">
            <summary>
               <para>The policy manager this router is associated with</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Router.Port">
            <summary>
               <para>The port this router is associated with</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.Router.RoutingTable">
            <summary>
               <para>The Router's routing table</para>
            </summary>
        </member>
        <member name="E:System.MessageBus.Router.Route">
            <summary>
               <para>Public event that interested parties may subscribe to. 
               This event is fired whenever an incoming message successfully matches the routes in the
               router and is to be forwarded. The event is fired before the actual forwarding happens.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.RoutingHeader">
            <summary>
            <para>Represents a WS-Routing <see cref="T:System.MessageBus.MessageHeader"/> .</para>
            </summary>
            <remarks>
            <para>Consistent with the overall design pattern that a <see cref="T:System.MessageBus.Message"/> does 
               not have an explicit destination, an application typically does not explicitly
               add a RoutingHeader. Instead, when a <see cref="T:System.MessageBus.Message"/> is sent using a <see cref="T:System.MessageBus.Port"/>, an appropriate
               RoutingHeader is added automatically.</para>
            <para>An <see cref="T:System.Exception"/> 
            is defined for each fault defined by WS-Routing. When a <see cref="T:System.MessageBus.Message"/> is received that contains
            WS-Routing fault, the fault is represented as a <see cref="T:System.MessageBus.MessageException"/>; the <see cref="T:System.Exception"/> may not be raised. When a WS-Routing-defined problem
            occurs while processing the <see cref="T:System.MessageBus.Message"/>, the <see cref="T:System.Exception"/> is raised and the corresponding fault may be
            created.</para>
            <para>See WS-Routing for more detail.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.#ctor">
            <overload>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.RoutingHeader"/> class.</para>
            </overload>
            <summary>
               <para>Initialize a new RoutingHeader.</para>
            </summary>
            <remarks>
            <para>Equivalent to RoutingHeader(<see langword="null"/>, 
            <see langword="null"/>).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.#ctor(System.MessageBus.Via)">
            <summary>
               <para> Initialize a new RoutingHeader with a destination.</para>
            </summary>
            <param name="to">The <see cref="T:System.MessageBus.Via"/> that represents a <see cref="T:System.MessageBus.Message"/> destination.</param>
            <remarks>
            <para>Equivalent to RoutingHeader(<paramref name="to"/>, <see langword="null"/>).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.#ctor(System.MessageBus.Via,System.MessageBus.Via)">
            <summary>
               <para>Initialize a new RoutingHeader with a destination and a source.</para>
            </summary>
            <param name="to">The <see cref="T:System.MessageBus.Via"/> that represents a <see cref="T:System.MessageBus.Message"/> destination</param>
            <param name=" from">The <see cref="T:System.MessageBus.Via"/> that represents a <see cref="T:System.MessageBus.Message"/> source</param>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.#ctor(System.MessageBus.RoutingHeader)">
            <summary>
               <para>Initializes one RoutingHeader given another.</para>
            </summary>
            <param name='source'>The RoutingHeader to be copied</param>
            <remarks>
               <para>This constructor creates a new RoutingHeader by copying 
                  over property values from another RoutingHeader. Only property values defined in
                  the RoutingHeader class are copied. This may be useful in implementing
                  Clone.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.Clone">
            <summary>
               <para>Creates a new RoutingHeader that is a deep copy of the current instance.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.WriteTo(System.Xml.XmlWriter)">
            <summary>
               <para>Serialize the RoutingHeader.</para>
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/>to serialize the RoutingHeader into</param>
            <remarks>
               <para>Serialize the RoutingHeader as XML using a default 
                  encoding.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.CreateEndpointGoneException(System.MessageBus.RoutingHeader,System.Uri)">
            <summary>
               <para> Creates an in-memory representation of the WS-Routing 
                  Endpoint Gone Fault.</para>
            </summary>
            <param name="header">The RoutingHeader that contains the invalid information</param>
            <param name=" endpoint">The endpoint that raised the fault</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="header"/> or <paramref name="endpoint"/> are <see langword="null"/></exception>
            <remarks>
               <para>The Routing Header must be </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.CreateEndpointMovedException(System.MessageBus.RoutingHeader,System.Uri,System.Uri[])">
            <summary>
               <para>Creates an in-memory representation of the WS-Routing 
                  EndPoint Moved Fault.</para>
            </summary>
            <param name="header">The RoutingHeader that contains the invalid information</param>
            <param name=" endpoint">The endpoint that raised the fault</param>
            <param name=" alternates">Alternate endpoints for the requested endpoint </param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="header"/> is <see langword="null"/></exception>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.CreateEndpointNotFoundException(System.MessageBus.RoutingHeader,System.Uri)">
            <summary>
               <para>Creates an in-memory representation of the WS-Routing 
                  Endpoint Not Found Fault.</para>
            </summary>
            <param name="header">The RoutingHeader that contains the invalid information</param>
            <param name=" endpoint">The endpoint that raised the fault</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="header"/> or <paramref name="endpoint"/> are <see langword="null"/></exception>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.CreateEndpointNotSupportedException(System.MessageBus.RoutingHeader,System.Uri)">
            <summary>
               <para>Creates an in-memory representation of the WS-Routing 
                  Endpoint Not Supported Fault.</para>
            </summary>
            <param name="header">The RoutingHeader that contains the invalid information</param>
            <param name=" endpoint">The endpoint that raised the fault</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="header"/> or <paramref name="endpoint"/> are <see langword="null"/></exception>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.CreateEndpointTooLongException(System.MessageBus.RoutingHeader,System.Int32)">
            <summary>
               <para>Creates an in-memory representation of the WS-Routing 
                  Endpoint Too Long Fault.</para>
            </summary>
            <param name="header">The RoutingHeader that contains the invalid information</param>
            <param name=" endpoint">The endpoint that raised the fault</param>
            <param name=" maxSize">Maximum acceptable size of the endpoint <see cref="T:System.Uri"/> in number of characters</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="header"/> is <see langword="null"/></exception>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.CreateForwardingEndpointNotReachableException(System.MessageBus.RoutingHeader,System.Uri)">
            <summary>
               <para>Creates an in-memory representation of the WS-Routing 
                  Forwarding Endpoint Not Reachable Fault.</para>
            </summary>
            <param name="header">The RoutingHeader that contains the invalid information</param>
            <param name=" endpoint">The endpoint that raised the fault</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="header"/> or <paramref name="endpoint"/> are <see langword="null"/></exception>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.CreateForwardingReversePathUnavailableException(System.MessageBus.RoutingHeader)">
            <summary>
               <para>Creates an in-memory representation of the WS-Routing 
                  Forwarding Reverse Path Unavailable Fault.</para>
            </summary>
            <param name="header"> The current RoutingHeader</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="header"/> is <see langword="null"/></exception>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.CreateMessageInvalidException(System.MessageBus.RoutingHeader)">
            <summary>
               <para>Creates an in-memory representation of the WS-Routing 
                  Message Invalid Fault.</para>
            </summary>
            <param name="header"> The current RoutingHeader</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="header"/> is <see langword="null"/></exception>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.CreateMessageLoopDetectedException(System.MessageBus.RoutingHeader)">
            <summary>
               <para>Creates an in-memory representation of the WS-Routing 
                  Message Loop Detected Fault.</para>
            </summary>
            <param name="header">The RoutingHeader that contains the invalid information</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="header"/> is <see langword="null"/></exception>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.CreateMessageTimeoutException(System.MessageBus.RoutingHeader,System.TimeSpan)">
            <summary>
               <para>Creates an in-memory representation of the WS-Routing 
                  Message Timeout Fault.</para>
            </summary>
            <param name="header"> The current RoutingHeader</param>
            <param name=" maxTime">Maximum acceptable amount of time</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="header"/> is <see langword="null"/></exception>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.CreateMessageTooLargeException(System.MessageBus.RoutingHeader)">
            <summary>
               <para>Creates an in-memory representation of the WS-Routing 
                  Message Too Large Fault.</para>
            </summary>
            <param name="header"> The current RoutingHeader</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="header"/> is <see langword="null"/></exception>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.CreateProcessingFailureException(System.MessageBus.RoutingHeader)">
            <summary>
               <para>Creates an in-memory representation of the WS-Routing 
                  Processing Failure Fault.</para>
            </summary>
            <param name="header">The RoutingHeader that contains the invalid information</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="header"/> is <see langword="null"/></exception>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.CreateReceiverTooBusyException(System.MessageBus.RoutingHeader,System.TimeSpan)">
            <summary>
               <para>Creates an in-memory representation of the WS-Routing 
                  Receiver Too Busy Fault.</para>
            </summary>
            <param name="header">The RoutingHeader that contains the invalid information</param>
            <param name=" retryAfter">When the receiver is expected to be less busy</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="header"/> is <see langword="null"/></exception>
        </member>
        <member name="M:System.MessageBus.RoutingHeader.CreateReceiverUnavailableException(System.MessageBus.RoutingHeader,System.TimeSpan)">
            <summary>
               <para>Creates an in-memory representation of the WS-Routing 
                  Receiver Unavailable Fault.</para>
            </summary>
            <param name="header">The RoutingHeader that contains the invalid information</param>
            <param name=" retryAfter">When the receiver is expected to be able to service the incoming message</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="header"/> is <see langword="null"/></exception>
        </member>
        <member name="P:System.MessageBus.RoutingHeader.Action">
            <summary>
            <para>Gets and sets the action of the <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <value>
            <para>The <see cref="T:System.Uri"/> that represents the action of the <see cref="T:System.MessageBus.Message"/> .</para>
            </value>
            <remarks>
               <para>This property indicates the type of the WS-Routing 
                  message in a manner similar to the "action" media type parameter defined by the
                  "application/soap+xml" media type. May be <see langword="null"/>.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.RoutingHeader.Fault">
            <summary>
               <para>Gets and sets any fault information that may be 
                  contained in the RoutingHeader.</para>
            </summary>
            <value>
            <para>The <see cref="T:System.Xml.XmlNode"/> containing the fault information.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.RoutingHeader.ForwardPath">
            <summary>
               <para>Gets the collection of endpoints in the forward path.</para>
            </summary>
            <value>
            <para>A <see cref="T:System.MessageBus.ViaCollection"/> representing an ordered set of intended 
               destinations for a <see cref="T:System.MessageBus.Message"/>.</para>
            </value>
        </member>
        <member name="P:System.MessageBus.RoutingHeader.LogicalHop">
            <summary>
            <para>Gets the next logical destination of a <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <remarks>
            <para>The next logical endpoint along the forward <see cref="T:System.MessageBus.Message"/> path, e.g., ForwardPath 
               [0].</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.RoutingHeader.PhysicalHop">
            <summary>
               <para>Gets and sets the next physical destination of a 
               <see cref="T:System.MessageBus.Message"/> .</para>
            </summary>
            <remarks>
               <para>Initially the LogicalHop but may be rewritten to be the physical address of 
                  the next logical endpoint.</para>
               <para>A physical destination may not appear on the forward 
                  path. A physical destination may correspond to a back-end server or to an
                  intermediary that provides routing but does not affect <see cref="T:System.MessageBus.Message"/>
                  processing.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.RoutingHeader.ReversePath">
            <summary>
               <para>Gets the collection of endpoints in the reverse path.</para>
            </summary>
            <value>
            <para>A <see cref="T:System.MessageBus.ViaCollection"/> representing an ordered set of previous 
               destinations for a <see cref="T:System.MessageBus.Message"/>.</para>
            </value>
        </member>
        <member name="T:System.MessageBus.RoutingTable">
            <summary>
               <para>Table of routes in the router.</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RoutingTable.#ctor">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RoutingTable.Add(System.MessageBus.Route)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RoutingTable.Contains(System.MessageBus.Route)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RoutingTable.Contains(System.Guid)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RoutingTable.CopyTo(System.MessageBus.Route[],System.Int32)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RoutingTable.IndexOf(System.MessageBus.Route)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RoutingTable.Insert(System.Int32,System.MessageBus.Route)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RoutingTable.Remove(System.MessageBus.Route)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RoutingTable.OnRemoveComplete(System.Int32,System.Object)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RoutingTable.OnClearComplete">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RoutingTable.OnInsertComplete(System.Int32,System.Object)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RoutingTable.OnSetComplete(System.Int32,System.Object,System.Object)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="M:System.MessageBus.RoutingTable.OnValidate(System.Object)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.RoutingTable.Item(System.Int32)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.RoutingTable.Item(System.Guid)">
            <summary>
               <para>[To be supplied.]</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.SendRequestChannel">
            <summary>
               <para>Channel to send requests and receive replies.</para>
            </summary>
            <remarks>
               <para>A SendRequestChannel provides a simple means to send 
                  request <see cref="T:System.MessageBus.Message"/>s to an endpoint and wait for a corresponding
                  reply <see cref="T:System.MessageBus.Message"/>
                  s. A request may be re-sent
                  if a maximum amount of time to wait is exceeded while waiting for a reply; if
                  there are multiple replies, the first reply received is returned, and the rest are discarded. If an overall maximum amount of time to wait is exceeded for a given
                  reply, an exception is raised.</para>
               <para>SendRequestChannels are created by calling methods of a 
               <see cref="T:System.MessageBus.RequestManager"/> . The 
                  overall timeout and retry behavior are set when the SendRequestChannel is
                  created.</para>
               <para> SendRequestChannel is a requester (client-side) concept; 
                  the recipient of the request <see cref="T:System.MessageBus.Message"/> may construct a reply using the
                  CreateReverseChannel method of a <see cref="T:System.MessageBus.Port"/>
                  .</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.SendRequestChannel.BeginSendRequest(System.MessageBus.Message,System.AsyncCallback,System.Object)">
            <summary>
               <para>Asynchronous begin for SendRequest.</para>
            </summary>
            <param name="message">Request message.</param>
            <param name=" callback">See Asynchronous Design Pattern. </param>
            <param name=" state">See Asynchronous Design Pattern. </param>
            <returns>
               <para>See Asynchronous Design Pattern. </para>
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="message"/> is null.</exception>
        </member>
        <member name="M:System.MessageBus.SendRequestChannel.EndSendRequest(System.IAsyncResult)">
            <summary>
               <para>Asychronous end for SendRequest.</para>
            </summary>
            <param name="result">See Asynchronous Design Pattern.</param>
            <returns>
            <para>Reply <see cref="T:System.MessageBus.Message"/> .</para>
            </returns>
            <remarks>
            <para>The reply <see cref="T:System.MessageBus.Message"/> must be closed by the caller of this 
               method.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.SendRequestChannel.SendRequest(System.MessageBus.Message)">
            <summary>
               <para>Send a request and wait for the reply.</para>
            </summary>
            <param name="message">The <see cref="T:System.MessageBus.Message"/> that is a request.</param>
            <returns>
            <para>Reply <see cref="T:System.MessageBus.Message"/> .</para>
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="message"/> is null.</exception>
            <remarks>
            <para>The reply <see cref="T:System.MessageBus.Message"/> must be closed by the caller of this method. </para>
            </remarks>
        </member>
        <member name="T:System.MessageBus.SoapConstants">
            <summary>
            Central location for constants used in SOAP text/xml.
            </summary>
        </member>
        <member name="T:System.MessageBus.Stage">
            <summary>
            <para> A well-defined placeholder in sequential <see cref="T:System.MessageBus.Message"/> processing.</para>
            </summary>
            <remarks>
            <para>A Stage represents a named, well-defined placeholder in sequential <see cref="T:System.MessageBus.Message"/> 
            processing. A Stage has a unique name and is ordered within an array of Stages.
            To indicate the ordering of <see cref="T:System.MessageBus.IMessageHandler"/>s, each <see cref="T:System.MessageBus.IMessageHandler"/> is associated with exactly one Stage; to
            avoid ambiguity in the ordering, each Stage must have at most one associated
            <see cref="T:System.MessageBus.IMessageHandler"/>. A Stage may have no associated <see cref="T:System.MessageBus.IMessageHandler"/>; such unused Stages are eliminated when the 
            <see cref="T:System.MessageBus.PipelineBuilder"/> constructs a <see cref="T:System.MessageBus.Pipeline"/>.</para>
            <para>Other classes define sets of Stages that may be used (e.g., <see cref="T:System.MessageBus.PortReceiveStages"/>), but applications are free to define their 
            own Stages to be used with a <see cref="T:System.MessageBus.PipelineBuilder"/>.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Stage.#ctor(System.Uri)">
            <summary>
            <para> Initializes a new instance of the <see cref="T:System.MessageBus.Stage"/> class.</para>
            </summary>
            <param name=" uri">The <see cref="T:System.Uri"/> that is the name of the Stage</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="uri"/> is <see langword="null"/></exception>
        </member>
        <member name="M:System.MessageBus.Stage.Equals(System.Object)">
            <summary>
               <para> Compares two Stages for equality.</para>
            </summary>
            <param name=' obj'>The Stage to compare to this instance</param>
            <returns>
            <para><see langword='true'/> if <paramref name="obj"/> is equal to this 
               Stage instance; otherwise, <see langword='false'/> .</para>
            </returns>
            <remarks>
               <para> This overload enables the '== ' and '!=' operators.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.Stage.GetHashCode">
            <summary>
               <para> A hash function for Stage.</para>
            </summary>
            <remarks>
               <para>This overload enables the '== ' and '!=' operators.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.Stage.Name">
            <summary>
               <para> Gets the name of the Stage.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.StageAlias">
            <summary>
            <para>Represents a refinement of one <see cref="T:System.MessageBus.Stage"/> into one or more other 
            <see cref="T:System.MessageBus.Stage"/> s.</para>
            </summary>
            <remarks>
            <para>To reduce the need for central coordination of <see cref="T:System.MessageBus.Stage"/> definitions, a <see cref="T:System.MessageBus.Stage"/> may be 
               refined into one or more other <see cref="T:System.MessageBus.Stage"/>s, in effect providing finer-grained
               placeholders for sequential <see cref="T:System.MessageBus.Message"/> processing.</para>
            <para>A StageAlias refines one <see cref="T:System.MessageBus.Stage"/> into a (potentially empty) array of 
            <see cref="T:System.MessageBus.Stage"/>s. A 
            StageAlias includes the original (to be refined) <see cref="T:System.MessageBus.Stage"/>, an array of new
            <see cref="T:System.MessageBus.Stage"/>s 
            representing the refinement, and an optional indication of the placement of the
            original <see cref="T:System.MessageBus.Stage"/>
            within the order of the new <see cref="T:System.MessageBus.Stage"/>s. </para>
            <para>If the original <see cref="T:System.MessageBus.Stage"/> is to be retained in the new array of 
            <see cref="T:System.MessageBus.Stage"/>s, then 
            exactly one of the new <see cref="T:System.MessageBus.Stage"/>s is marked as the placeholder, or alias, for
            the original <see cref="T:System.MessageBus.Stage"/>. (Thus the name "StageAlias" for the class.)
            If there is no alias in the new array of <see cref="T:System.MessageBus.Stage"/>s, then the original <see cref="T:System.MessageBus.Stage"/> is effectively deleted.</para>
            <para>Including an alias in the new array of <see cref="T:System.MessageBus.Stage"/>s allows one to insert <see cref="T:System.MessageBus.Stage"/>s before and/or after the 
            original <see cref="T:System.MessageBus.Stage"/>. Note that this allows inserting zero or more
            <see cref="T:System.MessageBus.Stage"/>s before a <see cref="T:System.MessageBus.Stage"/>, zero or more 
            <see cref="T:System.MessageBus.Stage"/>s after, and/or deleting a <see cref="T:System.MessageBus.Stage"/>. </para>
            <para>StageAliases may be chained, where one StageAlias 
               refines a <see cref="T:System.MessageBus.Stage"/> defined by another StageAlias. However, to
               avoid ambiguity in the overall <see cref="T:System.MessageBus.Stage"/> ordering, it is
               an error if the original <see cref="T:System.MessageBus.Stage"/> referenced by a
               StageAlias is not defined. Similarly, it is an error if more than one StageAlias
               attempts to refine the same <see cref="T:System.MessageBus.Stage"/>. </para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.StageAlias.#ctor(System.MessageBus.Stage,System.MessageBus.Stage,System.MessageBus.Stage[])">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.StageAlias"/> class.</para>
            </summary>
            <param name="stage">Original <see cref="T:System.MessageBus.Stage"/> to be refined</param>
            <param name=" alias">The new <see cref="T:System.MessageBus.Stage"/> that indicates the relative position of <paramref name="stage"/> in <paramref name="stages"/> </param>
            <param name=" stages">New array of <see cref="T:System.MessageBus.Stage"/>s</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="stage"/>, <paramref name="alias"/>, or <paramref name="stages"/> are <see langword="null"/></exception>
        </member>
        <member name="P:System.MessageBus.StageAlias.Alias">
            <summary>
            <para>The placeholder <see cref="T:System.MessageBus.Stage"/>
            .</para>
            </summary>
            <remarks>
            <para>This <see cref="T:System.MessageBus.Stage"/> is in the new array of <see cref="T:System.MessageBus.Stage"/>s. The 
               relative position of this <see cref="T:System.MessageBus.Stage"/> in the new array of <see cref="T:System.MessageBus.Stage"/>s indicates the relative
               position of any <see cref="T:System.MessageBus.IMessageHandler"/> attached to the original <see cref="T:System.MessageBus.Stage"/>.</para>
            </remarks>
        </member>
        <member name="P:System.MessageBus.StageAlias.Stage">
            <summary>
            <para>The original <see cref="T:System.MessageBus.Stage"/> to be refined.</para>
            </summary>
        </member>
        <member name="P:System.MessageBus.StageAlias.Stages">
            <summary>
            <para>Gets the new array of <see cref="T:System.MessageBus.Stage"/> s.</para>
            </summary>
        </member>
        <member name="T:System.MessageBus.SystemInfo">
            <summary>
            Common class from which to extract system information not readily available from the top-level framework
            </summary>
        </member>
        <member name="T:System.MessageBus.TextXmlEncoding">
            <summary>
               <para>Message encoding corresponding to SOAP Envelopes.</para>
            </summary>
            <remarks>
            <para><see cref="T:System.MessageBus.TextXmlEncoding"/> represents a clear text, XML <see cref="T:System.MessageBus.MessageEncoding"/> of a SOAP Envelope. It includes details like 
               character set encoding (e.g., UTF-8) following RFC 2376.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.TextXmlEncoding.#ctor(System.Text.Encoding)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.TextXmlEncoding"/> class.</para>
            </summary>
            <param name="encoding">The <see cref="T:System.Text.Encoding" qualify="true"/> that describes the character encoding of the message.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="encoding"/> is null.</exception>
        </member>
        <member name="P:System.MessageBus.TextXmlEncoding.ContentType">
            <summary>
               <para>Gets the media content type.</para>
            </summary>
            <value>
               <para>new ContentType("text/xml")</para>
            </value>
        </member>
        <member name="P:System.MessageBus.TextXmlEncoding.Encoding">
            <summary>
               <para>Gets the character encoding.</para>
            </summary>
            <value>
            <para>The <see cref="T:System.Text.Encoding" qualify="true"/> of the message.</para>
            </value>
        </member>
        <member name="T:System.MessageBus.TimeoutException">
            <summary>
            TimeoutException is thrown when an operation times out
            </summary>
        </member>
        <member name="M:System.MessageBus.UnsafeNativeMethods.GetProcessAffinityMask(System.IntPtr,System.IntPtr@,System.IntPtr@)">
            <summary>
            KERNEL32.DLL
            </summary>
        </member>
        <member name="T:System.MessageBus.UriGenerator">
            <summary>
               <para>Efficiently generates globally-unique URIs.</para>
            </summary>
            <remarks>
               <para> A UriGenerator efficiently 
                  creates globally-unique URIs. </para>
               <para>By default, the URIs created use the "uuid:" URI scheme, but this may be 
                  overriden when in the UriGenerator constructor. In a constructor, one may also
                  specify a prefix to be shared across all the URIs created by a UriGenerator.
                  URIs created are of the form <paramref name="scheme"/>, ":", <paramref name="prefix"/> (if any), a field common to all URIs created by
                  this generator, and a suffix unique to each URI.</para>
               <para>Each new URI is created by calling the Next method of a UriGenerator.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.UriGenerator.#ctor">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.UriGenerator"/> class.</para>
            </summary>
            <remarks>
               <para>Equivalent to UriGenerator("uuid").</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.UriGenerator.#ctor(System.String)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.UriGenerator"/> class.</para>
            </summary>
            <param name="scheme">Scheme for all URIs to be created.</param>
            <remarks>
               <para>Equivalent to UriGenerator(scheme, null).</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.UriGenerator.#ctor(System.String,System.String)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.UriGenerator"/> class.</para>
            </summary>
            <param name="scheme">Scheme for all URIs to be created.</param>
            <param name=" prefix">Prefix for all URIs to be created.</param>
        </member>
        <member name="M:System.MessageBus.UriGenerator.Next">
            <summary>
               <para>Creates a unique URI from a UriGenerator.</para>
            </summary>
            <returns>
            <para>A globally-unique URI of the form <paramref name="scheme"/>, 
               ":", <paramref name="prefix"/> (if any), a field common to all URIs created by this
               generator, and a suffix unique to each URI. (<paramref name="scheme"/> and <paramref name="prefix"/>
               are set in the UriGenerator constructor.)</para>
            </returns>
        </member>
        <member name="T:System.MessageBus.XmlPolicyStatement">
            <summary>
               Represents a Policy Statement internally in XML.
            </summary>
            <remarks>
               <para>This is for Policy.Load. Policy Statements that cannot otherwise be parsed 
                  are put in this format.</para>
            </remarks>
        </member>
        <member name="M:System.MessageBus.XmlPolicyStatement.#ctor(System.Xml.XmlReader)">
            <summary>
            <para>Initializes a new instance of the <see cref="T:System.MessageBus.XmlPolicyStatement"/> class.</para>
            </summary>
            <param name="statement">An XML reader positioned at the Policy Statement XML element to be read.</param>
        </member>
        <member name="M:System.MessageBus.XmlPolicyStatement.WriteTo(System.Xml.XmlWriter)">
            <summary>
               <para>Serializes this Policy Statement to XML</para>
            </summary>
            <param name='writer'>Points to where the Policy Statement should be written.</param>
        </member>
        <member name="M:System.MessageBus.XmlPolicyStatement.GetXmlReader">
            <summary>
               <para>Returns an XML reader over this Policy Statement.</para>
            </summary>
        </member>
    </members>
</doc>
